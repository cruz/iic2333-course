---
title: 1 - Administración de Procesos
layout: slide
---


section
	h2 Procesos
	/  --------



section
	h2 ¿Qué es un Proceso?
	/  -------------------

	section
		p.fragment Un programa en ejecución

		blockquote.fragment style="background:#B7E1CD;" 
			| Proceso = Código (programa) + Recursos

		ul.fragment
			li El código del programa
			li Los recursos de la ejecución
			ul.fragment
				li Memoria, archivos
				li Sockets, Dispositivos, Librerías (...)



section
	h2 Composición y representación
	/  -----------------------------

	section
		/div ¿Qué hay en un Proceso?

		div style="border:none; width:70%; vertical-align:middle; display:inline-block;" 

			ul.fragment
				li <b>Código</b> (<em>.text</em>, información estática)
				li <b>Datos</b> (<em>.data</em>): variables globales
				li <b>Stack</b>. Cada item del stack representa una función, y contiene:
				ul
					li Parámetros
					li Variables locales
					li Lugar de retorno (donde estaba la ejecución anterior, PC)
				li <b>Heap</b>. Memoria asignada dinámicamente (durante la ejecución)

		img src='/images/figures/01-3_01.pdf.png' width="25%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"



section#states
	h2 Estados
	/  -------


	section#states-inside
		div Un proceso en ejecución puede cambiar de estado

		ul
			li <b>New       </b>: En creación
			li <b>Running   </b>: En ejecución
			li <b>Waiting   </b>: Esperando (I/O, signal)
			li <b>Ready     </b>: Listo para ejecutar. Esperando asignación de CPU
			li <b>Terminated</b>: Ejecución terminada

		img src='/images/figures/01-3_02.pdf.png' width="60%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"


	section#states-status
		p ¿Cómo averiguo el estado de un proceso?

		p Desde un terminal
		pre
			code.hljs.lang-bash
				| $ htop
				  $ top
				  $ ps aux
		
		p Con un Administrador de Procesos

		img src='/images/figures/01-taskman-linux.jpg' width="30%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"
		div style="display:inline-block;" &nbsp; &nbsp; &nbsp; &nbsp; 
		img src='/images/figures/01-taskman-win.png' width="30%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"

	/section#states-status
	/	p ¿Cómo averiguo el estado de un proceso?

	/	.fragment
	/		p Desde un terminal
	/		pre
	/			code.hljs.lang-bash
	/				| $ htop || top || ps aux
	/	.fragment
	/		p En C
	/		pre
	/			code.hljs.lang-c
	/				| #include "sys/types.h"
	/				  #include "sys/wait.h"
	/				  /* ... */
	/				  int status;
	/				  pid_t return_pid = waitpid(process_id, /*out*/ &status, WNOHANG);
	/				  
	/				  switch(return_pid) {
	/				    case 0:
	/				      /* Still running */
	/				    case process_id:
	/				      /* Child terminated. Exit status in 'status' */
	/				    case -1:
	/				    default:
	/				      /* Error */
	/				  }
	/	.fragment
	/		p O con un Administrador de Procesos


section#repr
	h3 Representación de Procesos
	/  --------------------------

	section#repr-PCB
		div ¿Cómo represento un proceso?

		blockquote.fragment style="background:#F4C7C3;"<b>Process Control Block (PCB)</b>

		div style="border:none; width:60%; vertical-align:middle; display:inline-block;" 

			ul.fragment
				li Estado
				li Identificador (PID, <i>Process ID</i>)
				li Program Counter (PC)
				li Registros de CPU: <em>estado de ejecución</em>
				li Información de <em>scheduling</em>: prioridades, tipo de cola, &hellip;
				li Información de memoria: límites, tabla de páginas/segmentos, &hellip;
				li Contabilidad (<em>accounting</em>)
				li Información de I/O: archivos y dispositivos abiertos, &hellip;

		img src='/images/figures/01-3_03.pdf.png' width="15%" style="background:none; box-shadow:none; vertical-align:middle;"

		p.fragment Miremos en <a href="https://github.com/torvalds/linux/blob/master/include/linux/sched.h" target="_blank"><code>include/linux/sched.h</code></a>


	section#repr-contextSwitch
		p El cambio de procesos se conoce como <strong>Context Switch</strong>
		== image_tag '/images/figures/01-3_04.pdf.png', :width=>"50%", :style=>"border:none;"



section#creation
	h2 Creando procesos
	/  ----------------

	section#creation-0
		p Creación de procesos: ¿el huevo o la gallina?
		ul
			li.fragment  ¿Quién crea un proceso?...     <span class="fragment"> otro proceso</span>
			li.fragment  ¿Quién crea ese otro proceso?  <span class="fragment"> otro proceso</span>
			li.fragment  ¿Quién crea ese otro proceso?  <span class="fragment"> otro proceso&hellip;</span>

		p.fragment Existe un proceso llamado <code>init</code>, construido durante la inicialización del kernel. PID=1.
		/! Salvo Windows por supuesto, que usa el 4.
		ul.fragment
			li Linux: systemd, init, upstart
			li MacOS X: launchd
			li Windows: InitialSystemProcess, System

	section#creation-tree
		p Como todos los procesos tienen un padre, forman un árbol de procesos
		pre
			code.hljs
				| $ pstree --show-pids
		pre
			code.hljs
				| systemd(1)─┬─crond(572)───rsync(984)
				             ├─dbus-daemon(563)
				             ├─konsole(30672)───zsh(30675)───tmux(11098)
				             ├─systemd(756)─┬─ncmpcpp(759)
				             │              └─emacs(773)─┬─aspell(798)
				             │                           └─{gmain}(774)
				             ├─systemd-logind(573)
				             └─tmux(11100)─┬─zsh(9853)
				                           └─zsh(11221)───vim(13615)


	section#creation-init
		p Un proceso (padre) crea a un proceso (hijo).
		ul
			li.fragment ¿Quién sigue ejecutando? 
			ul
				li.fragment Padre e hijo continúan ejecutando concurrentemente
				li.fragment Padre espera que algunos o todos sus hijos terminen
			li.fragment ¿Qué personalidad tiene el hijo? (espacio de direcciones)
			ul
				li.fragment El hijo es un duplicado <a href="http://linux.die.net/man/2/fork" target="_blank">casi</a> exacto del padre
				li.fragment El hijo es un nuevo programa


	section#creation-syscalls
		
		blockquote.fragment style="background:#B7E1CD;" Syscall <a href="http://linux.die.net/man/2/fork" target="_blank"><code>fork()</code></a>

		ul.fragment
			li Crea un nuevo proceso como <strong>copia</strong> del padre.
			li Ambos continúan ejecutando desde la instrucción posterior a <code>fork()</code>
			li La llamada retorna el <code>PID</code> del hijo al padre y <code>0</code> al hijo

		blockquote.fragment style="background:#B7E1CD;" Syscall <a href="http://linux.die.net/man/2/execve" target="_blank"><code>exec()</code></a>
		
		ul.fragment
			li Carga un binario en memoria <strong>reemplazando</strong> el código de quien lo llamó, e inicia su ejecución.
			li El programa nuevo se "roba" el proceso (la memoria se sobreescribe)



	section#creation-fork-l-q
		p ¿Qué imprime este programa?

		pre
			code.hljs.lang-c
				| int a = 42;
				  
				  pid_t child_pid = fork(); /* create new process */
				  if (child_pid == 0) { /* child gets 0 */
				    a++;
				    printf("CHILD: a is : %d\n", a); /* ??? */
				  }
				  else if(child_pid > 0) { /* parent gets the new pid */
				    printf("PARENT: child_pid is %d\n", child_pid);
				    printf("PARENT: a is %d\n", a); /* ??? */
				  }


	section#creation-fork-loop-q
		p ¿Cuántos procesos se crean?

		pre
			code.hljs.lang-c
				| /* ... */
				  for(int i=0; i<4; i++) {
				    fork();
				    printf("[%4d] %d\n", getpid(), i);
				  }


	/section#creation-fork-q
		p ¿Qué hacen estos programas? (*)
		p <small>asumiendo que fork no falla</small>
		pre
			code.hljs.lang-c
				| while(fork())
				    exec("date");
				  /* ... */
		pre
			code.hljs.lang-c
				| while(!fork())
				    exec("date");
				  /* ... */


	section#creation-wait
		p Después del <code>fork()</code>, uno de los procesos (el hijo) podría ejecutar un <code>exec()</code>.
		ul.fragment
			li El padre conoce el <strong>pid</strong> del hijo
			li El padre podría seguir ejecutando y crear más hijos
			li &hellip; o bien esperar que el hijo termine (o muera)
		== image_tag '/images/figures/01-3_10.pdf.png', :style=>"border:none;"


	section#creation-wait-def


		blockquote style="background:#B7E1CD;" Syscall <a href="http://linux.die.net/man/2/fork" target="_blank"><code>fork()</code></a>

		div Clona el procesos (<b>copia</b> del padre)

		blockquote style="background:#B7E1CD;" Syscall <a href="http://linux.die.net/man/2/execve" target="_blank"><code>exec()</code></a>

		div Reemplaza el proceso por otro (sobreescribe)

		blockquote.fragment style="background:#B7E1CD;" Syscall <a href="http://linux.die.net/man/2/wait" target="_blank"><code>wait()</code></a>

		div.fragment Espera el término de un proceso hijo

	section#creation-shell

		div Código simplificado de una <i>shell</i>:

		img src='/images/figures/01-shell.png' width="75%" style="background:none; box-shadow:none; vertical-align:middle;"



section#termination
	h2 Terminando procesos
	/  -------------------

	section#termination-0
		p.fragment Todo proceso, al terminar su ejecución, ejecuta <code>exit()</code>
		ul.fragment
			li Entrega un <em>código de retorno</em> (¿para qué?)
			li El Sistema Operativo recupera todos los recursos asignados

		p.fragment El código de retorno se utiliza para avisar cómo resultó la ejecución
		ul.fragment
			li Generalmente es <code>0</code> cuando no hubo problemas
			li Y un número distinto de <code>0</code> para indicar un problema
			li La documentación del programa debería relacionar errores a códigos de retorno.
			li También se le llama <em>código de error</em>.

	section#termination-syscalls


		blockquote style="background:#B7E1CD;" Syscall <a href="http://linux.die.net/man/2/fork" target="_blank"><code>fork()</code></a>

		div Clona el procesos (<b>copia</b> del padre)

		blockquote style="background:#B7E1CD;" Syscall <a href="http://linux.die.net/man/2/execve" target="_blank"><code>exec()</code></a>

		div Reemplaza el proceso por otro (sobreescribe)

		blockquote style="background:#B7E1CD;" Syscall <a href="http://linux.die.net/man/2/wait" target="_blank"><code>wait()</code></a>

		div Espere el término de un proceso hijo

		blockquote.fragment style="background:#B7E1CD;" Syscall <a href="http://linux.die.net/man/2/exit" target="_blank"><code>exit()</code></a>

		div.fragment Termina el proceso con un código de retorno dado, y lo entrega al padre


	section#termination-signals

		div Un proceso puede enviar <i>señales</i> (<a href="http://www.comptechdoc.org/os/linux/programming/linux_pgsignals.html" target="_blank"><b>signal</b></a>s) a otros procesos

		blockquote.fragment style="background:#B7E1CD;" Syscall <a href="http://linux.die.net/man/2/kill" target="_blank"><code>kill()</code></a>
		
		ul.fragment
			li Envía una <strong>señal</strong> (<code>kill -l</code> muestra una lista)a otro proceso (típicamente <em>SIGTERM</em>)
			li Se puede especificar la señal (<em>SIGKILL</em> no tiene piedad)

		img.fragment src='/images/figures/01-signals.png' width="50%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"



	section#termination-q
		p Si el padre muere, ¿deben morir los hijos?

		ul.fragment
			li Sistema Operativo podría permitir (o no) que un hijo exista si el padre ha terminado.
			li Sin embargo, <a href="http://unix.stackexchange.com/questions/158727/is-there-any-unix-variant-on-which-a-child-process-dies-with-its-parent" target="_blank">podría parecer que los hijos sí mueren</a>.

		blockquote.fragment style="background:#B7E1CD;" Procesos <b>huérfanos</b>

		ul.fragment
			li Linux: Cuando un padre termina (<code>exit</code>) o muere (<code>kill</code>), sus hijos quedan <b>huérfanos</b> y pasan a ser hijos de <code>init</code>
			li Sin embargo, <a href="http://unix.stackexchange.com/questions/158727/is-there-any-unix-variant-on-which-a-child-process-dies-with-its-parent" target="_blank">podría parecer que los hijos sí mueren</a> (las condiciones pueden ser complicadas).
			li <code>init</code> hace <code>wait()</code> periódicamente por sus hijos.

		blockquote.fragment style="background:#B7E1CD;" Procesos <b>zombies</b>

		ul.fragment
			li Linux: Cuando un proceso termina y su padre no hace <code>wait()</code>.
			li Proceso terminado no se borra inmediatamente de la tabla de procesos (pero tampoco ejecuta).
			li Proceso queda en estado <b>zombie</b> hasta que el padre hace <code>wait()</code>.


	section#termination-necromancy
		p Creando un zombie

		pre
			code.hljs.lang-c style="max-height:600px;"
				| #include &lt;stdlib.h&gt;
				  #include &lt;sys/types.h&gt;
				  #include &lt;unistd.h&gt;
				  int main () {
				    pid_t child_pid;
				 
				    /* Create child*/
				    child_pid = fork ();
				    if (child_pid > 0) {
				      /* Parent process */
				      sleep (60);
				    }
				    else {
				      /*Child process. Exit immediately. */
				      exit (0);
				    }
				    return 0;
				  }



	section#termination-necromancy2
		p Creando zombies

		pre 
			code.hljs.lang-c style="max-height:600px;"
				| #include &lt;sys/wait.h&gt;
				  #include &lt;stdlib.h&gt;
				  #include &lt;unistd.h&gt;
				  
				  pid_t pids[10];
				  void main() {
				    
				    for (int i=9; i>=0; i--)
				      if ((pids[i]=fork()) == 0) { /* pid == 0, only child enters */
				         sleep(i+1);   /* Wait and terminate */
				         exit(0);
				      }
				    
				    for (int i=9; i>=0; i--)       /* Only root process reaches */
				      waitpid(pids[i], NULL, 0);   /* First wait [9] is the longest */

				  }




/section#_ipc
	h2 Comunicación entre procesos (IPC)
/    =================================
/section#ipc
	h2 Comunicación entre procesos (IPC)
	/  ---------------------------------

	section#ipc-0
		p <em>InterProcess Comunication (IPC)</em>

		p.fragment Si hay multiprogramación, hay múltiples procesos "en ejecución"
		/''\footnote{ya sabemos que esto no es estrictamente correcto}
		ul
			li.fragment Procesos <strong>independientes</strong> no provocan problemas &hellip;
			li.fragment procesos <strong>cooperativos</strong> requieren <strong>comunicación inter-procesos</strong>

		p.fragment Dos modelos fundamentales de IPC:
		ul
			li.fragment <strong>Memoria compartida</strong> (<em>shared memory</em>)
			li.fragment <strong>Paso de mensajes</strong> (<em>message passing</em>)


	section#ipc-shm_vs_mp
		p Memoria compartida vs. Paso de mensajes

		p Memoria Compartida
		p.fragment data-fragment-index="1" Procesos acuerdan un espacio de memoria donde ambos pueden escribir
		ul
			li.fragment data-fragment-index="3" Más rápido que paso de mensajes (sólo un <em>syscall</em> para crearla)
			li.fragment data-fragment-index="5" Requiere coordinar accesos


		p
		span.fragment.fade-in data-fragment-index="0" 
			span.fragment.fade-out data-fragment-index="1"
				small Fight!

		p Paso de Mensajes
		p.fragment data-fragment-index="2" Procesos se envían mensajes
		ul
			li.fragment data-fragment-index="4" Requiere <em>Syscall</em>s <code>send</code>/<code>recv</code>
			li.fragment data-fragment-index="6" Fácil de programar para envíos pequeños (no provoca conflictos)


	section#ipc-shm_vs_mp-fig
		== image_tag '/images/figures/01-3_12.pdf.png'


/section#ipc-_shm
	h2 Memoria Compartida

	section#ipc-shm
		p ¿Escribir en memoria de otro proceso?

		ul.fragment
			li Procesos $A$ y $B$ deben <strong>acordar</strong> permitirse acceso
			li Proceso $A$ designa una región de su espacio de memoria como <em>compartida</em>
			li Proceso $B$ agrega esa región como parte de su espacio
			li $A$ y $B$ se preocupan de coordinar los accesos

		p.fragment API POSIX provee syscall para crear y exponer regiones de memoria compartida
		ul.fragment
			li <em>Memory-mapped files</em>
			li <code>shm_open()</code>, <code>ftruncate()</code>, <code>mmap()</code>, <code>shm_unlink()</code>


	/section#ipc-shm-prod_cons
	/	p Un problema clásico de coordinación

	/	p
	/		em Problema del productor y consumidor
	/	ul.fragment
	/		li Proceso <strong>productor</strong> produce información.
	/		li Proceso <strong>consumidor</strong> consume información del productor.
	/	pre
	/		== image_tag '/images/figures/01-ProdCons.png'
	/	.fragment
	/		p Variantes: con <strong>buffer limitado</strong> ó <strong>ilimitado</strong>
	/		ul
	/			li.fragment Con <strong>buffer limitado</strong> el productor puede tener que esperar



	/section#ipc-shm-prod_cons-code
	/	p Buffer limitado (<em>bounded</em>) en memoria compartida
	/	pre
	/		code.hljs.lang-c
	/			| #define BUFFER_SIZE 10
	/			  
	/			  typedef struct {
	/			    /* ... */
	/			  } item;
	/			  
	/			  item buffer[BUFFER_SIZE];
	/			  int in = 0;     // proxima posicion libre
	/			  int out = 0;    // primera posicion llena
	/	p ¿Cuándo está lleno el buffer? ¿Cuándo está vacío?


	/section#ipc-shm-prod_cons-code-prod
	/	p Proceso <strong>productor</strong>
	/	pre
	/		code.hljs.lang-c
	/			| item next_product;
	/			  while(true) {
	/			    next_product = produce();
	/			    while ( ((in+1)%BUFFER_SIZE) == out);  /* !!! */
	/			    
	/			    buffer[in] = next_product;
	/			    in = (in+1)%BUFFER_SIZE;
	/			  }


	/section#ipc-shm-prod_cons-code-cons
	/	p Proceso <strong>consumidor</strong>

	/	pre
	/		code.hljs.lang-c
	/			| item next_consumed;
	/			  
	/			  while(true) {
	/			    while(in == out); /* !!! */
	/			    
	/			    next_consumed = buffer[out];
	/			    out = (out+1)%BUFFER_SIZE;
	/			    
	/			    consume(next_consumed);
	/			  }
	/	p ¿Cuántos ítemes puede haber como máximo en el <em>buffer</em>?



/section#ipc-_mp
	h2 Paso de mensajes

	section#ipc-mp
		p.fragment Abstracción de <em>mensaje</em>. Dos primitivas:

		ul.fragment
			li <code>send(message)</code>
			li <code>receive(message)</code>

		/p.fragment ¿Cómo habilitar la comunicación? Varios aspectos a decidir
		/ul
		/	li.fragment Comunicación directa o indirecta
		/	ul
		/		li.fragment <code>send(P, message)</code>, <code>recv(Q, message)</code>, <code>recv(&id, message)</code>
		/		li.fragment <code>send(A, message)</code>, <code>recv(A, message)</code>
		/	li.fragment Comunicación síncrona o asíncrona


	section#ipc-mp-d-u
		p Comunicación directa vs indirecta

		p.fragment data-fragment-index="0" Con <strong>comunicación directa</strong>, cada proceso debe conocer el <em>nombre</em> del otro
		ul.fragment
			li <code>send(P, message)</code>
			li <code>receive(Q, message)</code>
		p.fragment Este esquema es <strong>simétrico</strong><span class="fragment">. Variante <em>asimétrica</em>: <code>receive(&id, message)</code></span>

		p.fragment data-fragment-index="0" Con <strong>comunicación indirecta</strong> utiliza abstracción de <em>mailbox</em> o <em>port</em>
		ul.fragment
			li <code>send(A, message)</code>
			li <code>receive(A, message)</code>
		p.fragment Ambos deben poseer un referencia al <em>mailbox</em> <code>A</code>


	section#ipc-mp-sync
		p Comunicación síncrona vs asíncrona

		p.fragment Tanto <code>send()</code> como <code>receive()</code> pueden ser <strong>bloqueantes</strong> (síncrono) o <strong>no bloqueantes</strong> (asíncrono)

		ul
			li.fragment <code>send</code> <strong>bloqueante</strong>: bloquea hasta que el mensaje es recibido
			li.fragment <code>send</code> <strong>no-bloqueante</strong>: envía y continúa
			li.fragment <code>recv</code> <strong>bloqueante</strong>: espera hasta recibir un mensaje
			li.fragment <code>recv</code> <strong>no-bloqueante</strong>: recibe un mensaje inmediatamente o <code>null</code>



	/section#ipc-mp-buf
	/	p Comunicación <em>buffered</em> o <em>unbuffered</em>

	/	p.fragment Sistemas Operativos usan <em>colas</em> temporales para transmitir mensajes
	/	ul
	/		li.fragment <strong>Cola de capacidad cero</strong>: fuerza <code>send()</code> bloqueante
	/		li.fragment <strong>Cola de capacidad limitada</strong>: máximo de $n$ mensajes encolados mientras no sean recibidos.
	/		ul
	/			li.fragment Si se llena, el siguiente <code>send()</code> se bloquea
	/		li.fragment <strong>Cola de capacidad ilimitada</strong>: cola potencialmente infinita


/section#ipc-hl
/	h2 Más comunicación inter-procesos
/	small Algunas técnicas de más alto nivel


/	section#ipc-hl-sockets
/		p.fragment <strong>Sockets</strong>: punto de comunicación de servicios

/		ul
/			li.fragment Indexado
/			li.fragment Comunicación cliente/servidor
/			li.fragment Para comunicación TCP o UDP
			/ \footnote{Si no sabe que es esto, búsquelo en Google o espere hasta los capítulos de redes}
/		== image_tag '/images/figures/01-3_20.pdf.png', :width=>"50%", :style=>"float:right;"


/	section#ipc-hl-rpc
/		p <strong>RPC</strong>: Remote Procedure Call
		/ \footnote{Más de esto en IIC2523, Sistemas Distribuidos}
/		ul
/			li.fragment Comunicación a nivel de funciones (métodos) en otro proceso
/			li.fragment Requiere un intermediario (<em>matchmaker/portmapper</em>) para ubicar los proveedores del método remoto
/			li.fragment Versión <em>object oriented</em>: <strong>RMI</strong>, <em>Remote Method Invocation</em>
/			li.fragment Mismo esquema usado por <em>Web Services</em>

/		== image_tag '/images/figures/01-RPC.png', :width=>"40%"


/	section#ipc-hl-rpc
/		p <strong>Pipes</strong>: <em>tubo</em> entre dos procesos

/		ul
/			li.fragment  Unidireccionales o bidireccionales
/			li.fragment  Un proceso escribe en un extremo (<em>write-end</em>), y otro proceso lee desde el otro extremo (<em>read-end</em>)
/			li.fragment  Pueden ser tratadas como archivos
/			li.fragment  Implementación implícita en consolas. Ej: <code>ls | more</code>
/		== image_tag '/images/figures/01-pipes.png'




/ Frame
  //   \frametitle{Desafío \#1: Fork de Procesos}
  //   %\framesubtitle{Algunos puntos clave}
  //
  //   \begin{enumerate}
  //     li.fragment  Entrar a sitio del curso en \url{http://edx.ing.puc.cl}.
  //     li.fragment  Construir un código único en C que cree un proceso que permita crear un árbol binario de procesos con $3$ niveles.
  //       ul
  //         li.fragment  Nivel 1: Proceso padre, $P_0$ crea dos hijos $P_1$, $P_2$
  //         li.fragment  Nivel 2: $P_1$ y $P_2$ crean dos hijos cada uno
  //         li.fragment  Nivel 3: Procesos hoja imprimen su PID, su PPID, y un mensaje de despedida.
  //         li.fragment  Cada proceso padre debe esperar a los hijos
  //         li.fragment  Cuando todos los descendientes han terminado, el padre debe mostrar la hora actual (<code>date</code>)
  //         li.fragment  Bonus si funciona para $N$ niveles
  //     li.fragment  Pueden hacerlo en conjuntos de $N$, $1 \leq N \leq 3$.

section#scheduling
	h2 Scheduling

	section#scheduling-init
		p <i>CPU Scheduling</i> a.k.a. Planificación de CPU

		div style="width:60%; vertical-align:middle; display:inline-block;" 

			div.fragment

				div Tenemos
			
				ul
					li Procesos en memoria (<i>multiprogramación</i>), ordenado en una tabla de PCBs
					li Algunos procesos en estado <i>ready</i> (listos para ejecutar)
					li CPU, que puede atender <b>solo un proceso</b> a la vez

			div.fragment

				div Y queremos:

				ul
					li <i>Multitasking</i>: asignar tiempo a múltiples procesos

		img src='/images/figures/01-pcbs.gif' width="40%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"

		blockquote.fragment style="background:#B7E1CD;"Sistema Operativo debe elegir cuál de todos los procesos en estado <b>ready</b> debe ejecutar a continuación: <b>scheduling</b>

	section
		div Responsable: <b>scheduler</b>, a.k.a.  <i>planificador</i>

		div <em>Scheduling</em> puede ser visto como un sistema de <em>manejo de colas</em>

		== image_tag '/images/figures/01-3_06.pdf.png', :width=>"50%", :style=>"border:none; box-shadow:none;"

	section
		div Distintos niveles de <i>scheduling</i> en el sistema operativo:

		div style="width:50%; vertical-align:middle; display:inline-block;" 

			ul.fragment
				li <b>Long-term Scheduler</b>:  Admite procesos en la <em>cola ready</em>. Determina el <strong>grado de multiprogramación</strong> (cantidad de procesos en memoria).
				li <b>Short-term Scheduler</b> (a.k.a. <b>dispatcher</b>): Selecciona un proceso de la cola <em>ready</em> para ejecutar.
				li <b>Medium-term Scheduler</b>: Modificación temporal del grado de multiprogramación, haciendo <strong>swapping</strong>

		img src='/images/figures/01-schedulers.gif' width="50%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"


	section#cpuSched-thrsh
		p ¿Y si estamos siempre haciendo <em>Scheduling</em> en vez de ejecutar programas?

		div.fragment <em>Scheduling</em> es importante para <strong>multiprogramación</strong> y <b>multitasking</b> &hellip; <span class="fragment">pero <em>scheduling</em> y <em>context switch</em> <strong>son sólo <em>overhead</em></span></strong>

		ul
			li.fragment ¿Qué pasa si el <em>scheduler</em> o el <i>context switch</i> toman más tiempo de lo que toma el proceso?
			li.fragment ¿Qué pasa si se le asigna poco tiempo a cada proceso?
			li.fragment ¿Qué pasa si hay muchos procesos <em>ready</em>? (long-term scheduler)

		blockquote.fragment style="background:#B7E1CD;"
			| Contención de procesos se refleja en <strong>thrashing</strong>

		img.fragment src='/images/figures/01-thrashing.jpg' width="40%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"


	section#cpuSched-types
		h3 Modelo de ejecución de un proceso

		div No todos los procesos se comportan igual. Alternan entre dos fases:

		ul.fragment
			li Uso de CPU (<b>CPU-burst</b>)
			li Espera por I/O (<b>I/O-burst</b>)		

		div.fragment Procesos suelen estar dominados por una u otra etapa:

		img.fragment src='/images/figures/01-processtypes.png' width="70%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"

	section

		div El tiempo que gasta un proceso en espera influye en la utilización de CPU.

		blockquote.fragment style="background:#F4C7C3;" Una CPU bajo el 100% está subutilizada.

		div.fragment

			div $p$ es el porcentaje de tiempo en espera por I/O. 

			div $p^n$ probabilidad que $n$ procesos estén esperando por I/O.

			div Utilización de la CPU es $\text{CPU}_u = 1 - p^n$

		img.fragment src='/images/figures/01-utilization.png' width="40%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"

section#SchedTypes

	h2 Tipos de Scheduling

	section
		div Por tipo de interrupción

		blockquote.fragment style="background:#B7E1CD;" <b>Preemptive</b> (expropiativo)

		div.fragment Utiliza interrupciones (ej: de reloj (<i>timer</i>)) para decidir cuando sacar a un proceso de ejecución.

		blockquote.fragment style="background:#B7E1CD;" <b>Non-Preemptive</b> (colaborativo o no-expropiativo)

		div.fragment
			div Permite que un proceso ejecute hasta que:

			ul
				li El proceso deja voluntariamente la CPU, ó
				li El proceso se bloquea en I/O, ó
				li El proceso termina

	section
		div Por objetivo:

		div style="width:80%; vertical-align:middle; display:inline-block;" 

			blockquote.fragment style="background:#B7E1CD;" Batch Scheduling

			div.fragment
				div Trabajo por lotes. Sin interacción.
				ul
					li Mantener la CPU lo más ocupada posible
					li Minimizar <i>turnaround time</i>: tiempo desde envío hasta término.
					li Maximizar <i>throughput</i>: número de trabajos por hora

			blockquote.fragment style="background:#B7E1CD;" Interactive Scheduling

			div.fragment
				ul
					li Minimizar tiempo de respuesta
					li Satisfacer usuarios

			blockquote.fragment style="background:#B7E1CD;" Real time Scheduling

			div.fragment
				ul 
					li Alcanzar <i>deadlines</i>
					li Tiempo de respuesta debe ser predecible

		div style="width:20%; vertical-align:middle; display:inline-block;" 

			blockquote.fragment style="background:#B7E1CD;" Para todos

			div.fragment <b>Fairness</b>. Que todos los procesos tengan un tiempo razonable de ejecución.

section#SchedTypes

	h2 Algoritmo de Scheduling (Batch)

	section
		h3 First-Come, First-Served (FCFS)

		div Orden de llegada. Cola FIFO.

		div.fragment
			img src='/images/figures/01-fifo-table.png' width="40%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"

			img.fragment src='/images/figures/01-fifo-chart.png' width="40%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"

			div.fragment Turnaround time promedio: $109$

		div.fragment
			div Si P2 hubiese llegado en $t=0$, y P1 hubiese llegado en $t=1$, entonces <br><i>turnaround time promedio</i> $\to$ <span class="fragment">$79$

		br

		ul.fragment
			li Non-Preemptive
			li &#x1f44d; Simple
			li &#x1f44e; Poco predecible. <i>Convoy effect</i>

	section
		h3 Shortest Job First (SJF)

		div El más corto primero

		div.fragment
			img src='/images/figures/01-sjf-table.png' width="40%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"

			img.fragment src='/images/figures/01-sjf-chart.png' width="40%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"

			div.fragment Turnaround time promedio: $49$

		ul.fragment
			li &#x1f389; <b>Óptimo</b>
			li &#x1f62d; No sabemos cuánto demora cada <i>CPU-burst</i>
			li Versión preemptive: <b>Shortest Remaining Time Next</b>. Elige al que le queda menos tiempo.
			li &#x1f480; Potencial <b>inanición</b> (<i>starvation</i>) de procesos largos.

section#SchedTypes2

	h2 Algoritmo de Scheduling (Interactive)

	section 
		div Métrica: <b>tiempo de respuesta</b> (<i>response time</i>).

		div Tiempo desde llegada (a la cola) hasta primera ejecución.

		div.fragment
			img src='/images/figures/01-rr-table.png' width="40%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"

			img.fragment src='/images/figures/01-rr-chart.png' width="40%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"

			ul.fragment 
				li Turnaround time promedio: $9$
				li Response time promedio: $4$


	section 
		h3 Round-Robin (RR)

		div Un turno (<i>quantum</i>, <i>time slice</i>) para cada uno.

		div Ejemplo con $q=1$

		div.fragment
			img src='/images/figures/01-rr-table2.png' width="40%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"

			img.fragment src='/images/figures/01-rr-chart2.png' width="40%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"

			ul.fragment 
				li Turnaround time promedio: $13.9$
				li Response time promedio: $0.9$

		ul.fragment
			li Con $n$ procesos, cada uno recibe $1/n$ de CPU. <b>Fair!</b> &#x2696;
			li Ningún proceso espera más de $(n-1)\times q$ para ejecutar
			li Altamente dependiente de la elección de $q$ (¿qué pasa si $q$ es muy pequeño o muy grande?)

	section 
		h3 Priority Scheduling

		div Cada proceso tiene asociada una <strong>prioridad</strong>

		ul.fragment
			li Se atienden por orden de <strong>prioridad</strong>
			li Prioridades iguales: FCFS ó RR
			li SJF es un <em>caso particular</em> de este algoritmo (¿por qué?)
			li Prioridades pueden ser estáticas o dinámicas
			li &#x1f480; <b>Starvation</b> de procesos con baja prioridad
			li &#x1f474; <b>Aging</b>: incrementar prioridad de procesos que llevan más tiempo

		div.fragment <a href="https://linux.die.net/man/2/nice"><code>nice</code></a> permite reducir la prioridad de un proceso (incrementa su <i>niceness</i>)

	section
		h3 Multilevel Feedback Queue (MLFQ)

		blockquote <a href="https://en.wikipedia.org/wiki/Fernando_J._Corbat%C3%B3">Fernando J. Corbató</a> (Turing Award 1990) et al. <b>"An Experimental Time-Sharing System"</b>, IFIPS 1962.

		div Usado en CTSS (1962) y Multics (1965)

		blockquote style="background:#B7E1CD;" Scheduler que optimize <i>turnaround time</i> (como SJF), pero minimizando <i>response time</i> (como RR)

		div Múltiples colas con distinta prioridad

		ul.fragment
			li R1. Si $\text{priority}(A) > \text{priority}(B))$, ejecutar $A$
			li R2. Si $\text{priority}(A) = \text{priority}(B))$, ejecutar $A$ y $B$ con RR
			li R3. Procesos entran en la cola con <b>mayor</b> prioridad
			li R4. Si un proceso usa su $q$ (acumulado en todos sus turnos), su prioridad se reduce
			li R5. Después de un tiempo $S$, todos los procesos se mueven a la cola con mayor prioridad

	section
		h3 Multilevel Feedback Queue (MLFQ)

		img src='/images/figures/01-mlfq.png' width="30%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"

		div Base para schedulers de Windows y MacOSX

		ul
			li R1. Si $\text{priority}(A) > \text{priority}(B))$, ejecutar $A$
			li R2. Si $\text{priority}(A) = \text{priority}(B))$, ejecutar $A$ y $B$ con RR
			li R3. Procesos entran en la cola con <b>mayor</b> prioridad
			li R4. Si un proceso usa su $q$ (acumulado en todos sus turnos), su prioridad se reduce
			li R5. Después de un tiempo $S$, todos los procesos se mueven a la cola con mayor prioridad

	section
		h3 Otros ...

		ul
			li <b>Lottery </b> (1994). Procesos reciben tickets 
			li <b>Fair Share</b> (1988). Tiempo compartido entre grupos de procesos (usuarios)
			li <b>O(1)</b>. Dos colas de procesos. Activos y expirados. Linux 2.6, &lt; 2.6.23.
			li <b>Completely Fair Scheduler (CFS)</b> (2007). Linux &ge; 2.6.23. Procesos ordenados por su <i>virtual runtime</i>, que se calcula a partir de <i>niceness</i>, prioridad y tiempo de ejecución. Utiliza un <i>red-black tree</i> para mantener el orden.
			li <b>Brain Fuck Scheduler (BFS)</b> (2009). 


section#SchedTypes3
	h2 Algoritmos de Scheduling (Real time)

	section
		h3 Procesos Real Time

		ul
			li Poseen <i>deadlines</i> y periodos de ejecución
			li Sistema debe determinar si, dado <i>deadline</i> ($d$), periodo ($p$), y tiempo de ejecución ($t$),es capaz de incorporar el procesos a la ejecución.

		img src='/images/figures/01-rt-sched.png' width="75%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"


	section
		h3 Rate monotonic Scheduling

		img src='/images/figures/01-rt-sched-dead.png' width="75%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"

		div Cada proceso recibe prioridad: $\frac{t_i}{p_i}$

		div Con $P_1: \{p_1=50, t_1=20\}$, y $P_2: \{p_2=100, t_2=35\}$

		img src='/images/figures/01-rt-sched-rtm.png' width="75%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"


	section
		h3 Earliest Deadline First Scheduling (EDF)

		div <i>Rate Monotonic Scheduling</i> es <b>estático</b>. Podría perder <i>deadlines</i>

		div Con $P_1: \{p_1=50, t_1=25\}$, y $P_2: \{p_2=80, t_2=35\}$

		img src='/images/figures/01-rt-sched-rtm-dead.png' width="75%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"

	section
		h3 Earliest Deadline First Scheduling (EDF)

		div <i>Earliest Deadline First Scheduling</i> es <b>dinámico</b>. Elige siempre el que tiene <i>deadline</i> más cercano.

		div Con $P_1: \{p_1=50, t_1=25\}$, y $P_2: \{p_2=80, t_2=35\}$

		img src='/images/figures/01-rt-sched-edf.png' width="75%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"


section#threads
	h2 Threads

	section#threads-_init
		h2 <em>Threads</em> y <em>Multicores</em>

	section#threads-init
		p <strong><em>Thread</em></strong>: Como un proceso, pero más liviano.

		p.fragment Unidad básica de uso de CPU
		ul.fragment
			li  <em>Thread ID</em> (<strong>tid</strong>)
			li  Program Counter
			li  Registros
			li  <em>Stack</em>
		p.fragment El resto está compartido con otros <i>thread</i>s del mismo proceso.



	section#threads-mt
		p <em>Single-threading</em> vs <em>Multi-threading</em>

		p Procesos pueden tener uno o más <em>threads</em>
		== image_tag '/images/figures/01-4_01.pdf.png', :width=>"60%", :style=>"border:none; box-shadow:none;"


	section#threads-why
		
		blockquote style="background:#B7E1CD;" ¿Para qué <i>threads</i>?

		div.fragment data-fragment-index="1" Procesos complejos deben atender múltiples tareas
		ul.fragment data-fragment-index="1"
			li Programar con <i>thread</i>s puede hacer el código más simple
			ul.fragment data-fragment-index="2"
				li <em>Threads</em> pueden ejecutar distintas partes del código de un proceso
				li Apropiados para programación guiada por eventos
			li Programar con <i>thread</i>s puede ayudar a paralelizar/distribuir tareas
			ul.fragment data-fragment-index="3"
				li Cuidado. <i>Threads</i> no necesariamente ejecutan <b>al mismo tiempo</b>. 
				li Solo en presencia de múltiples CPU (cores) podría haber real concurrencia
				li Un programa con mútiples <i>threads</i> <i>podría ser más lento</i>

		blockquote.fragment data-fragment-index="4" style="background:#B7E1CD;" Entonces, ¿crear <i>threads</i> o procesos?
		ul.fragment data-fragment-index="5"
			li Creación/destrucción de <i>threads</i> es sustancialmente más liviana que un proceso

	section#threads-web-mt

		div <i>Multihreaded webserver</i> 

		== image_tag '/images/figures/01-webserver-mt.png', :width=>"40%", :style=>"border:none; box-shadow:none;"

		br

		== image_tag '/images/figures/01-webserver-mt-threads.png', :width=>"50%", :style=>"border:none; box-shadow:none;"



section#thread-models
	h2 Modelos de Threads

	section#mt-dataModels
		p <i>Threads</i> surgen de separar el concepto de recursos y ejecución
		ul.fragment
			li <b>Procesos</b> agrupan recursos (y ejecución)
			li <b>Threads</b> son solamente unidades de ejecución: <b>lightweight processes</b>


		== image_tag '/images/figures/01-threads-process-os.png', :width=>"50%", :style=>"border:none; box-shadow:none;"

	section
		blockquote style="background:#B7E1CD;" <i>Threads</i> comparten
		ul.fragment
			li Espacio de memoria
			li Variables globales (sección <i>data</i>)
			li Archivos abiertos
			li Procesos Hijo
			li Alarmas pendiente
			li Señales y manejadores de señales
			li Información de <i>accountability</i>

		blockquote style="background:#B7E1CD;" <i>Threads</i> <b>NO</b> comparten
		ul.fragment
			li <i>Stack</i>
			li <i>Registros</i> (incluyendo PC)
			li Estado

		div Información privada tiene que ver con <i>ejecución</i>. 

		div Información compartida tiene que ver con <i>recursos</i>

	section
		div ¿Cómo se mantienen múltiples <i>stacks</i>?

		== image_tag '/images/figures/01-threads-stacks.png', :width=>"50%", :style=>"border:none; box-shadow:none;"

	section
		blockquote style="background:#B7E1CD;" Funciones típicas de <i>threads</i>


		ul
			li <code>thread_create()</code>
			li <code>thread_exit()</code>
			li <code>thread_join()</code>
			li <code>thread_yield()</code>

	section#posix
		h3 POSIX Threads

		div Estándar IEEE 1003.1c. Librería <code>pthreads</code>

		== image_tag '/images/figures/01-pthreads.png', :width=>"50%", :style=>"border:none; box-shadow:none;"

		div Ejemplo: <a href="../examples/pthreads1.c" target="_blank">POSIX Threads en acción</a>

		div Ejemplo: <a href="../examples/pthreads2.c" target="_blank">POSIX Threads compartiendo memoria</a>

section#thread-impl
	h2 Implementación de threads

	section

		div Algunos aspectos no son obvios al diseñar un sistema de <i>multithreading</i>

		ul.fragment
			li Semántica de <code>fork()</code>, <code>exec</code>
			li Señales: ¿quién las recibe?
			li Bloqueos: ¿quién se bloquea?

	section

		div Dos opciones

		ul.fragment
			li <b>User</b> space
			li <b>Kernel</b> space
			li <b>Hybrid</b> (ok, 3 opciones)


	section#user

		h3 User space threads

		div style="width:70%; vertical-align:middle; display:inline-block;" 

			div.fragment
				div Implementados y manejados por una biblioteca de usuario
				div Kernel no ve <i>threads</i>. Solo ve procesos <i>single threaded</i>

			div.fragment
				ul
					li &#x1f603; Portable. Implementable en cualquier S.O.
					li &#x1f603; <i>Context switch</i> y <i>scheduling</i> más rápido.
					li &#x1f603; Mejor escalabilidad (usa memoria del proceso)
					li &#x1f61e; Llamadas a <i>syscall</i>s pueden bloquear el proceso
					li &#x1f61e; Requiere <i>scheduling</i> cooperativo (no hay timers)
					li Piensen en su uso en <i>multithreaded web server</i>
					li Implementaciones usan variante no-bloqueantes de algunas <i>syscall</i>s


		div style="width:30%; vertical-align:middle; display:inline-block;" 

			== image_tag '/images/figures/01-user-threads.png', :width=>"100%", :style=>"border:none; box-shadow:none;"


	section#kernel

		h3 Kernel space threads

		div style="width:70%; vertical-align:middle; display:inline-block;" 

			div.fragment
				div Implementados y manejados nativamente por estructuras del kernel
				div No necesita bibliotecas de usuario
				div <i>Syscall</i> manejados por el S.O.

			div.fragment
				ul
					li &#x1f603; No requiere bibliotecas. Soporte nativo.
					li &#x1f603; <i>Syscall</i>s no bloquean el proceso.
					li &#x1f61e; <i>Syscall</i>s más costosas. Requiere llamadas al kernel.
					li &#x1f61e; Escalabilidad limitada por el S.O.
					li &#x1f61e; Semántica de <code>fork()</code> no es clara.
					li &#x1f61e; Semántica de <code>signals</code> no es clara.

			div.fragment Implementaciones evitan crear y destruir <i>threads</i>. Kernel utiliza <i>thread pools</i> y reutiliza estructuras.


		div style="width:30%; vertical-align:middle; display:inline-block;" 

			== image_tag '/images/figures/01-kernel-threads.png', :width=>"100%", :style=>"border:none; box-shadow:none;"

	section#hybrid

		h3 Hybrid implementations

		div style="width:70%; vertical-align:middle; display:inline-block;" 

			div.fragment
				div Kernel threads <b>multiplexados</b> entre user threads
				div Kernel solo ve kernel threads
				div Varios user threads asignados a un kernel thread

			div.fragment
				ul
					li &#x1f603; Más livianos de crear
					li &#x1f603; <i>Syscall</i>s no bloquean el proceso.
					li &#x1f603; Escalable como los user threads


		div style="width:30%; vertical-align:middle; display:inline-block;" 

			== image_tag '/images/figures/01-hybrid-threads.png', :width=>"100%", :style=>"border:none; box-shadow:none;"



	/section#mt-dataModels-greenThreads
		p <em>Many-to-one</em>

		ul
			li.fragment  + Manejo de <em>threads</em> en biblioteca de usuario
			li.fragment  - Un <em>syscall</em> de un <em>thread</em> bloquea todo el proceso
		.fragment
			== image_tag '/images/figures/01-4_05.pdf.png', :width=>"40%"

		br
		p.fragment Solaris: biblioteca <em>green threads</em>


	/section#mt-dataModels-id
		p <em>One-to-one</em>
		ul
			li.fragment  + <em>Threads</em> ejecutando <em>syscall</em> no bloquean el proceso
			li.fragment  + Asignables a distintos <em>core</em>s
			li.fragment  - Creación implica ejecutar <em>syscalls</em>
			li.fragment  - Sistemas Operativos limitan el máximo número de <em>threads</em>
		== image_tag '/images/figures/01-4_06.pdf.png', :width=>"60%"
		br
		p.fragment Linux & Windows

	/section#mt-dataModels-m2m
		p <em>Many-to-many</em>
		ul
			li.fragment  + Usuario pueden crear número ilimitado de <em>threads</em>
			li.fragment  + Asignación de <em>user thread</em> a <em>kernel thread</em> se hace <em>on-demand</em>
			li.fragment  + <em>Threads</em> ejecutando <em>syscall</em> no bloquean el proceso
			li.fragment  - Creación implica ejecutar <em>syscalls</em>
			li.fragment  - Sistemas Operativos limitan el máximo número de <em>threads</em>
		== image_tag '/images/figures/01-4_07.pdf.png', :width=>"40%"
		br
    /p.fragment Linux & Windows.


	/section#mt-threadingLibs
		p Bibliotecas de <em>threads</em>

		p.fragment Tres principales:
		ul.fragment
			li POSIX Pthreads (kernel ó user)
			li Windows Threads (kernel)
			li Java threads (user)


	/section#mt-threadingLibs-pthreads
		h5
			code pthread

		p POSIX standard IEEE 1003.1c (especificación)

		p.fragment API para creación y sincronización de <em>thread</em>s.
		p.fragment Implementaciones para Linux, Mac OS X, Solaris
		ul
			li.fragment  <code>pthread_t</code>, identificador
			li.fragment  <code>pthread_create()</code>, creación de <em>thread</em>
			li.fragment  <code>pthread_join()</code>, padre espera que hijo(s) termine(n)
			li.fragment  <code>pthread_exit()</code>, termina el <em>thread</em> actual

	/section#mt-threadingLibs-winThreads
		h5 Windows Threads

		p Disponible nativamente en Windows API (kernel <em>thread</em>s)
		ul
			li.fragment  <code>HANDLE</code>, permite acceder al <em>thread</em> (puntero)
			li.fragment  <code>CreateThread()</code>, creación de <em>thread</em>
			li.fragment  <code>WaitForSingleObject()</code> padre espera que hijo termine
			li.fragment  <code>WaitForMultipleObjects()</code> padre espera que hijo(s) termine(n)
			li.fragment  <code>CloseHandle()</code>, borra el <em>thread</em> indicado


	/section#mt-threadingLibs-javaThreads
		h5 Java Threads

		p Implementado como biblioteca nativa en la JVM

		p.fragment Se consideran <em>user thread</em>s ya que la JVM ejecuta sobre algún Sistema Operativo <em>host</em>
		ul
			li.fragment  Creación: extender clase <code>Thread</code> y hacer <em>override</em> del método <code>run()</code>
			li.fragment  Creación: clase que implementa la interfaz <code>Runnable</code>
			li.fragment  <em>Thread</em> es efectivamente creado al invocar <code>start()</code>
			ul
				li.fragment  Asigna memoria para el nuevo objeto <em>thread</em> en la JVM
				li.fragment  Llama al método <code>run()</code> iniciando la ejecución del <em>thread</em>
			li.fragment  Esperar que un <em>thread</em> hijo termine: <code>join()</code>


/section#semantics
	h2 Semántica de <code>fork</code>/<code>exec</code> y señales

	p Aún quedan algunas situaciones "poco claras"
	ul
		li.fragment  Semántica de <code>fork()</code> y <code>exec()</code> en proceso <em>multithreaded</em>
		ul
			li.fragment  ¿Se duplican todos los <em>thread</em>s o solo el actual?
			li.fragment  ¿<code>exec()</code> reemplaza todos los <em>thread</em>s?
			/!ul
				li.fragment  No se debería poder, el resto de los threads quedarían corruptos
				li.fragment  Si se espera que funcione  debe ser creando un proceso nuevo y terminando el thread

		li.fragment  Semántica de señales (<em>signal</em>s) en Unix, ¿quién la recibe?
		ul
			li.fragment  Un <em>thread</em>, aquél al cual se le aplica
			li.fragment  A todos los <em>thread</em>s del proceso
			li.fragment  A algunos <em>thread</em>s
			li.fragment  Siempre al mismo <em>thread</em>



/section#summary-
	h2 Resumen: <em>Threads</em>
	ul
		li.fragment  <em>Thread</em>: flujo de control básico dentro de un proceso
		li.fragment  Múltiples <em>thread</em>s en el mismo proceso comparten espacio de memoria
		li.fragment  <em>User thread</em>s: fáciles de crear, pero no visto por el Sistema Operativo
		li.fragment  <em>Kernel thread</em>s: manejables por el Sistema Operativo, más costosos de crear
		li.fragment  MacOSX, Windows, Linux, soportan <em>kernel thread</em>s y hacen <em>mapping</em> a <em>user thread</em>s
		li.fragment  Bibliotecas de <em>thread</em>s más comunes: Pthreads, Windows threads, Java threads



section#synch-init
	h2 Sincronización

	section#synch-init-init
		h2 <em>Sincronización</em>

	section#
		p <strong><em>Threads</em></strong> como unidad básica de procesamiento
		ul.fragment
			li  <i>Threads</i> en un proceso comparten memoria
			li  <i>Threads</i> son concurrentes (compiten por uso de CPU)
			li  <i>Threads</i> en un sistema multicore pueden ejecutar en paralelo

		p.fragment Pero deben ser sincronizados... o puede pasar ...

		div.fragment Ejemplo: <a href="../examples/pthreads2.c" target="_blank">POSIX Threads compartiendo memoria</a>

		div.fragment
			== image_tag '/images/figures/01-2problems.png', :width=>"60%", :style=>"border:none;"

	section
		h3 ¿Qué ocurre en el programa?

		div Vemos ...

		pre
			code.hljs.lang-c
				| counter = counter + 1

		div Pero lo que se ejecuta es... (tip: <code>objdump -d &lt;ejecutable&gt;</code>)

		pre
			code.hljs.asm
				|  mov    0x60208c,%eax        
  				   add    $0x1,%eax
                   mov    %eax,0x60208c        

	
		
	section

		div <i>Thread A</i> ejecuta:

		pre
			code.hljs.asm
				|  mov    0x60208c,%eax        
  				   add    $0x1,%eax
                   mov    %eax,0x60208c        

		div <i>Thread B</i> ejecuta:

		pre
			code.hljs.asm
				|  						  mov    0x60208c,%eax        
  				   													add    $0x1,%eax
                   													mov    %eax,0x60208c        

        div En la práctica pueden ocurrir muchos <i>interleaving</i> (entremezclas):

		a href="http://i.imgur.com/MS13CAb.gif"
			pre
				code.hljs.asm
					| mov    0x60208c,%eax ; eax = 10
					                                    			mov    0x60208c,%eax ; eax = 10
					                                    			add    $0x1,%eax     ; eax = 11
					                                    			mov    %eax,0x60208c ; counter = 11, Write lost!!
					  add    $0x1,%eax     ; eax = 11
					  mov    %eax,0x60208c ; counter = 11   Dirty write :/

		div.fragment ¿Podemos tener tan mala suerte para que ocurra <a href="https://www.reddit.com/r/Bitcoin/comments/1wtbiu/how_i_stole_roughly_100_btc_from_an_exchange_and">así</a>?

	section
		div Esta situación ilustra una <b>race condition</b>

		blockquote.fragment style="background:#F4C7C3;" <b>Race Condition</b><br/> Situación en que la salida de una operación depende del orden temporal de sus operaciones internas, el cual no está bajo control del programador.

		p.fragment El resultado depende de la entremezcla (<em>interleaving</em>) de sus <em>threads</em>
		h5.fragment <strong>Hay que evitarlas</strong>

section
	h2 El Problema de la Sección Crítica
	/  ---------------------------------

	section#crS-def
		div El segmento de código en que el <i>thread</i> accede a recursos compartidos se conoce como <strong>sección crítica</strong>

		blockquote.fragment
			| Necesitamos un protocolo que <b>no permita</b> que dos o más <i>threads</i> se encuentren en su sección crítica al mismo tiempo

		pre.fragment
			code.hljs.c
				| void mess_with_shared_things() {
				    entry();
				    /* do stuff with shared resources */
				    leave();
				    
				    /* moar stuff */
				 }

	section#crS-solReqs
		p Una solución al problema de la sección crítica (SC) debe cumplir:

		blockquote.fragment style="background:#B7E1CD;" <b>Exclusión Mutua</b>

		div.fragment <b>A lo más un</b> <i>thread</i> está en su SC.

		blockquote.fragment style="background:#B7E1CD;" <b>Progreso</b>

		div.fragment <b>Al menos un</b> <i>thread</i> puede entrar a su SC.

		div.fragment Si ningún <i>thread</i> está en su SC, y hay <i>thread</i>s que desean entrar, entonces los que quieren entrar deben decidir quién entra, y decidirlo en un tiempo acotado.

		blockquote.fragment style="background:#B7E1CD;" <b>Espera acotada</b> (ausencia de inanición)

		div.fragment Si un proceso quiere entrar a su SC, podrá hacerlo luego de una cantidad <b>finita</b> de tiempo.

	section
		div Ejecución deseada:

		== image_tag '/images/figures/01-2processes.png', :width=>"80%", :style=>"border:none;"

section
	h2 Algunas soluciones

	section
		div Atacar al problema de raíz

		div.fragment <b>Deshabilitar las interrupciones</b>

		ul.fragment 
			li Problema ocurre cuando un <i>thread</i> es interrumpido
			li Si no hay interrupciones no hay problema
			li ¿Es suficiente?
			li ¿Quién puede hacer esto?

	section
		div En el mundo del usuario estamos a merced de las interrupciones

		div.fragment <b>Solución con variable compartida <code>lock</code></b>

		div.fragment
			pre
				code.hljs.lang-c
					| int lock = 0;  // 0==free, 1==busy

		div.fragment Código de cada <i>thread</i>:

		div.fragment
			pre
				code.hljs.lang-c
					| while(TRUE) {
					      while(lock);     // busy waiting (spinlock)
					      lock = 1;
					      /* ... SC ... */
					      lock = 0;
					      /* ... out of SC ... */
					  }

		div.fragment ¿Problemas?

	section
		div <b>Solución con <code>turn</code></b>, para alternar entre dos <i>threads</i>

		div Variable compartida <code>turn</code> determina quién puede entrar.

		pre
			code.hljs.lang-c
				| int turn = 1;  // o 0 ... 

		div Código para <i>thread</i> 0 y <i>thread</i> 1:
		pre
			code.hljs.lang-c
				| /* Thread 0 */                            /* Thread 1 */
				  while(TRUE) {                             while(TRUE) {
				      while(turn != 0);                         while(turn != 1);
				      /* ... SC ... */                          /* ... SC ... */
				      turn = 1;                                 turn = 0;
				      /* ... out of SC ... */                   /* ... SC ... */
				  }

		div ¿Cumple todas las condiciones?

	section
		div <b>Solución de G.L.Peterson, 1981</b> (no la primera, pero la más simple)

		div Variable compartida <code>turn</code> determina quién puede entrar.

		pre
			code.hljs.lang-c
				| int turn = 1;                 // o 0 ... 
				  int flag[2] = {false, false}; // indica t_i está interesado en entrar
	
		div Variable local <code>me</code> puede ser 0 ó 1
		pre
			code.hljs.c
				| int me = // ... 0 ó 1;    /* Peterson es para dos threads */
				  int other = 1-me;
				  while('o') {
				      flag[me] = true;  /* wants */
				      turn = other;
				      while(flag[other] && turn == other); /* wait */
				      /* ... SC ... */
				      flag[me] = false;
				      /* ... out of SC .../ */
				  }

		div.fragment ¿Cumple los requisitos? ¿Por qué? ¿Se puede demostrar?





section
	h2 Sincronización por <i>hardware</i>

	section 
		p Soluciones por <em>software</em> dependen de que existan <strong>instrucciones atómicas</strong> provistas por el <em>hardware</em>.

		pre
			code.hljs.lang-c
				| int lock = 0;  // 0==free, 1==busy

		pre
			code.hljs.c
				| while(TRUE) {
				      while (lock);
				      lock = 1;
				      /* Critical Section */
				      lock = 0;
				      /* ... */

		p.fragment Esto no era suficiente. ¿Qué instruccion(es) me gustaría que fuese(n) atómica(s)?


	section
		p <code>test_and_set()</code> (TSL)

		p Algunas arquitecturas proveen instrucciones atómicas del tipo <code>test_and_set</code>

		p La instrucción, que se ejecuta atómicamente, es equivalente a este código:
			
		pre
			code.hljs.c
				| bool SOFTWARE_test_and_set (bool *target) {
				      bool old_value = *target;
				      *target = true;
				   
				      return old_value;
				 }

		p.fragment  ¿Cómo usarlo?

	section
		div Código equivalente a <code>test_and_set</code>
		pre
			code.hljs.c
				| bool SOFTWARE_test_and_set (bool *target) {
				      bool old_value = *target;
				      *target = true;
				   
				      return old_value;
				 }

		div Ahora se puede implementar la versión "ingenua"

		pre
			code.hljs.lang-c
				| bool lock = false;  // false==free, true==busy


		pre
			code.hljs.c
				| while(true) {
				      /* ... ... ... */
				      while (test_and_set(&lock));
				      /* ... SC ... */
				      lock = false;
				      /* ... Out of SC ... */
				  }

		div.fragment ¿Cumple las propiedades?


	section
		div Otra instrucción atómica <code>compare_and_swap()</code> (XCHG, CAS)
		pre
			code.hljs.c
				| bool SOFTWARE_compare_and_swap (int *value, int expected, int new_value) {
				    int previous = *value;
				    
				    if(*value == expected)
				      *value = new_value;
				    
				    return previous;
				  }

		p.fragment  ¿Cómo usarlo?

	section
		div Código equivalente a <code>compare_and_swap()</code>
		pre
			code.hljs.c
				| int SOFTWARE_compare_and_swap (int *value, int expected, int new_value) {
				    int previous = *value;
				    
				    if(*value == expected)
				      *value = new_value;
				    
				    return previous;
				  }

		div Otra implementación simple, gracias a una instrucción atómica

		pre
			code.hljs.lang-c
				| int lock = 0;  // 0==free, 1==busy


		pre
			code.hljs.c
				| while(true) {
				      /* ... ... ... */
				      while (compare_and_swap(&lock, 0, 1));
				      /* ... SC ... */
				      lock = 0;
				      /* ... Out of SC ... */
				  }

		div.fragment ¿Cumple las propiedades?


	section#sync-correctness

		div Sección crítica para <code>N</code> procesos

		pre
			code.hljs.lang-c
				| bool lock = false;  // false==free, true==busy
				  bool waiting[N];    // todos inicializados en false

		div Cada <i>thread</i> <code>i</code> ejecuta:

		pre 
			code.hljs.lang-c style="max-height:600px;"
				| while('-') {
				    /* ... ... ... */
				    waiting[i] = key = true;          /* I'm waiting and it's locked */
				    while (waiting[i] && key)
				      key = test_and_set(&lock);
				    waiting[i] = false;               /* I'm no longer waiting */
				    
				    /* ... ... SC ... ... */
				    
				    j = (i+1)%N;                      /* Find waiting proc (clockwise circle) */
				    while((j != i) && !waiting[j])
				      j = ++j%N;
				    if(j == i)                          /* -Nobody was waiting */
				      lock = false;
				    else                                /* -proc_j should go (stop waiting) */
				      waiting[j] = false;
				    /* ... out of SC ... ... */'
				 }

		p.fragment ¿Cumplen con las propiedades de solución para sección crítica?

	section
		div Soluciones anteriores son correctas &hellip;

		div Pero utilizan <b>busy waiting</b> (<i>espera ocupada</i>)

		pre
			code.hljs.lang-c
				| lock = true;     // false==free, true==busy
				  while(lock);     // busy waiting, consume ciclos de CPU "esperando"
				  /* enter */

		blockquote style="background:#B7E1CD;" Solo cuando se espera un tiempo de bloqueo muy corto, puede justificarse usar <i>busy waiting</i>. En este caso se le llama <b>spinlock</b>

		div <b>Ejemplo:</b>Dos procesos con prioridades $H$ y $L$, $H>L$. 
		ul
			li $L$ ejecuta y toma un <i>lock</i> (está en su SC)
			li $H$ llega y <i>scheduler</i> (preemptive) ejecuta a $H$
			li $H$ hace <i>busy waiting</i>
			li Mientras $H$ exista, $L$ no puede ejecutar ni salir de su SC &#x1f613;





section#abstractions
	h2 Abstracciones de Sincronización
	/  -------------------------------

	section#abstractions-init
		p En general no se usan directamente soluciones por <em>hardware</em>

		p Se construyen <b>primitivas de <em>software</em></b> sobre ellas.


section#Locks-init
	h2 Mutex Locks

	section
		div La más simple: <b>MUTual EXclusion locks</b> (<i>mutex locks</i>)
		ul
			li <code>Lock::acquire();</code> toma el <i>lock</i>
			li <code>Lock::release();</code> libera el <i>lock</i> (error si no está tomado)

		pre
			code.hljs.c
				| struct Lock {
				    bool value = false; // false==free, true==busy
				  }

		div Implementación sin (mucho) <i>busy waiting</i>

		pre
			code.hljs.c
				| void acquire() {     
				    while(test_and_set(&value))
				      thread_yield();            // otras implementaciones usan sleep() y colas de espera
				  }
				  void release() {
				    value = false;
				  }
	section

		div Solución a Sección Crítica

		pre
			code.hljs.c
				| while(true) {
				      /* ... ... ... */
				      lock.acquire();
				      /* ... SC ... */
				      lock.release();
				      /* ... Out of SC ... */
				  }

		div Contador con acceso exclusivo

		pre
			code.hljs.c
				| struct Lock l; // compartido

		pre
			code.hljs.c
				| /* ... ... ... */
				  for(int i=0; i&lt;max; i++) {
				  	l.acquire();
				  	counter = counter + 1;
				  	l.release();
				  }

section#producer-consumer

	h2 Problema del productor-consumidor

	section 
		h3 Ó problema del <i>bounded-buffer</i>
		ul
			li Un <i>buffer</i> circular de tamaño limitado $N$
			li Dos <i>threads</i>: productor (agrega) y consumidor (consume)
			li Todos los elementos producidos deben ser consumidos en orden

		div style="border:none; width:70%; vertical-align:middle; display:inline-block;" 

			pre
				code.hljs.c
					| int stock = 0;
					  T storage[N];

			pre
				code.hljs.c
					| int in = 0;
					  while('p') {
					      item = produce();
				  		  while (stock == N);  // Storage full 
				   		  storage[in] = item;
						  in = ++in%N;         // rotate index
				   		  stock++;
				   	  }

			pre
				code.hljs.c
					| int out = 0;
					  while ('c') {
				          while(!stock);       // Wait for new items
				          item = storage[out];
				          out = ++out%N;       // rotate index
				          stock--;
				          consume(item);
				      } /* ' */

		img src='/images/figures/01-ProdCons.jpg' width="25%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"

	section
	    div Podemos agregar locks en <i>stock</i>

		pre
			code.hljs.c
				| int in = 0;
				  while('p') {
				      item = produce();
			  		  while (stock == N);  // Storage full 
			   		  storage[in] = item;
					  in = ++in%N;         // rotate index
					  lock.acquire();
			   		  stock++;
			   		  lock.release();
			   	  }

		pre
			code.hljs.c
				| int out = 0;
				  while ('c') {
			          while(!stock);       // Wait for new items
			          item = storage[out];
			          out = ++out%N;       // rotate index
			          lock.acquire();
			          stock--;
			          lock.release();
			          consume(item);
			      } /* ' */

        div ¿Cómo eliminamos busy waiting?


	section
	    ul
	      li <code>sleep()</code> se bloquea en cola <i>waiting</i>
	      li <code>wakeup(t)</code> saca a <code>t</code> de la cola <i>waiting</i> (si está)

		pre
			code.hljs.c
				| int in = 0;
				  while('p') {
				      item = produce();
			  		  while (stock == N) sleep(); // Storage full 
			   		  storage[in] = item;
					  in = ++in%N;                // rotate index
					  lock.acquire();
			   		  stock++;
			   		  lock.release();
			   		  if(stock == 1) wakeup(consumer);
			   	  }

		pre
			code.hljs.c
				| int out = 0;
				  while ('c') {
			          while(!stock) sleep();     // Wait for new items
			          item = storage[out];
			          out = ++out%N;             // rotate index
			          lock.acquire();
			          stock--;
			          lock.release();
			          if(stock == N-1) wakeup(producer);
			          consume(item);
			      } /* ' */

        div ¿Problema? <span class="fragment">¿Si $C$ es interrumpido antes de dormir?</span>

section#semaphore

    h2 Semáforos 

	section#sema

        div E.W.Dijkstra (1965) propone una nueva primitiva de sincronización: <b>semáforos</b>, y las introduce en Algol 68.

		p <b>Semáforos</b> permiten un número limitado de <i>thread</i>s en una sección crítica.

		div.fragment
			dl
				dt style="background:#B7E1CD;" Semáforo
				dd
					p Un semáforo <code>S</code> incluye un contador y dos operaciones:
					ul
						li.fragment <em>proberen</em> <code>P()</code> ó <code>wait()</code> ó <code>up()</code>. Intenta decrementar el valor.
						li.fragment <em>verhogen</em> <code>V()</code> ó <code>signal()</code> ó <code>down()</code>. Incrementa el valor.
			p.fragment E.W.Dijkstra era holandés, pero si no saben holandés es más fácil recordar <code>Pedir</code>/<code>Votar</code>

	section

		div Implementación de semáforos

		pre
			code.hljs.c
				| struct semaphore{
				    int count;
				    struct Lock l;
				    struct process* slept = NULL;
				  }

		div style="border:none; width:60%; vertical-align:middle; display:inline-block;" 

			pre
				code.hljs.c
					| void init(c) {
					      count = c;
					  }

					  void P() {      /* wait: put into queue and sleep */
					    l.acquire();
					    while(count <= 0) {
					        /* code to add itself to 'slept' */ // /
					        l.release();
					        sleep();
					        l.acquire();
					    }
					    count--;
					    l.release();
					  }

		div style="border:none; width:40%; vertical-align:middle; display:inline-block;" 

			pre
				code.hljs.c
					|
					  void V(S) {    /* signal */
					  	l.acquire();
					    count++;
					    wakeup(/* first from 'slept' */); 
					    // plus, remove from queue
					    l.release();
					  }

		div Otras implementaciones usan <i>busy waiting</i> (para multiprocesadores)


	section
	    
	    div Bounded-buffer con semáforos

		pre
			code.hljs.c
				| struct lock l; int stock = 0; T storage[N];
				  struct semaphore full;  full.init(0);
				  struct sempahore empty; empty.init(N);
		
		pre
			code.hljs.c
				| int in = 0;
				  while('p') {
				      item = produce();
			  		  empty.P();            // Wait one empty slot. P=='wait'=='down'
			  		  l.acquire();
			   		  storage[in] = item;
					  in = ++in%N;                // rotate index
			   		  stock++;
			   		  lock.release();
			   		  full.V();             // One more full slot. V=='signal'=='up'
			   	  }

		pre
			code.hljs.c
				| int out = 0;
				  while ('c') {
			          full.P()             // Wait one more item. P=='wait'=='down'
			          lock.acquire();
			          item = storage[out];
			          out = ++out%N;             // rotate index
			          stock--;
			          lock.release();
			          empty.V();           // One more empty slot. V=='signal'=='up'
			          consume(item);
			      } 

section#conditions

    h2 Variables de Condición (Condition Variables)

	section#cond

        div Semáforos sirven para controlar cantidad de accesos a una región protegida

        div Mecanismo consisten en bloquearse (<code>P()</code>) bajo una condición (contador negativo) y avisar o señalar (<code>V()</code>) que una condición se ha cumplido (contador mayor a 0)

        blockquote.fragment style="background:#B7E1CD;" Variables de condición permitan bloquearse bajo condiciones arbitrarias.

		ul.fragment
			li  <code>Condition::wait()</code> bloquea <strong>siempre</strong> el <em>thread</em>
			li  <code>Condition::signal()</code> despierta a un <em>thread</em> bloqueado, si lo hay


	section
	    
	    div Bounded-buffer con <i>condition variables</i>

		pre
			code.hljs.c
				| struct lock l; 
				  struct condition condCons, condProd;
				  int stock = 0; T storage[N];
		
		pre
			code.hljs.c
				| int in = 0;
				  while('p') {
				      item = produce();
				      l.acquire();                        // with mutex
				      while(stock == N) condProd.wait(l); // wait if full
			   		  storage[in] = item;  in = ++in%N;   // fill and rotate index
			   		  stock++;
			   		  condCons.signal();                  // signal new item for consumer
			   		  l.release();
			   	  }

		pre
			code.hljs.c
				| int out = 0;
				  while ('c') {
			          l.acquire();
			          while(!stock) condCons.wait(l);     // wait if empty
			          item = storage[out]; out = ++out%N; // extract and rotate index
			          stock--;
			          condProd.signal();                  // signal new slot for producer
			          l.release();
			          consume(item);
			      }

		<i>Condition variables</i> utilizan un <i>lock</i> y lo liberan antes de bloquearse. 


section#readers-writers

	h2 Problema de los lectores y escritores

	section 
		h3 Readers-Writers

		div Planteado por Courtois et al. (1971). Modela acceso a una base datos.

		ul
			li Permitir acceso de $n$ lectores simultáneos, pero solamente 1 escritor

		pre
			code.hljs.c
				| struct semaphore rw; rw.init(1); 
				  struct semaphore mutex; mutex.init(1); 
				  int readers = 0;        // leen o quieren leer
		
		div style="border:none; width:50%; vertical-align:middle; display:inline-block;" 

			div Writers

			pre
				code.hljs.c
					| while('w') {
					      rw.P();
					      /* ... WRITE ... */
				   		  rw.V();
				   	  }

		div style="border:none; width:50%; vertical-align:middle; display:inline-block;" 

			div Readers

			pre
				code.hljs.c
					| while ('r') {
				          mutex.P();
				          readers += 1;
				          if(readers == 1)
				              rw.P();
				          mutex.V();
				          /* ... READ ... */
				          mutex.P();
				          readers -= 1;
				          if(readers == 0)
				              rw.V();
				          mutex.V();
				      }


section#philosophers

	h2 Problema de los filósofos comensales

	section#block-phi_
		div 5 filósofos se pasan la vida en dos actividades: <em>comer</em> y <em>pensar</em>
		div
			ul
				li  Para comer deben tomar ambos palillos
				li  Sólo pueden tomar un palillo a la vez

		div.fragment style="border:none; width:50%; vertical-align:middle; display:inline-block;" 

			div Código para filósofo <code>i</code>

			pre
				code.hljs.c
					| int left =  i;
					  int right = (i+1)%N;           // N==5
					  struct semaphore chopstick[N]; // inicializados en 1
					  
					  do {
					    chopstick[left].P();
					    chopstick[right].P();
					    
					    /* eat */
					    
					    chopstick[left].V();
					    chopstick[right].V();
					    
					    /* philosophise */
					    
					  } while ('p');

		img src='/images/figures/01-5_13.pdf.png' width="25%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"


	section#block-phi-sem
		h3 Filósofos Comensales con Semáforos

		pre
			code.hljs.c
				| int N = 5;
				  enum {PHILOSOPHISE, HUNGRY, EATING} state[N];   /* free / waiting / using */
				  struct lock l;
				  struct semaphore philosopher[N]; // inicializados en 1

		div.fragment style="border:none; width:50%; vertical-align:middle; display:inline-block;" 

			pre.stretch
				code.hljs.c
					| int left(i)  { return (i+N-1)%N; }
					  int right(i) { return (i+1)%N; }

	                  void philosoph(int i) {
	                      while(TRUE) {
	                          think();
	                          take_forks();
	                          eat();
	                          release_forks();
	                      }
	                  }

				      void take_forks(int i) {
				          l.acquire();
				          state[i] = HUNGRY;
				          try_forks(i);
				          l.release();
				          philosopher[i].P();
					  }

		div.fragment style="border:none; width:50%; vertical-align:middle; display:inline-block;" 

			pre.stretch
				code.hljs.c
					| void release(int i) {
				          l.acquire();
				          state[i] = PHILOSOPHISE;
				          try_forks(left(i));
				          try_forks(right(i));
				          l.release();
				      }
				    
				      void try_forks(int i) {
				          if(state[i] == HUNGRY && state[left(i)] != EATING 
				          	 && state[right] != EATING) {
				              state[i] = EATING;
				              philosopher[i].V();
				          }
				      }


