---
title: Administración de Memoria
layout: slide
---


section
  h2 Memoria

  section#memory0
    h3 Direcciones de Memoria

    div 

      ul
        li Un gran arreglo de <i>bytes</i>
        li Cada uno con su propia <b>dirección</b>

    div style="width:50%; vertical-align:middle; display:inline-block;" 

      div Al principio &hellip;

      img src='/images/figures/02-memory-old.png' width="40%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"

    div.fragment style="width:50%; vertical-align:middle; display:inline-block;" 

      div Con multiprogramación &hellip;

      img src='/images/figures/02-memory-new.png' width="35%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"

  section data-transition="fade-out"
    h3 Direcciones de Memoria

    div style="width:60%; vertical-align:middle; display:inline-block;" 

      div Con solamente un proceso en memoria &hellip;

      pre
        code.hljs.asm
          |  mov %eax, 0x10001       ; a += 3
             add %eax, $0x3
             mov 0x10001, %eax


      div La vida del compilador es (más) fácil

      br
      br

      ul
        li Programa siempre se carga en la misma dirección
        li Cada variable tiene la misma dirección en memoria en cada ejecución

    div style="width:40%; vertical-align:middle; display:inline-block;" 

      img src='/images/figures/02-memory-old.png' width="60%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"

  section data-transition="fade-in fade-out"
    h3 Direcciones de Memoria

    div style="width:60%; vertical-align:middle; display:inline-block;" 

      div Con múltiples procesos en memoria (<i>multiprogramación</i>) &hellip;

      pre
        code.hljs.asm
          |  mov %eax, 0x10001       ; falla si a no está en 0x10001
             add %eax, $0x3
             mov 0x10001, %eax

      div Procesos pueden cargarse en cualquier parte de la memoria

      br
      br

      div Problema 1:
      ul
        li Variables no están siempre en la misma ubicación
        li Requisito: <b>relocalización de variables</b>

    div style="width:40%; vertical-align:middle; display:inline-block;" 

      img src='/images/figures/02-memory-new.png' width="60%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"


  section data-transition="fade-in fade-out"
    h3 Direcciones de Memoria

    div style="width:60%; vertical-align:middle; display:inline-block;" 

      div Con múltiples procesos en memoria (<i>multiprogramación</i>) &hellip;

      pre
        code.hljs.asm
          |  mov %eax, 0x20001       ; 0x20001 es memoria de C
             add %eax, $0x3
             mov 0x20001, %eax

      div Procesos pueden cargarse en cualquier parte de la memoria

      br
      br

      div Problema 2:
      ul
        li Un proceso, por error, podría leer memoria y modificar memoria de otro proceso
        li Requisito: <b>protección de memoria</b>

    div style="width:40%; vertical-align:middle; display:inline-block;" 

      img src='/images/figures/02-memory-new.png' width="60%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"

  section data-transition="fade-in fade-out"
    h3 Direcciones de Memoria

    div style="width:40%; vertical-align:middle; display:inline-block;" 

      div <b>Direcciones absolutas no sirven con multiprogramación</b>
      ul
        li Caso (a). Un proceso único en memoria, de 16KB, cargado en 0.
        li Caso (b). Otro proceso único en memoria, de 16KB, cargado en 0.
        li Caso (c). Dos procesos de 16KB cargados en memoria, de manera contigua.

    div style="width:50%; vertical-align:middle; display:inline-block;" 

      img src='/images/figures/04-spaces.png' width="75%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"

  section data-transition="fade-in"
    h3 Relocalización y protección

    div style="width:50%; vertical-align:middle; display:inline-block;" 

      div <b>Direcciones absolutas no sirven con multiprogramación</b>
      ul
        li Caso (b). Instrucción <code>JMP 28</code> está OK si el proceso está cargado en 0.
        li Caso (c). Si el proceso se carga en <code>16384</code., hay que cambiar <code>JMP 28</code> por <code>JMP 16412</code>.
        li ¿Cómo conseguirlo?
        ul.fragment
          li Compilador podría generar: <code>JMP 28+X</code> 
          li Al cargar en memoria se determina que <code>X</code> es 16384, y se carga en memoria <code>JMP 16412</code>
          li Ejecutar esto cada vez que se cargue

    div style="width:50%; vertical-align:middle; display:inline-block;" 

      img src='/images/figures/04-spaces.png' width="75%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"

  section
    h3 Direcciones de memoria

    div ¿Cómo podemos saber donde se ubica nuestro código?

    div style="width:60%; vertical-align:middle; display:inline-block;" 

      pre
        code.hljs.lang-c
          |  #include &lt;stdio.h&gt;
             #include &lt;stdlib.h&gt;

             int b = 3;

             int main(int argc, char *argv[]) {
               int x=3;
               printf("Location of code   : %p\n", (void *)main);
               printf("Location of data   : %p\n", (void *)&b);
               printf("Location of heap   : %p\n", (void *)malloc(1));
               printf("Location of stack  : %p\n", (void *)&x);
               return x+b;
             }

      div.fragment Código completo <a href="../examples/mems.c" target="_blank">aquí</a>

      div.fragment Atención: estas direcciones son <b>virtuales</b> &#x1f632;

    div style="width:40%; vertical-align:middle; display:inline-block;" 

      img src='/images/figures/02-memory-sections.png' width="75%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"


section
  h2 Espacios de direcciones

  section
    div Dos problemas: (1)<b>relocalización</b> y (2)<b>protección</b>

    blockquote.fragment data-fragment-index="1" style="background:#B7E1CD;" Abstracción: <b>espacios de direcciones</b>

    div.fragment data-fragment-index="2" style="width:60%; vertical-align:middle; display:inline-block;" 

      div CPUs desde CDC6600 hasta Intel 8088 integran dos registros: <code>base</code> y <code>limit</code><br/><br/>

      ul
        li Al cargar cada procesos se cargan estos registros
        li Proceso quiere ejecutar <code>JMP 28</code>
        li Pero <i>hardware</i> ejecuta <code>JMP 28+16384</code>
        li Si la dirección es mayor que <code>limit</code>, se genera un <i>trap</i>
        li MMU: <b>Memory Manager Unit</b>

      div.fragment data-fragment-index="3" ¿Resuelto?

    div.fragment data-fragment-index="2" style="width:40%; vertical-align:middle; display:inline-block;" 

      img src='/images/figures/04-twoprocs.png' width="70%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"

  section
    div Proceso mantiene un espacio <b>único</b> y <b>secuencial</b> (lineal) de direcciones.

    div style="width:60%; vertical-align:middle; display:inline-block;" 

      ul
        li Proceso $A$ utiliza 16KB.
        ul
          li <code>code</code> en 0-1023
          li <code>heap</code> empieza en 1024, y crece
          li <code>stack</code> empieza en 16383, y decrece
        li Al cargarlo en memoria, el sistema operativo asigna <code>Base: 4096</code>, <code>limit: 16384</code>.
        ul
          li Código de $A$ no es modificado
          li Proceso $A$ pide la dirección <b>virtual</b>: 768
          li MMU entrega la dirección <b>física</b>: 4864

    div style="width:40%; vertical-align:middle; display:inline-block;" 

      img src='/images/figures/02-memory-inside.png' width="100%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"

  section
    h3 Sobrecarga de memoria

    div ¿Cuántos procesos caben en memoria? ¿Qué pasa si la memoria se llena?

    blockquote.fragment data-fragment-index="1" style="background:#B7E1CD;"  Operaciones de <b>swapping</b>

    div.fragment data-fragment-index="2" style="width:60%; vertical-align:middle; display:inline-block;" 

      ul
        li <b>Swap-out</b>. Memoria del proceso se copia a disco.
        li <b>Swap-in</b>. Memoria del proceso se copia de disco a memoria.

      div.fragment data-fragment-index="3" ¿Qué pasa con la relocalización?

    div.fragment data-fragment-index="2" style="width:40%; vertical-align:middle; display:inline-block;" 

      img src='/images/figures/02-8_05.pdf.png' width="80%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"

  section
    div Procesos pueden ser cargados y descargados de la memoria

    == image_tag '/images/figures/04-loadprocs.png', :width=>"50%", :style=>"border:none; box-shadow:none;"

    div Memoria del sistema queda con huecos

    div.fragment ¿Qué hacer con los huecos?

  section
    div ¿Qué hacer con los huecos?

    == image_tag '/images/figures/02-compact.png', :width=>"35%", :style=>"border:none; box-shadow:none;"

    br

    div style="width:60%; vertical-align:middle; display:inline-block;" 

      div <b>Compactación</b>: Fusionar los huecos

      ul.fragment data-fragment-index="2"
        li Requiere copiar memoria a otras direcciones
        li Caro. No se hace.
        li.fragment data-fragment-index="3" <i>Mejor</i>: asignar espacios de manera que no se necesite compactar

    div style="width:40%; vertical-align:middle; display:inline-block;" 

      img.fragment data-fragment-index="1" src='/images/figures/02-fusion.png' width="50%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"


  section
    div ¿Como evitar espacios libres?

    div Estrategias:
    ul
      li <strong>First-fit</strong>. En el primer lugar disponible.
      li <strong>Best-fit</strong>. En el que deja menos espacio libre (el más pequeño posible).
      li <strong>Worst-fit</strong>. En el que deja más espacio libre (el más grande).

    div

      div style="width:25%; vertical-align:middle; display:inline-block;" 

        img.fragment data-fragment-index="1" src='/images/figures/02-fits.png' width="24%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"

      div style="width:25%; vertical-align:middle; display:inline-block;" 

        img.fragment data-fragment-index="2" src='/images/figures/02-fits-first.png' width="25%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"

      div style="width:25%; vertical-align:middle; display:inline-block;" 

        img.fragment data-fragment-index="3" src='/images/figures/02-fits-best.png' width="25%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"

      div style="width:25%; vertical-align:middle; display:inline-block;" 

        img.fragment data-fragment-index="4" src='/images/figures/02-fits-worst.png' width="23%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"

  section
    h3 Fragmentación

    div Con cualquier estrategia aún pueden quedar espacios libres no contiguos.

    blockquote style="background:#B7E1CD;" <b>Fragmentación Externa</b>. Espacios libres no contiguos.

    ul.fragment
      li Compactar no es una opción práctica
      li Supuesto: procesos se pueden reubicar en cualquier parte de la memoria 
      li Supuesto: procesos deben ubicarse en espacios <b>contiguos</b>













section#segmentation
  h2 Segmentación

  section
    div Problema: un espacio de direcciones muy grande.

    blockquote.fragment data-fragment-index="1" style="background:#F4C7C3;" <b>Segmentación</b>

    div.fragment data-fragment-index="2" Se divide el espacio de direcciones en varios espacios más pequeños

    ul.fragment data-fragment-index="2"
      li Espacios más pequeños pueden ser asignados más fácilmente

    div.fragment data-fragment-index="3" style="width:50%; vertical-align:middle; display:inline-block;" 

      div <b>Segmento:</b> espacio de direcciones contiguo
      ul
        li Ejemplo: código, datos, heap, stack, &hellip;

    div.fragment data-fragment-index="3" style="width:50%; vertical-align:middle; display:inline-block;" 
    
      img src='/images/figures/02-basic-segments.png' width="80%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"


  section
    h3 Implementando segmentación

    div Ahora hay varios espacios lineales de direcciones.

    div style="width:50%; vertical-align:middle; display:inline-block;" 

      div MMU debe ser capaz de hacer la traducción

      table
        tr
          td Segment
          td Base
          td Size 
        tr
          td <code>code</code>
          td 32768 (32KB)
          td 2048 (2KB)
        tr
          td <code>heap</code>
          td 34816 (34KB)
          td 2048 (2KB)
        tr
          td <code>stack</code>
          td 28672 (28KB)
          td 2048 (2KB)

      div <b>Tabla de Segmentos</b>

      ul.fragment
        li Dirección virtual (lógica): $100$
        ul
          li Está en segmento <code>code</code>
          /li <i>Offset</i> dentro de <code>code</code>: $100$
          li Base + dirección $= 32768 + 100 = 32868$
        li Dirección física: $32868$

    div style="width:50%; vertical-align:middle; display:inline-block;" 

      img src='/images/figures/02-segments-2.png' width="40%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"

      div style="width:10%; vertical-align:middle; display:inline-block;" 

      img src='/images/figures/02-segments-1.png' width="23%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"

  section
    h3 Implementando segmentación

    div style="width:50%; vertical-align:middle; display:inline-block;" 

      table
        tr
          td Segment
          td Base
          td Size 
        tr
          td <code>code</code>
          td 32768 (32KB)
          td 2048 (2KB)
        tr
          td <code>heap</code>
          td 34816 (34KB)
          td 2048 (2KB)
        tr
          td <code>stack</code>
          td 28672 (28KB)
          td 2048 (2KB)

      br
      
      ul.fragment
        li Dirección virtual (lógica): $4200$
        ul
          li Está en segmento <code>heap</code>
          /li <i>Offset</i> dentro de <code>code</code>: $100$
          li Base + dirección $= 34816 + 4200 = 39016$
        li Dirección física: $39016$

      blockquote.fragment  style="background:#F4C7C3;" <code>Segmentation Fault!</code>

    div style="width:50%; vertical-align:middle; display:inline-block;" 

      img src='/images/figures/02-segments-2.png' width="40%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"

      div style="width:10%; vertical-align:middle; display:inline-block;" 

      img src='/images/figures/02-segments-1.png' width="23%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"


  section
    h3 Implementando segmentación

    div style="width:50%; vertical-align:middle; display:inline-block;" 

      table
        tr
          td Segment
          td Base
          td Size 
        tr
          td <code>code</code>
          td 32768 (32KB)
          td 2048 (2KB)
        tr
          td <code>heap</code>
          td 34816 (34KB)
          td 2048 (2KB)
        tr
          td <code>stack</code>
          td 28672 (28KB)
          td 2048 (2KB)

      br
      
      ul.fragment
        li Dirección virtual (lógica): $4200$
        ul
          li Está en segmento <code>heap</code>
          li <i>Offset</i> dentro de <code>heap</code>: $4200-\mathbf{4096}=104$
          li Base + <i>offset</i> $= 34816 + 104 = 34920$
        li Dirección física: $34920$

      br
      br

      div.fragment ¿Cómo conozco el segmento? ¿y el offset?

    div style="width:50%; vertical-align:middle; display:inline-block;" 

      img src='/images/figures/02-segments-2.png' width="40%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"

      div style="width:10%; vertical-align:middle; display:inline-block;" 

      img src='/images/figures/02-segments-1.png' width="23%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"

  section
    h3 Implementando segmentación

    div ¿Cómo conocer segmento y <i>offset</i>?

    ul
      li Se pueden hacer restas &hellip; 
      li Pero la lógica de bit es más rápida

    br
    div.fragment Ejemplo: ¿cuántos bit necesitamos para identificar 3 segmentos? <span class="fragment">$\rightarrow 2$</span>

    img.fragment src='/images/figures/02-segment-bits.png' width="30%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"

    br

    div.fragment style="width:50%; vertical-align:middle; display:inline-block;" 

      ul
        li Dirección virtual: $4200 = 0b01 0000 0110 1000 = 0x1068$
        ul
          li Bits de segmento: $0b01 = 1 = 0x1$
          li Bits de offset: $0b0000 0110 1000 = 104 = 0x068$

    div.fragment style="width:50%; vertical-align:middle; display:inline-block;" 

      pre
        code.hljs.lang-c
          |  SEG_MASK = 0x3000;
             OFFSET_MASK = 0xFFF;
             SEG_SHIFT = 12;
             virtualAddress = 4200;
             segment = (virtualAddress & SEG_MASK) >> SEG_SHIFT;
             offset = virtualAddress & OFFSET_MASK;
             if(offset >= size[segment])
               raise(SEG_FAULT);
             else
               physicalAddress = base[segment] + offset;

  section
    h3 Implementando segmentación

    div style="width:50%; vertical-align:middle; display:inline-block;" 

      table
        tr
          td Segment
          td Base
          td Size 
        tr
          td <code>code</code>
          td 32768 (32KB)
          td 2048 (2KB)
        tr
          td <code>heap</code>
          td 34816 (34KB)
          td 2048 (2KB)
        tr
          td <code>stack</code>
          td 28672 (28KB)
          td 2048 (2KB)

      div <b>Atención con el <i>stack</i></b>.
      
      ul.fragment
        li Dirección virtual (lógica): $16300$
        ul
          li Segmento <code>stack</code> (segmento 3)
          /li <i>Offset</i> dentro de <code>heap</code>: $4200-\mathbf{4096}=104$
          li Base + <i>offset</i> $= 28672 + 4012 = 32684$
        li Dirección física: $32684$ &#x274c;


    div style="width:50%; vertical-align:middle; display:inline-block;" 

      img src='/images/figures/02-segments-2.png' width="40%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"

      div style="width:10%; vertical-align:middle; display:inline-block;" 

      img src='/images/figures/02-segments-1.png' width="23%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"


  section
    h3 Implementando segmentación

    div style="width:50%; vertical-align:middle; display:inline-block;" 

      div Otro campo en la tabla de segmentos

      table
        tr
          td Segment
          td Base
          td Size 
          td Upwards
        tr
          td <code>code</code>
          td 32768 
          td 2048 
          td 1
        tr
          td <code>heap</code>
          td 34816 
          td 2048 
          td 1
        tr
          td <code>stack</code>
          td 28672 
          td 2048 
          td 0

      ul.fragment
        li Dirección virtual (lógica): $16300$
        ul
          li Segmento <code>stack</code> (segmento 3)
          li <i>Offset</i>: complemento de 4096 (4KB, máximo offset). $4012-4096=-84$
          li Base + <i>offset</i> $= 28672 - 84 = 28588$
        li Dirección física: $28588$ &#x2714;


    div style="width:50%; vertical-align:middle; display:inline-block;" 

      img src='/images/figures/02-segments-2.png' width="40%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"

      div style="width:10%; vertical-align:middle; display:inline-block;" 

      img src='/images/figures/02-segments-1.png' width="23%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"


  section
    h3 Visualizando segmentos

    div Comando <code>pmap</code> permite ver segmentos asignados a un proceso

    pre
      code.hljs.bash
        |  pmap -x [PID]

    div Atención: necesita un proceso en ejecución


  section
    h3 Fragmentación

    div Implementamos segmentación para eliminar fragmentación externa

    blockquote style="background:#B7E1CD;" <b>Fragmentación Externa</b>. Espacios libres no contiguos.

    div style="width:50%; vertical-align:middle; display:inline-block;" 

      ul.fragment
        li Menos fragmentación &hellip; pero sigue existiendo
        li Difícil anticipar los tamaños de los segmentos

    div style="width:50%; vertical-align:middle; display:inline-block;" 

      img src='/images/figures/02-fragments-ram.png' width="35%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"



















section#pagination
  h2 Paginación

  section

    div Problema: un espacio de direcciones muy grande.
    ul
      li Idea 1: Dividir el espacio de direcciones en <b>segmentos</b>
      li.fragment data-fragment-index="1" Idea 2: Que los segmentos sean del mismo tamaño: <b>páginas de memoria</b>

    blockquote.fragment data-fragment-index="2" style="background:#F4C7C3;" <b>Paginación</b>

    div.fragment data-fragment-index="2" style="width:50%; vertical-align:middle; display:inline-block;" 

      ul
        li Espacio virtual: <b>páginas</b>
        li Espacio físico: <i><b>frames</b></i> (marcos)
        li Páginas y <i>frames</i> del <b>mismo</b> tamaño

      br 
      br

      div.fragment data-fragment-index="3" Sistema con 128B RAM
      
      ul.fragment data-fragment-index="3" 
        li Espacio virtual (lógico) de 64B.
        li Espacio físico de 128B.
        li Páginas (y <i>frames</i>) de 16B.

    div.fragment data-fragment-index="3" style="width:50%; vertical-align:middle; display:inline-block;" 

      img src='/images/figures/02-pages-1.png' width="50%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"

      img src='/images/figures/02-pages-2.png' width="50%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"

  section

    ul
      li Sistema necesita llevar registro de páginas asignadas a cada proceso
      li Sistema necesita información para traducir direcciones virtuales a físicas

    blockquote.fragment data-fragment-index="1" style="background:#B7E1CD;" <b>Tabla de Páginas</b>

    div.fragment data-fragment-index="2" style="width:70%; vertical-align:middle; display:inline-block;" 

      div.fragment data-fragment-index="2" Páginas de 16B, espacio virtual 64B, espacio físico 128B.

      ul
        li.fragment data-fragment-index="3" Direcciones posibles en una página: $16 = 2^4$<span class="fragment" data-fragment-index="4">$\rightarrow 4$ bit.</span>
        ul.fragment data-fragment-index="5" style='font-size:32px;'
          li 4 bit indican el <i>offset</i> dentro de una página.
        li.fragment data-fragment-index="6" Espacio virtual de $64=2^6$ Byte. Requiere $6$ bit.
        ul.fragment data-fragment-index="7" style='font-size:32px;'
          /li 4 bit indican el <i>offset</i>
          li 2 bit indican el número de página (VPN).
          li Páginas posibles: $2^2=4$ entradas en la tabla de páginas
        li.fragment data-fragment-index="8" Espacio virtual de $128=2^7$ Byte. Require $7$ bit.
        ul.fragment data-fragment-index="9" style='font-size:32px;'
          /li 4 bit indican el <i>offset</i>
          li 3 bit indican el número de <i>frame</i> (PFN).
          li <i>Frames</i> en la memoria principal: $2^3=8$ <i>frames</i>

      br
      br

      div.fragment data-fragment-index="10" Traducción VPN$\to$PFN en la Tabla de Páginas

    div.fragment data-fragment-index="2" style="width:30%; vertical-align:middle; display:inline-block;" 

      img src='/images/figures/02-page-translation.png' width="70%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"


  section
    h3 Tabla de Páginas

    div Páginas de 16B, espacio virtual 64B, espacio físico 128B.

    div.fragment data-fragment-index="1" style="width:100%; vertical-align:middle; display:inline-block;" 

      img src='/images/figures/02-pages-1.png' width="30%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"

      div style="display:inline-block;" &nbsp; &nbsp; &nbsp; 

      img src='/images/figures/02-page-translation.png' width="20%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"

      div style="display:inline-block;" &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;

      img src='/images/figures/02-pages-2.png' width="25%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"

    div.fragment data-fragment-index="2" style="width:50%; vertical-align:middle; display:inline-block;" 

      table style='font-size:28px;'
        tr
          td Page (VPN)
          td Frame (PFN)
        tr
          td 0 (0b00) 
          td 3 (0b011)
        tr
          td 1 (0b01)
          td 7 (0b111)
        tr
          td 2 (0b10)
          td 5 (0b101)
        tr
          td 3 (0b11)
          td 2 (0b010)

    div.fragment data-fragment-index="3" style="width:50%; vertical-align:middle; display:inline-block;" 

      div Dirección virtual: $21\; (0b010101)$
      ul.fragment data-fragment-index="4" style='font-size:28px;'
        li #Página: $1\; (0b01)$
        li <i>Offset</i>: $5\; (0b0101)$
        li Tabla: $1 \rightarrow 7$
      div.fragment data-fragment-index="5" Dirección física: $117\; (0b1110101)$


  section
    h3 Tabla de Páginas

    div Páginas de 4KB, dirección virtual de 16 bit, dirección física de 15 bit.

    div.fragment data-fragment-index="2" style="width:65%; vertical-align:middle; display:inline-block;" 

      div <b>Dimensiones</b>
      ul
        li Tamaño de espacio virtual: <span class="fragment" data-fragment-index="3">$2^{16} \text{B} =65536 \text{B} = 64\text{KB}$</span>
        li Tamaño de espacio físico: <span class="fragment" data-fragment-index="4">$2^{15} \text{B} =32768 \text{B} = 32\text{KB}$</span>
        li Tamaño de página: <span class="fragment" data-fragment-index="5">$4\text{KB}=2^2\times2^{10}\text{B}= 2^{12}\text{B}$</span>
        li Bits para <i>offset</i>: <span class="fragment" data-fragment-index="6">$12$ (rango: $0x000$ a $0xFFF$)</span>
        li Bits para #página: <span class="fragment" data-fragment-index="7">$4$ (16 páginas)</span>
        li Bits para #frame: <span class="fragment" data-fragment-index="8">$3$ (8 frames)</span>

      div <b>Traducción</b>
      ul
        li Dirección lógica: $8196\; (0x2004)$
        ul.fragment data-fragment-index="9"
          li #Página: 2
          li #Frame: 6
        li Dirección física: <span class="fragment" data-fragment-index="10">$24580\; (0x6004)$</span>

    div.fragment data-fragment-index="1" style="width:35%; vertical-align:middle; display:inline-block;" 

      img src='/images/figures/02-page-translation-big.png' width="100%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"
      br
      div style='font-size:16px;' Ignoramos el "present/absent" bit, &hellip; por ahora


  section data-transition="fade-out"
    blockquote style="background:#B7E1CD;" <b>¿De qué tamaño es una tabla de páginas?</b>

    ul.fragment data-fragment-index="1"
      li Arquitectura con espacio de direcciones virtuales de 32 bit
      li Páginas de $4$KB. $20$ bit para #página, $12$ bit para <i>offset</i>
      li ¿Cuántas páginas? $2^{20}$. Tabla de páginas necesita $2^{20}$ entradas (filas, o PTE, <i>Page Table Entry</i>)

    blockquote.fragment data-fragment-index="2" style="background:#B7E1CD;"  <b>¿De qué tamaño es una entrada en la tabla de páginas?</b>

    div.fragment data-fragment-index="3" Al menos necesita los bit para el #<i>frame</i>. Si el espacio físico es de 32 bit, necesita $20$ bit.

    div.fragment data-fragment-index="3" style="width:50%; vertical-align:middle; display:inline-block; font-size:16px;"
      img src='/images/figures/02-pte.png' width="100%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"
    div.fragment data-fragment-index="3" style="width:10%; vertical-align:middle; display:inline-block; font-size:16px;" PTE en x86

    ul.fragment data-fragment-index="4" style='font-size:24px;'
      li <code>V</code>, <b>valid bit</b> (no está en la imagen), indica si la página ha sido asignada
      li <code>P</code>, <b>present bit</b>, indica si la página está en memoria o en disco.
      li <code>RW</code>, <b>read/write bit</b>, indica si se puede escribir
      li <code>U/S</code>, user-supervisor bit, indica si se puede acceder en <i>user-mode</i>
      li <code>PWT</code>, <code>PCD</code>, <code>PAT</code>, <code>G</code>, controlan el <i>caching</i>
      li <code>A</code>, <b>accessed bit</b>, o <b>reference bit</b> indica si la página ha sido leída
      li <code>D</code>, <b>dirty bit</b>, indica si la página ha sido modificada

  section data-transition="fade-in"
    blockquote style="background:#B7E1CD;" <b>¿De qué tamaño es una tabla de páginas?</b>

    ul
      li Arquitectura con espacio de direcciones virtuales de 32 bit
      li Páginas de $4$KB. $20$ bit para #página, $12$ bit para <i>offset</i>
      li ¿Cuántas páginas? $2^{20}$. Tabla de páginas necesita $2^{20}$ entradas (filas, o PTE, <i>Page Table Entry</i>)

    blockquote style="background:#B7E1CD;"  <b>¿De qué tamaño es una entrada en la tabla de páginas?</b>

    div Al menos necesita los bit para el #<i>frame</i>. Si el espacio físico es de 32 bit, necesita $20$ bit.

    div style="width:50%; vertical-align:middle; display:inline-block; font-size:16px;"
      img src='/images/figures/02-pte.png' width="100%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"
    div style="width:10%; vertical-align:middle; display:inline-block; font-size:16px;" PTE en x86

    ul style='font-size:24px;'
      li #PTEs: $2^{20}$. Tamaño de cada PTE: $32$ bit $= 4\text{B}$
      li Tamaño de tabla de páginas: $2^{20} \times 2^2 \text{B} = 4\text{MB}$
      li Cada proceso requiere $4\text{MB}$ de memoria principal <b>sólo para su tabla de páginas</b>.
      li Tabla de páginas se almacena en memoria virtual del Sistema Operativo.

    div.fragment <b>Problema</b>: tablas de páginas grandes &#x1f61e;

  section
    blockquote style="background:#B7E1CD;"  <b>¿Cuántos accesos a memoria?</b>

    div Dirección de tabla de páginas se guarda en PCB, como <b>PageTableBaseRegister</b> (PTBR)

    div.fragment data-fragment-index="2" style="width:55%; vertical-align:middle; display:inline-block;" 

      pre
        code.hljs.lang-c
          |  VPN = (virtualAddress & VPN_MASK) >> VPN_SHIFT;
             PTEAddress = PageTableBaseRegister + (VPN * sizeof(PTE));
             PTE = ReadMemory(PTEAddress);
             
             // está en memoria
             if(!PTE.valid)
               raise(SEG_FAULT);
             // verificación de permisos
             else if(PTE.protected)       
               raise(PROTECTION_FAULT);
             // Acceso OK
             else {
               offset = virtualAddress & OFFSET_MASK;
               physicalAddress = (PTE.PFN << PFN_SHIFT) | offset;
               register = ReadMemory(physicalAddress);

      div <b>Cada acceso a memoria se convierte en DOS accesos</b>

      div <b>Problema</b>: accesos en el doble de tiempo &#x1f61e;

    div.fragment data-fragment-index="2" style="width:45%; vertical-align:middle; display:inline-block;" 

      img src='/images/figures/02-8_10.pdf.png' width="100%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"















section#pag_tlb
  h2 Paginación con TLB

  section

    div Solución para acelerar acceso a memoria: <i>fully associative caché</i> de direcciones en MMU

    blockquote.fragment data-fragment-index="1" style="background:#F4C7C3;" <b>Translation Look-aside Buffer (TLB)</b> /

    div style="width:60%; vertical-align:middle; display:inline-block;" 

      ul.fragment data-fragment-index="2" style='font-size:24px;'
        li Si la dirección está en el caché (<i>TLB hit</i>), se responde directamente
        li Si la dirección no está en el caché (<i>TLB miss</i>), se lee desde la memoria y se actualiza TLB

      pre.fragment data-fragment-index="4"
        code.hljs.lang-c style="max-height:600px;"
          |  VPN = (virtualAddress & VPN_MASK) >> VPN_SHIFT;
             (Success, TLBEntry) = TLB_Lookup(VPN);
             if(Success) {         //TLB Hit: UN acceso a memoria
               if(!TLBEntry.protected) {
                 offset = virtualAddress & OFFSET_MASK;
                 physicalAddress = (TLBEntry.PFN << PFN_SHIFT) | offset;
                 register = ReadMemory(physicalAddress);
               }
               else raise(PROTECTION_FAULT);
             }
             else {                //TLB Miss: DOS accesos a memoria
               PTEAddress = PageTableBaseRegister + (VPN * sizeof(PTE));
               PTE = ReadMemory(PTEAddress);
               if(!PTE.valid)          raise(SEG_FAULT);
               else if (PTE.protected) raise(PROTECTION_FAULT);
               else {
                 TLB_Insert(VPN, PTE);
                 Retry();
               }
             }


    div.fragment data-fragment-index="3" style="width:40%; vertical-align:middle; display:inline-block;" 

      img src='/images/figures/02-8_14.pdf.png' width="100%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"

  section
    h3 Efectividad de TLB

    div Ejemplo: espacio virtual de 8 bit, con páginas de 16 B, almacenando arreglo de 10 <code>int</code> (4B).

    div style="width:75%; vertical-align:middle; display:inline-block;" 

      ul
        li 4 bit para <i>offset</i>. 4 bit para #página. 16 páginas.

      pre.fragment data-fragment-index="1"
        code.hljs.lang-c
          | int sum = 0;
            for(i=0; i<10; i++)
              sum += a[i];

      ul.fragment data-fragment-index="2"
        li Considerando sólo el acceso a <code>a</code>
        li Sin TLB: 10 $\times$ (acceso tabla de páginas, acceso <code>a[i]</code>)
        ul
          li 20 accesos a memoria
        li.fragment data-fragment-index="3" Con TLB: miss, hit, hit, miss, hit, hit, hit, miss, hit, hit
        ul.fragment data-fragment-index="3"
          li 10 accesos a <code>a[i]</code>, 3 accesos a tabla de páginas (miss)
          li 13 accesos a memoria

      div.fragment data-fragment-index="4" 7 de 10 accesos ahorrados: $70\%$ TLB <i>Hit Rate</i>

      div.fragment data-fragment-index="4" style='font-size:18px;' Con páginas más grandes, el <i>Hit Rate</i> hubiese aumentado


    div style="width:25%; vertical-align:middle; display:inline-block;" 

      img src='/images/figures/02-tlb-effect.png' width="100%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"

  section
    h3 Efectividad de TLB

    div ¿Es bueno $70\%$ de TLB <i>Hit Rate</i>?

    div style="width:75%; vertical-align:middle; display:inline-block;" 

      pre
        code.hljs.lang-c
          | int sum = 0;
            for(i=0; i<10; i++)
              sum += a[i];

      ul
        li Un acceso a memoria física $\approx 100\text{ns} = 10^{-7}\text{s}$
        li Un acceso a TLB $\approx 1\text{ns} = 10^{-9}\text{s}$
        li TLB Hit $\approx 101\text{ns}$
        li TLB Miss $\approx 201\text{ns}$

      ul.fragment
        li Sin TLB. 20 acc. a memoria. $2000\text{ns} = 2\times 10^{-6}\text{s}$
        li Con TLB. 13 acc. a memoria, 10 acc. a TLB. $1310\text{ns} = 1.31 \times 10^{-6}\text{s}$
        li Aceleración: $2000/1310 \approx 1.52$ veces más rápido.
        li Tiempo promedio de acceso: $201\text{ns} \times 0.3 + 101\text{ns} \times 0.7 = 131\text{ns}$

      blockquote.fragment style="background:#B7E1CD;" TLB Hit Rate reales $\approx 99\%$


    div style="width:25%; vertical-align:middle; display:inline-block;" 

      img src='/images/figures/02-tlb-effect.png' width="100%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"

  section
    h3 Efectividad de TLB

    div TLB Hit Rate reales $\approx 99\%$

    div <b>¿Por qué funciona?</b>

    div style="width:50%; vertical-align:middle; display:inline-block;" 

      blockquote style="background:#B7E1CD;" Localidad Espacial

      pre
        code.hljs.lang-c
          | int sum = 0;
            for(i=0; i<1000; i++)
              sum += a[i];

      div.fragment data-fragment-index="1" align="left" Después de acceder a una dirección <code>x</code>, el programa probablemente accederá a direcciones cercanas a <code>x</code>

      ul.fragment data-fragment-index="2"
        li Luego de un <i>miss</i>, y guardar un PTE en TLB, vendrán muchos <i>hit</i>


    div style="width:50%; vertical-align:middle; display:inline-block;" 

      blockquote style="background:#B7E1CD;" Localidad Temporal

      pre
        code.hljs.lang-c
          | int sum = 0;
            for(k=0; k<10; k++)
              for(i=0; i<1000; i++)
                sum += a[i];

      div.fragment data-fragment-index="3" align="left" Una dirección <code>x</code> que acaba de ser accedida, probablemente será accedida de nuevo dentro de poco tiempo

      ul.fragment data-fragment-index="4"
        li Una PTE recién guardada, volverá a ser usada pronto

    div.fragment data-fragment-index="5" <i>El comportamiento real depende del programa, pero la mayor parte del tiempo los programas manifiestan localidad de referencia (espacial o temporal).</i>


  section
    h3 Detalles de TLB

    div <b>¿Dónde se guardan los datos de un TLB ante un cambio de contexto?</b>

    ul.fragment data-fragment-index="1"
      li TLB no se almacena en memoria del S.O. (como la Tabla de Páginas), ni en el PCB
      li PTBR se actualiza en cada cambio de contexto
      li PTEs de un proceso no sirven al siguiente proceso
      li Se puede borrar completamente el TLB (<i>flush</i>), marcando todas los <b>valid bit</b> en 0.

    img src='/images/figures/02-tlb-entry.png' width="50%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"

    div style='font-size:18px;' TLB Entry de un MIPS R4000

    ul.fragment data-fragment-index="2"
      li <code>V</code> indica si la <b>entrada del TLB</b> es válida
      ul
        li style='font-size:20px;' Atención: no es el mismo valid bit de la PTE
      li <code>ASID</code> indica el <b>Address Space Identifier</b>
      ul
        li Cada proceso tiene su propio <code>ASID</code> (en su PCB)
        li Campo <code>ASID</code> permite que coexistan entradas de distintos procesos en el TLB
      















section#pag_tlb
  h2 Variantes de paginación

  section

    div <b>Problema</b>: tablas de páginas muy grandes &#x1f61e;

    ul.fragment data-fragment-index="1"
      li Arquitectura con espacio de direcciones virtuales de 32 bit
      li Páginas de $4$KB. $20$ bit para #página, $12$ bit para <i>offset</i>
      li Tabla de páginas necesita $2^{20}$ PTEs
      li Tamaño de cada PTE: $32$ bit $= 4\text{B}$
      li Tamaño de tabla de páginas: $2^{20} \times 2^2 \text{B} = 4\text{MB}$
      li Con 100 procesos, se gasta $400\text{MB}$ del Sistema Operativo <b>sólo en tablas de páginas</b>.

    blockquote.fragment data-fragment-index="2" style="background:#B7E1CD;" Solución: <i>páginas más grandes</i>

    ul.fragment data-fragment-index="3"
      li Con páginas de $1\text{MB}$. $20$ bit para <i>offset</i>, $12$ bit para #página
      li Tablas de páginas necesita $2^{12}$ PTEs
      li Tamaño de tabla de páginas: $16\text{KB}$ &#x1f389;

  section
    h3 Fragmentación Interna

    blockquote style="background:#B7E1CD;" <b>Fragmentación Externa</b>. Espacios libres no contiguos.

    div Paginación elimina la fragmentación externa (¿por qué?), pero &hellip;

    blockquote.fragment data-fragment-index="1" style="background:#B7E1CD;" <b>Fragmentación Interna</b>. Espacios sobreasignado.

    div.fragment data-fragment-index="2" Si las páginas son de $1\text{MB}$ &hellip;

    ul.fragment data-fragment-index="3" 
      li Procesos de $x\text{MB}$, con $x$ entero reciben la cantidad exacta de espacio.
      li Un proceso de $16\text{KB}$ recibe $1\text{MB}$ ($1008\text{KB}$ desperdiciados)
      li Un proceso de $1025 \text{KB}$ recibe $2\text{MB}$

    div.fragment data-fragment-index="4" Espacio se asigna a los procesos pero no se utiliza

    br

    div.fragment data-fragment-index="4" Paginas más grandes aumentan la fragmentación interna. &#x1f61e;

    br

    div.fragment data-fragment-index="5" ¿De qué tamaño son las páginas de su sistema? (Tip: <code>getconf PAGE_SIZE</code>)



  section
    h3 Segmentos paginados

    div Procesos no suelen ocupar todas sus páginas

    div style="width:70%; vertical-align:middle; display:inline-block;" 

      div Espacio virtual con 16 páginas.
      ul
        li Proceso utiliza efectivamente: 4 páginas
        li 12 entradas vacías ($75\%$) en tabla de páginas


      img.fragment data-fragment-index="1" src='/images/figures/02-hybrid-va.png' width="100%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"

      br
      div.fragment data-fragment-index="2" <b>Idea</b>: una tabla de páginas por segmento
      ul.fragment data-fragment-index="3"
        li Tablas de páginas más pequeña &#x1f603;
        li <code>base</code> (direcc. de tabla de páginas)
        li <code>limit</code> (#paginas)
        li Vuelve la fragmentación externa &#x1f61f;

    div style="width:30%; vertical-align:middle; display:inline-block;" 

      img src='/images/figures/02-hybrid.png' width="100%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"




  section
    h3 Tablas de páginas multinivel

    div En lugar de segmentar, mejor <b>paginar</b> la tabla de páginas

    div
      img src='/images/figures/02-multilevel-va.png' width="30%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"

    div style="width:60%; vertical-align:middle; display:inline-block;" 

      ul.fragment data-fragment-index="2"
        li Dirección virtual de 14-bit, páginas de $64\text{B}$.
        li Esquema de 1 nivel: 256 PTEs. 
        ul style='font-size:24px;'
          li Memoria: $256 \times 4\text{B} = 2\text{KB}$
        li Esquema de 2 niveles: 16 PTEs en tabla principal, 16 PTEs en 16 tablas de 2do nivel
        ul style='font-size:24px;'
          li Memoria: Al menos tabla principal + 1 tabla secundaria
          li Memoria: $16 \times 4\text{B} + 16 \times 4\text{B} = 128{B}$
        

    div style="width:40%; vertical-align:middle; display:inline-block;" 

      img src='/images/figures/02-multilevel-1.png' width="100%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"


  section
    h3 Tablas de páginas multinivel

    div Esquema se puede extender a más niveles

    div
      img src='/images/figures/02-multilevel-2.png' width="40%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"

    div style="width:50%; vertical-align:middle; display:inline-block;" 

      ul
        li En memoria se necesita la tabla de páginas del primer nivel (completa), y una tabla de cada nivel para poder resolver una dirección física
        li Cada división puede tener distintos tamaños


    div style="width:50%; vertical-align:middle; display:inline-block;" 

      img src='/images/figures/02-multilevel-3.png' width="80%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"

  section
    h3 Tablas de páginas invertidas

    div En lugar de guardar una tabla por proceso, mantener una tabla <b>única para todo el sistema</b>

    div style="width:50%; vertical-align:middle; display:inline-block;" 

      ul
        li Indice es el <i>frame</i>. Una PTE por <i>frame</i>.
        li Clave de búsqueda es $\langle$ pid, #page $\rangle$
        li Consume menos memoria &#x1f603;
        li Pero búsqueda es lenta (secuencial) &#x1f61e;
        li Alternativa: usar <i>hashing</i>

    div style="width:50%; vertical-align:middle; display:inline-block;" 

      img src='/images/figures/02-8_20.pdf.png' style="background:none; border:none; box-shadow:none;" width="100%"

    div PowerPC usaba este esquema


















section#page_replace
  h2 Reemplazo de páginas

  section
    div <b>Supuesto a eliminar</b>: todo el espacio de direcciones cabe en memoria física

    div Procesos pueden tener parte de su memoria no cargada aún (en disco), o en <i>swap</i> (en disco).

    blockquote.fragment data-fragment-index="1" style="background:#B7E1CD;" Desafío: usar efectivamente el disco (grande, pero lento) para proveer la ilusión que <b>todo</b> el espacio virtual está en memoria

    br

    div.fragment data-fragment-index="2" Procesos deben seguir creyendo que pueden acceder a todo el rango de direcciones virtuales

    ul.fragment data-fragment-index="2" 
      li ¿Por qué? Es más fácil para el proceso (separa la <i>ilusión</i> de la realidad)
      li Sistema Operativo se encarga de cargar las páginas <i>on-demand</i>

    br
    br

    div.fragment data-fragment-index="3"  Si no caben más páginas en memoria física, alguna debe salir para hacer más espacio

    blockquote.fragment data-fragment-index="3" style="background:#B7E1CD;" ¿Qué página eliminar?, y ¿a dónde moverla?



  section
    h3 Swap space

    blockquote style="background:#B7E1CD;" ¿A dónde mover las páginas de memoria?

    div.fragment data-fragment-index="1" Páginas que van a ser borradas de memoria van a <i>espacio de <b>swap</b></i>

    ul.fragment data-fragment-index="1"
      li Representan parte del espacio de memoria de un proceso <b>en ejecución</b>
      li Tabla de páginas utiliza <b>present bit</b> para saber si la página está en un <i>frame</i> o no

    blockquote.fragment data-fragment-index="2" style="background:#B7E1CD;" Si la página no está presente, se genera un <b>page fault</b>

    div.fragment data-fragment-index="2" <b>Page fault</b> activa el mecanismo de recuperación de una página desde disco a memoria física
    ul.fragment data-fragment-index="2"
      li Sistema Operativo atiende el <i>page fault</i>
      li Cuando el <i>page fault</i> ha sido resuelto, el proceso puede continuar

  section
    h3 Page Fault

    div Ante un <i>page fault</i>, el sistema operativo va a buscar la página

    div style="width:60%; vertical-align:middle; display:inline-block;" 

      div style='font-size:26px;' Algoritmo para paginación con TLB, y <i>page faults</i>

      pre
        code.hljs.lang-c style="max-height:600px;"
          |  VPN = (virtualAddress & VPN_MASK) >> VPN_SHIFT;
             (Success, TLBEntry) = TLB_Lookup(VPN);
             if(Success) {         //TLB Hit
               if(!TLBEntry.protected()) {
                 offset = virtualAddress & OFFSET_MASK;
                 physicalAddress = (TLBEntry.PFN << PFN_SHIFT) | offset;
                 register = ReadMemory(physicalAddress);
               }
               else raise(PROTECTION_FAULT);
             }
             else {                //TLB Miss
               PTEAddress = PageTableBaseRegister + (VPN * sizeof(PTE));
               PTE = ReadMemory(PTEAddress);    // lectura tabla de paginas
               if(!PTE.valid)          raise(SEG_FAULT);
               else if (PTE.protected) raise(PROTECTION_FAULT);
               else if (!PTE.present)  raise(PAGE_FAULT);
               else {                  // pagina en memoria
                 TLB_Insert(VPN, PTE);
                 Retry();
               }
             }


    div style="width:40%; vertical-align:middle; display:inline-block;" 

      img src='/images/figures/02-9_01.pdf.png' style="background:none; border:none; box-shadow:none;" width="100%"

  section
    h3 Page Fault

    div Mecanismo de rutina <i>page-fault handler</i>

    div style="width:60%; vertical-align:middle; display:inline-block;" 

      div style='font-size:26px;' Algoritmo para manejar un <i>page fault</i>

      pre
        code.hljs.lang-c style="max-height:600px;"
          |  PFN = FindFreePhysicalPage();   // busca frame libre
             if(PFN == -1)                   '// no había frame libre :'(
               PFN = ReplacePage();          // rutina de reemplazo de página

             // Copia desde el disco a la memoria. Proceso queda "waiting on I/O"
             DiskRead(PTE.DiskAddress, PFN);

             // Actualiza tabla de páginas
             PTE.present = TRUE;
             PTE.PFN = PFN;

             // Vuelve a ejecutar la instrucción que generó el PAGE_FAULT 
             Retry(); 

    div style="width:40%; vertical-align:middle; display:inline-block;"  

      img src='/images/figures/02-9_06.pdf.png' style="background:none; border:none; box-shadow:none;" width="100%"

  section

    blockquote style="background:#B7E1CD;" ¿Qué página reemplazar?

    div La ocurrencia de un <i>page-fault</i> es algo malo (significa acceder al disco)

    br
    br

    div Cualquier algoritmo de decisión debe intentar minimizar la ocurrencia de <i>page-faults</i>

    br
    br

    div Ejemplo: direcciones virtuales de 16 bit, páginas de 4KB
    ul 
      li Ocurre un <i>page-fault</i> para acceder a la dirección $0x6300$ (página $6$)
      li Se escoge la página $9$ y se hace <i>swap</i>
      li Proceso continúa y solicita dirección $0x9204$
      li Ocurre otro <i>page-fault</i>
      li No fue tan buena idea haber sacado la página $9$.

  section
    h3 MIN: Reemplazo óptimo

    div Planteado por Laszlo A. Belady, 1966

    blockquote style="background:#B7E1CD;" Elegir la que será usada lo más lejos posible en el futuro

    div style="width:60%; vertical-align:middle; display:inline-block;"  

      div style='font-size:32px;' Ejemplo: Sistema con 3 <i>frames</i> como máximo para un proceso

      div style='font-size:32px;' Secuencia de accesos a páginas: 0, 1, 2, 0, 1, 3, 0, 3, 1, 2, 1

      table style='font-size:20px;'
        tr
          td Página
          td Hit/Miss
          td Reemplazar
          td Páginas en mem.
        tr
          td 0
          td Miss
          td
          td 0
        tr
          td 1
          td Miss
          td
          td 0, 1
        tr
          td 2
          td Miss
          td
          td 0, 1, 2
        tr
          td 0
          td Hit
          td
          td 0, 1, 2
        tr
          td 1
          td Hit
          td
          td 0, 1, 2
        tr
          td 3
          td Miss
          td 2
          td 0, 1, 3
        tr
          td 0
          td Hit
          td
          td 0, 1, 3
        tr
          td 3
          td Hit
          td
          td 0, 1, 3
        tr
          td 1
          td Hit
          td
          td 0, 1, 3
        tr
          td 2
          td Miss
          td 3
          td 0, 1, 2
        tr
          td 1
          td Hit
          td
          td 0, 1, 2

    div style="width:40%; vertical-align:middle; display:inline-block;"  

      div style='font-size:32px;' Tasa de hits (<i>Hit Rate</i>)

      div style='font-size:32px;' $\text{Hit Rate} = \frac{6}{6+5} = 0.545$

      div style='font-size:32px;' Si ignoramos el primer <i>miss</i> de cada página (<i>cold start</i>)

      div style='font-size:32px;' $\text{Hit Rate} = \frac{6}{6+1} = 0.857$

      br
      br

      div El mejor algoritmo &#x1f603;

      div Pero no podemos conocer el futuro &#x1f61e;

      /br

      /div ¿Qué hacer? &hellip; aproximarlo

  section
    h3 FIFO: First In First Out

    div Muy simple de implementar 

    blockquote style="background:#B7E1CD;" Elegir la página que lleva más tiempo en memoria

    div style="width:60%; vertical-align:middle; display:inline-block;"  

      div style='font-size:32px;' Ejemplo: Sistema con 3 <i>frames</i> como máximo para un proceso

      div style='font-size:32px;' Secuencia de accesos a páginas: 0, 1, 2, 0, 1, 3, 0, 3, 1, 2, 1

      table style='font-size:20px;'
        tr
          td Página
          td Hit/Miss
          td Reemplazar
          td Páginas en mem.
        tr
          td 0
          td Miss
          td
          td Queue: 0
        tr
          td 1
          td Miss
          td
          td Queue: 0, 1
        tr
          td 2
          td Miss
          td
          td Queue: 0, 1, 2
        tr
          td 0
          td Hit
          td
          td Queue: 0, 1, 2
        tr
          td 1
          td Hit
          td
          td Queue: 0, 1, 2
        tr
          td 3
          td Miss
          td 0
          td Queue: 1, 2, 3
        tr
          td 0
          td Miss
          td 1
          td Queue: 2, 3, 0
        tr
          td 3
          td Hit
          td
          td Queue: 2, 3, 0
        tr
          td 1
          td Miss
          td 2
          td Queue: 3, 0, 1
        tr
          td 2
          td Miss
          td 3
          td Queue: 0, 1, 2
        tr
          td 1
          td Hit
          td
          td Queue: 0, 1, 2

    div style="width:40%; vertical-align:middle; display:inline-block;"  

      div style='font-size:32px;' <i>Hit Rate</i>

      div style='font-size:32px;' $\text{Hit Rate} = \frac{4}{4+7} = 0.364$

      div style='font-size:32px;' Sin <i>cold start</i>

      div style='font-size:32px;' $\text{Hit Rate} = \frac{4}{4+3} = 0.571$

      br
      br

      div Más malo que MIN &#x1f61e;

      div Si hay más <i>frames</i> disponibles, se debería comportar mejor (¿o no?)


  section
    h3 RANDOM

    div Simple de implementar 

    blockquote style="background:#B7E1CD;" Elegir una página aleatoria

    div style="width:60%; vertical-align:middle; display:inline-block;"  

      div style='font-size:32px;' Ejemplo: Sistema con 3 <i>frames</i> como máximo para un proceso

      div style='font-size:32px;' Secuencia de accesos a páginas: 0, 1, 2, 0, 1, 3, 0, 3, 1, 2, 1

      img src='/images/figures/02-random.png' style="background:none; border:none; box-shadow:none;" width="60%"

      div style='font-size:32px;' 10000 ejecuciones

    div style="width:40%; vertical-align:middle; display:inline-block;"  

      ul
        li MIN <i>hits</i>: 6
        li FIFO <i>hits</i>: 4

      br
      br

      div FIFO y RANDOM no aprovechan la localidad de referencia

      br
      br

      div Podrían eliminar páginas que van a usarse en el corto plazo.

  section
    h3 LRU: Least Recently Used

    div Una página que se usó recientemente, probablemente pronto será usada otra vez

    blockquote style="background:#B7E1CD;" Elegir la página que lleva más tiempo sin usarse


    div style="width:60%; vertical-align:middle; display:inline-block;"  

      div style='font-size:32px;' Ejemplo: Sistema con 3 <i>frames</i> como máximo para un proceso

      div style='font-size:32px;' Secuencia de accesos a páginas: 0, 1, 2, 0, 1, 3, 0, 3, 1, 2, 1

      table style='font-size:20px;'
        tr
          td Página
          td Hit/Miss
          td Reemplazar
          td Páginas en mem.
        tr
          td 0
          td Miss
          td
          td LRU: 0
        tr
          td 1
          td Miss
          td
          td LRU: 0, 1
        tr
          td 2
          td Miss
          td
          td LRU: 0, 1, 2
        tr
          td 0
          td Hit
          td
          td LRU: 1, 2, 0
        tr
          td 1
          td Hit
          td
          td LRU: 2, 0, 1
        tr
          td 3
          td Miss
          td 2
          td LRU: 0, 1, 3
        tr
          td 0
          td Hit
          td 
          td LRU: 1, 3, 0
        tr
          td 3
          td Hit
          td
          td LRU: 1, 0, 3
        tr
          td 1
          td Hit
          td 
          td LRU: 0, 3, 1
        tr
          td 2
          td Miss
          td 0
          td LRU: 3, 1, 2
        tr
          td 1
          td Hit
          td
          td LRU: 3, 2, 1

    div style="width:40%; vertical-align:middle; display:inline-block;"  

      div style='font-size:32px;' <i>Hit Rate</i>

      div style='font-size:32px;' $\text{Hit Rate} = \frac{6}{6+5} = 0.545$

      div style='font-size:32px;' Sin <i>cold start</i>

      div style='font-size:32px;' $\text{Hit Rate} = \frac{6}{6+1} = 0.857$

      br
      br

      ul 
        li MIN: 1 <i>miss</i>, Hit Rate $0.857$
        li FIFO: 3 <i>misses</i>, Hit Rate $0.571$
        li Similar a MIN &#x1f603;
        li Implementable &#x1f603;
        li ¿Eficientemente? &#x1f914;


  section
    h3 Workload sin localidad

    div Algoritmos de reemplazo se comparan ejecutándolos bajo una secuencia de accesos a páginas (<i>workload</i>), y distinta cantidad de <i>frames</i> disponibles.


    div style="width:65%; vertical-align:middle; display:inline-block;"  

      div 100 páginas. Secuencia de 10000 accesos sin localidad.

      br
      br

      ul
        li Sin localidad todas las políticas que podemos implementar se comportan igual
        li Con suficientes <i>frames</i> disponibles se llega a <i>Hit Rate</i> 1.
        li Patrón poco común (pero posible)


    div style="width:35%; vertical-align:middle; display:inline-block;"  

      img src='/images/figures/02-replacement-nolocality.png' width="90%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"

      ul style='font-size:18px;'
        li La cantidad de <i>frames</i> disponibles es como una cantidad de bloques de caché en memoria física
        li OPT $\equiv$ MIN


  section
    h3 Workload 80-20

    div 100 páginas. Secuencia con 80% de localidad en 10000 accesos.

    div style="width:65%; vertical-align:middle; display:inline-block;"  

      ul
        li 80% de los 10000 accesos se hacen a un 20% de páginas (<i>hot pages</i>)
        li 20% de los 10000 accesos se hacen al 80% de páginas restantes (<i>cold pages</i>)
      br
      br

      ul
        li LRU mejor que FIFO y RANDOM
        li Patrón más común


    div style="width:35%; vertical-align:middle; display:inline-block;"  

      img src='/images/figures/02-replacement-8020.png' width="90%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"

      ul style='font-size:18px;'
        li La cantidad de <i>frames</i> disponibles es como una cantidad de bloques de caché en memoria física
        li OPT $\equiv$ MIN



  section
    h3 Workload con loop secuencial

    div 100 páginas. Acceso secuencial a 50 páginas (0, 1, &hellip;, 49). Se repite hasta completar 10000 accesos.

    div style="width:65%; vertical-align:middle; display:inline-block;"  

      ul
        li FIFO y LRU eliminan las páginas más "antiguas"
        li RANDOM se comporta mejor
      br
      br

      ul
        li Peor caso para FIFO y LRU
        li Patrón común en muchas aplicaciones
        li Tamaño del conjunto de páginas usadas es crítico


    div style="width:35%; vertical-align:middle; display:inline-block;"  

      img src='/images/figures/02-replacement-loop.png' width="90%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"

      ul style='font-size:18px;'
        li La cantidad de <i>frames</i> disponibles es como una cantidad de bloques de caché en memoria física
        li OPT $\equiv$ MIN


  section
    h3 Implementando LRU

    div ¿Fácil de implementar?

    ul
      li Estructura para FIFO se actualiza en cada <i>miss</i>
      li Estructura para LRU se actualiza en <b>cada acceso</b> &#x1f62e;

    br
    br
    div.fragment data-fragment-index="1" <i>Algunas alternativas para implementar LRU</i>

    ul.fragment data-fragment-index="2"
      li Mantener cola ordenada en cada acceso a memoria. Caro.
      li Agregar <i>timestamp</i> en cada acceso. Puede ser por <i>hardware</i> (más barato).
      ul
        li Al momento de reemplazar se elige la que tiene menor <i>timestamp</i>
        li Requiere comparar <i>todas</i> las páginas candidatas. Caro.


  section
    h3 Aproximando LRU

    div LRU se puede <i>aproximar</i> con ayuda del <i>hardware</i>

    blockquote.fragment data-fragment-index="1" style="background:#B7E1CD;" <b>Algoritmo del reloj (clock)</b>

    div.fragment data-fragment-index="1" style='font-size:18px;' Casi igual que <b>algoritmo de segunda oportunidad</b>

    div.fragment data-fragment-index="2"  Aproximación basada en <b>reference bit</b> (1 si la página ha sido usada)

    div.fragment data-fragment-index="3" style="width:60%; vertical-align:middle; display:inline-block;"  

      ul
        li Algoritmo apunta a una página (cualquiera)
        li Al momento de elegir, se mira <b>reference bit</b>
        ul
          li Si <b>reference bit</b>$=$1, se cambia a 0 y pasa a la siguiente página
          li Si <b>reference bit</b>$=$0, se elige esta página

      br
      br

      div Aproxima LRU bastante bien, y es eficiente

    div.fragment data-fragment-index="3" style="width:40%; vertical-align:middle; display:inline-block;"  

      img src='/images/figures/02-clock.png' width="100%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"


  section
    h3 Aproximando LRU

    div Enfoque de múltiples <b>reference bit</b>

    blockquote style="background:#B7E1CD;" Algoritmo de <b>aging</b>

    div.fragment data-fragment-index="1" style="width:50%; vertical-align:middle; display:inline-block;"  

      div Contadores por cada página
      ul
        li Contadores se actualizan por <i>hardware</i> a intervalos regulares
        li En cada <i>tick</i>, los <i>reference bit</i> se copian a cada contador (left shift), y se borran
        li Secuencia de bit sirve como historia
        li Página con menor contador es la menos usada

    div.fragment data-fragment-index="1" style="width:50%; vertical-align:middle; display:inline-block;"  

      img src='/images/figures/02-aging.png' width="100%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"

  section
    h3 Aproximando LRU

    div Usando los <b>dirty bit</b> (1 si la página ha sido modificada), se pueden priorizar mejor las páginas para el algoritmo del reloj.

    br
    br
    table
      tr
        td Reference
        td Dirty
        td
      tr
        td 0
        td 0
        td No usada recientemente ni modificada. Buena candidata.
      tr
        td 0
        td 1
        td No usada recientemente, pero modificada.
      tr
        td 1
        td 0
        td Usada recientemente, pero no modificada.
      tr
        td 1
        td 1
        td Usada recientemente y modificada.


/---------------------------------------------------------------------
section#reemp
  h2 Working Set y Thrashing

  section#reemp13


    div El modelo de <b>working set</b> intenta determinar si un proceso tiene una cantidad apropiada de <i>frames</i>

    blockquote.fragment data-fragment-index="1" style="background:#B7E1CD;" <b>Working Set</b>, $w_{\Delta}(t)$: conjunto de páginas utilizadas por un proceso en los últimos $\Delta$ acceso a memoria.

    div.fragment data-fragment-index="1"
      img src='/images/figures/02-9_20.pdf.png' style="background:none; border:none; box-shadow:none;" width="60%"

    ul.fragment data-fragment-index="2"
      li Medida de la demanda efectiva por <i>frames</i> de un proceso.
      li Si no se le puede asignar $|w_{\Delta}(t)|$ <i>frames</i> no conviene tenerlo en ejecución
      li Si la suma de los <i>working set</i> de todos los procesos es mayor a la cantidad de <i>frames</i> en el sistema, habrá <i>thrashing</i>

    div.fragment data-fragment-index="3" El <i>working set</i> es usado por el <i>medium-term scheduler</i>. /

    ul.fragment data-fragment-index="3"
      li Se puede implementar usando los <b>reference bit</b>




