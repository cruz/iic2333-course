---
title: 0 - Caracterización de Sistemas Operativos
layout: slide
---



section

    h2 ¿Para qué un Sistema Operativo?

    section 
    	div ¿Qué ocurre al ejecutar un programa (compilado)?

		div == image_tag '/images/figures/00-basic-ic.jpg', :width=>"35%"

    	div ¿Hacemos esto manualmente?

    section
    	div El computador es una máquina programable (léase "reconfigurable")

		div 
			img src='/images/figures/00-arqui.png' width="50%" style="background:none; border:none; box-shadow:none;"

		div ¿Quién controla qué programa se ejecuta?
		div ¿Quién controla cuando se lee I/O?

	section
		div Para ejecutar un código, necesitamos traducirlo al set de instrucciones del computador:

		div
			img src='/images/figures/00-main.png' width="20%" style="background:none; border:none; box-shadow:none;" &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
			img src='/images/figures/00-compiled.png' width="20%" style="background:none; border:none; box-shadow:none;"

		div.fragment Pero antes debemos configurar el computador para que lo ejecute:

		div.fragment
			img src='/images/figures/00-ThompsonRitchie.jpg' width="20%" style="background:none; border:none; box-shadow:none;"

		div.fragment Afortunadamente existe el <b>Sistema Operativo</b> &#x1f605;

section

	h2 Estructura de un Sistema Operativo

	section data-transition="fade"
		div ¿Dónde vive el Sistema Operativo?
		div.fragment == image_tag '/images/figures/00-os-location.jpg', :width=>"50%"

	section data-transition="fade"
		div Sistema Operativo <b>es</b> <i>software</i>
		div == image_tag '/images/figures/00-os-location.jpg', :width=>"50%"

	section data-transition="fade"
		div Sistema Operativo <b>habla con</b> el <i>hardware</i>
		div == image_tag '/images/figures/00-os-location.jpg', :width=>"50%"
		div.fragment ¿Qué pasaría si no hubiese sistema operativo? ... <span class="fragment">Antes no había</span>

	section data-transition="fade"
		div ¿Interactuamos con el Sistema Operativo?
		div == image_tag '/images/figures/00-os-location.jpg', :width=>"50%"
		div.fragment Normalmente interactuamos con <b>interfaces de usuario</b>: <span class="fragment"><b>shell</b>, <b>GUI</b></span>

	section data-transition="fade"
		div ¿User mode?, ¿kernel mode?
		div == image_tag '/images/figures/00-os-location.jpg', :width=>"50%"
		div.fragment Solo el Sistema Operativo utiliza el <i>kernel mode</i> ... <span class="fragment"><i>(a.k.a. monitor, privileged, system, supervised)</i></span>
		

section
	h2 ¿Qué es un Sistema Operativo?
	/  -------------------------------

	section
		p.fragment <i>Software</i> ... <span class="fragment">que corre en <i>kernel mode</i></span>
		p.fragment No hace mucho por sí mismo (es como el gobierno) ... <span class="fragment"> pero es fundamental</span>
		p.fragment Sería inútil sin programas/aplicaciones/usuarios (personas)

		blockquote.fragment style="background: #F4C7C3;" Sistema Operativo nos permiten <b>usar efectivamente</b> el computador

	section
		h3 ¿Qué hace el sistema operativo?
		ul
			li.fragment data-fragment-index="1" Para el usuario:
			blockquote.fragment data-fragment-index="3" style="background: #F4C7C3;" Permite <strong>utilizar los recursos</strong> del computador (el <i>hardware</i>)
			<span class="fragment" data-fragment-index="4">Ejecutar programas, leer archivos, efectuar cálculos ... de manera limpia, fácil y rápida</span>
			br
			br
			li.fragment data-fragment-index="2" Para el sistema computacional:
			blockquote.fragment data-fragment-index="5" style="background: #F4C7C3;" Permite <b>administrar los recursos</b>
			<span class="fragment" data-fragment-index="6">Permite <b>multiplexar</b> el uso de los recursos (escasos) entre múltiples programas.</span>
			ul
				li.fragment Multiplexión en tiempo: turnos. Ejemplo: uso de CPU(s), uso de impresora
				li.fragment Multiplexión en espacio: división del recurso. Ejemplo: procesos cargados en memoria, programas almacenados en disco
			blockquote.fragment data-fragment-index="9" style="background: #F4C7C3;" Sistema Operativo <b>virtualiza los recursos</b>: CPU, memoria, disco

section
	h2 Evolución de los Sistemas Operativos

	section

		p Érase una vez ...

		div.fragment style="display:inline-block; width=50px"
			div Charles Babbage (1791-1871)
			div
				img src='/images/figures/00-babbage.jpg' width="20%"  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
				img src='/images/figures/00-babbage-analytical.jpg' width="25%" 
		div.fragment style="display:inline-block; width=50px"
			div  and the Analytical Engine  

		div.fragment Primer diseño de <i>computador digital</i> ... <span class="fragment">aunque nunca lo terminó</span>

	section 
		
		div style="display:inline-block; width=50px"
			div Ada Lovelace (1815-1852)
			div
				img src='/images/figures/00-AdaLovelace.jpg' width="20%" &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
				img src='/images/figures/00-AdaLovelace-algorithm.jpg' width="40%" 
		div.fragment style="display:inline-block; width=50px"
			div style="display:inline-block;" and the First Algorithm

		div.fragment La primera programadora... <span class="fragment">su programa calculaba los números de Bernoulli usando la Analytical Engine</span>


	section
		h3 1ra Generación (1945-55): Tubos de vacío

		p Colossus Mark 2 @ Bletchley Park (incluyendo a Alan Turing)
		div
			img src='/images/figures/00-colossus.jpg' width="60%"

		div Primeros computadores digitales <b>electrónicos</b> ... programables, pero no de propósito general (no Turing-complete)


	section data-transition="fade"
		h3 Primera Generación (1945-55): Tubos de vacío

		p ENIAC @ U.Pennsylvania
		div
			img src='/images/figures/00-ENIAC.jpg' width="40%"

		div Primeros computadores programables de <i>propósito general</i>


	section data-transition="fade"

		h3 Primera Generación (1945-55): Tubos de vacío
		
		div
			img src='/images/figures/00-eniac-programming.jpg' width="40%"

		ul
			li Programación via conexión de cables (y luego, tarjetas perforadas)
			li No existían los lenguajes de programación (ni siquiera assembler)
			li Aprox. 20000 tubos de vacío

	section 
		h3 Segunda Generación (1955-65): Transistores y Sistemas <i>Batch</i>

		p Separación de roles: diseñador, constructor, programador, operador, mantenedor

		p <b>Mainframes</b>

		div
			img src='/images/figures/00-ibm1401.jpg' width="35%"

		p IBM1402 (card reader), IBM1401 (processing), IBM1403 (printer)


	section data-transition="fade"
		/h3 Segunda Generación (1955-65): Transistores y Sistemas <i>Batch</i>

		p Modo de operación: ejecución de un <b>job</b>
		ul
			li Programador escribe en FORTRAN (tarjetas perforadas) y entrega a operador
			li IBM1401 pasa tarjetas a cinta (operador lleva cinta a IBM7094)
			li IBM7094 procesa cinta (operador lleva cinta a IBM1403)
			li IBM1403 imprime resultados

		div
			img src='/images/figures/00-ibm7094.jpg' width="30%"
		p IBM7094

	section data-transition="fade"
		/h3 Segunda Generación (1955-65): Transistores y Sistemas <i>Batch</i>
		div
			img src='/images/figures/00-batch-manual.png' width="60%"

		p Proceso de <i>trabajo por lotes</i>, <b>batch</b>
		ul
			li Lenguajes: assembler y FORTRAN (primer lenguaje de programación)
			li Sistema Operativo: FMS (Fortran Monitor System)
			li Sistema Operativo: IBSYS (para el IBM7094)


	section
		h3 3ra Generación (1965-1980): Circuitos Integrados y Multiprogramación

		p IBM unifica sus <i>mainframes</i> en System/360. Misma arquitectura e <i>instruction set</i>.

		blockquote style="background: #B7E1CD;" Primeros en utilizar <b>circuitos integrados</b>

		div
			img src='/images/figures/00-ibms360.jpg' width="40%"


	section data-transition="fade"
		h3 Tercera Generación (1965-1980): Circuitos Integrados y Multiprogramación

		p Si el <i>hardware</i> está unificado, ¿por qué no el <i>software</i>?

		p.fragment <b>OS/360</b> (Fred Brooks)

		p.fragment Mientras se procesa I/O, la CPU no realizaba trabajo

		blockquote.fragment style="background: #B7E1CD;" OS/360 introduce la <b>multiprogramación</b>

		ul
			li.fragment Particionamiento de la memoria
			li.fragment Si un proceso no está ocupando la CPU, se entrega a otro

		p.fragment Posibilidad de cargar un programa de tarjeta a memoria en el momento que un espacio queda libre

		blockquote.fragment style="background: #B7E1CD;" Simultaneous Peripheral Operation On Line <b>SPOOLing</b>



	section data-transition="fade"
		h3 Tercera Generación (1965-1980): Circuitos Integrados y Multiprogramación

		p Usuarios aún deben esperar horas para obtener un resultado. ¿Y si hay error de compilación?

		p.fragment <b>Solución</b>: que múltiples usuarios puedan utilizar el computador simultáneamente

		blockquote.fragment style="background: #B7E1CD;" <b>Timesharing</b>

		p.fragment Cada usuario posee un terminal para entregar comandos al computador.

		ul.fragment
			li <b>CTSS</b> (<i>Compatible Time Sharing System</i>), MIT.
			li Primer sistema de <i>timesharing</i> de propósito general.
			li <b>Problema</b>: usuarios deben tener cuidado de no alterar el trabajo de otros

	section data-transition="fade"
		h3 Tercera Generación (1965-1980): Circuitos Integrados y Multiprogramación

		p MIT, Bell Labs, General Electric, deciden crear un sistema que soporte cientos de usuarios, inspirados en el modelo de la red eléctrica.

		ul.fragment
			li <b>MULTICS</b> (<b>MULT</b>iplexed <b>I</b>nformation and <b>C</b>omputing <b>S</b>ervice)
			li Escrito en lenguaje <b>PL/I</b> (poco popular y con un compilador deficiente)
			li Bell Labs y General Electric abandonan

		p.fragment <b>Visión de MULTICS</b>: sistema de computación que pueda ser accedido por múltiples usuarios, en que el <i>mainframe</i> ejecuta todo, y usuarios acceden a través de terminales "livianos"


	section data-transition="fade"
		h3 Tercera Generación (1965-1980): Circuitos Integrados y Multiprogramación

		p <b>DEC</b> (<i>Digital Equipment Corporation</i>) produce su serie de minicomputadores, desde <b>PDP-1</b> al <b>PDP-11</b>

		p.fragment <i>1970</i>. Ken Thompson y Dennis Ritchie escriben una versión reducida de MULTICS para un PDP-7 abandonado.

		blockquote.fragment style="background: #F4C7C3;" Al ser un MULTICS reducido, lo llaman UNICS, y finalmente <b>UNIX</b>

		ul.fragment
			li <i>1972</i>. Dennis Ritchie reescribe el código de Unix en <b>C</b>
			li Surgen muchas versiones (incompatibles entre sí), pero dos sobreviven
			ul
				li <b>System V</b>, de AT&T
				li <b>BSD</b> (Berkeley Software Distribution) de U.C.Berkeley.
			li IEEE desarrolla una interfaz estándar: <b>POSIX</b>
			li <i>1987</i>. Andrew Tanenbaum desarrolla una versión simplificada con objetivos educacionales: <b>MINIX</b>
			li <i>1991</i>. Linus Torvalds, inspirado en MINIX, escribe su propia versión: <b>LINUX</b>



	section 
		h3 Cuarta Generación (1980-): Computadores Personales

		p LSI (Large Scale Integration) posibilita la construcción de miles de transistores en 1cm2. 
		
		blockquote.fragment style="background: #B7E1CD;" Surgen los computadores personales, o <b>microcomputadores</b>
		ul
			li.fragment <i>1974</i>. <b>Intel 8080</b>. Primera CPU de propósito general de 8-bit. <b>No tiene sistema operativo</b>.
			li.fragment Gary Kildall, consultor, escribe <b>CP/M</b> (<i>Control Program for Microcomputers</i>) en un diskette de 8''.
			li.fragment Intel no se interesa, y entrega CP/M de vuelta a Gary Kildall.
			li.fragment <i>1977</i>. Gary Kildall funda <b>Digital Research</b> y adapta CP/M para otras CPU.
			li.fragment <i>1980</i>. IBM crea el <b>IBM PC</b>. Para probarlo obtienen un intérprete BASIC de ... <span class="fragment"><b>Bill Gates</b></span>
			li.fragment IBM PC no tiene Sistema Operativo. Bill Gates sugiere que contacten a Gary Kildall
			li.fragment Kildall rechaza a IBM. IBM solicita un Sistema Operativo a Bill Gates.
			li.fragment Bill Gates compra <b>DOS</b> (<i>Disk Operating System</i>) a <b>Seattle Computer Products</b>, y lo ofrece a IBM.
			li.fragment Bill Gates contrata a Tim Paterson en su nueva compañía, <b>Microsoft</b>, y producen <b>MS-DOS</b>
			li.fragment MS-DOS se populariza al ser ofrecido a empresas de computación y no a usuarios.


	section data-transition="fade"
		h3 Cuarta Generación (1980-): Computadores Personales

		ul
			li <i>1983</i>. IBM lanza <b>IBM PC/AT</b>, con Intel 80286 y MS-DOS.
			li MS-DOS ampliamente usado con Intel 80386 y 80486.
			li Tanto CP/M como MS-DOS usaban una <b>shell</b> (línea de comandos) como interacción.

		br
		br

		div.fragment En 1960's, Doug Engelbart (1925-2013) inventa las <b>GUI</b> (<i>Graphical User Interface</i>) en el Stanford Research Institute, Menlo Park.

		br 

		ul.fragment
			li <i>1968</i>. <i>Mother of all demos</i>. Engelbart presenta <i>windows</i>, <i>hypertext</i>, <i>mouse</i>, ...
			li GUIs empiezan a ser usadas en XEROX PARC (Palo Alto Research Center)
			li Steve Jobs conoce la GUI en XEROX PARC y la incorpora su siguiente computador Apple: Macintosh

		br
		br

		div.fragment <b>GUI</b>s atraen a usuarios que no saben (ni les interesa) el funcionamiento del computador.


	section data-transition="fade" 
		h3 Cuarta Generación (1980-): Computadores Personales

		blockquote style="background: #B7E1CD;" Microsoft adopta GUIs: <b>Windows</b>

		ul.fragment
			li <i>1985-1995</i>. MS-DOS ejecuta Windows como una aplicación de usuario.
			li <i>1995</i>. <b>Windows 95</b> reemplaza a MS-DOS.
			li <b>Windows 95</b> y <b>Windows 98</b> aún mantienen código assembler Intel 16-bit.
			li Microsoft reescribe Windows completamente para 32-bit. <b>Windows New Technology</b>: <b>Windows NT</b>
			li <i>1999</i>. <b>Windows NT 4.0</b> y <b>Windows 2000</b> se posicionan en el ámbito corporativo.
			li <i>2000</i>. <b>Windows Me</b> termina con la línea de Windows 95/98.
			li <i>2001</i>. Windows 2000 evoluciona a <b>Windows XP</b>.
			li Línea server: Windows 2003 Server, Windows 2008.
			li Línea client: Windows Vista, Windows 7, Windows 8, Windows 10.

	section data-transition="fade" 
		h3 Cuarta Generación (1980-): Computadores Personales

		blockquote style="background: #B7E1CD;"  Evolución de <b>UNIX</b>

		ul.fragment
			li <b>UNIX</b> popular en ambiente de servidores. 
			li <b>Linux</b> crece en computadores personales.
			li <i>1993</i>. <b>FreeBSD</b> deriva de BSD. <b>OSX</b> es una versión modificada de FreeBSD.
			li MIT produce un sistema de ventanas para UNIX: <b>X Windows System</b> (luego X11, Xorg).
			li UNIX adopta GUIs que funcionan sobre X11 (Gnome, KDE, XFCE, etc)
			

	section 
		h3 Quinta Generación (1980-): Computadores Móviles

		blockquote style="background: #B7E1CD;" Evolución de dispositivos móviles

		ul.fragment
			li <i>1946</i>. Primer teléfono móvil. 40 kg.
			li <i>1970</i>. Teléfono móvil de 1 kg. (ladrillo)
			li <i>1990s</i>. Nokia N9000 combina teléfono con PDA (Personal Digital Assistant)
			li Primeros sistemas operativos para móviles: SymbianOS
			li <i>2002</i>. RIM. Blackberry OS
			li <i>2007</i>. Apple. iOS.
			li <i>2008</i>. Google. Android. Basado en Linux.
			li <i>2011</i>. Nokia cambia SymbianOS por Windows Phone.


section
	h2 ¿De qué tamaño es un Sistema Oprerativo?
	/  -----------------------------

	section
		p.fragment <a href="http://www.informationisbeautiful.net/visualizations/million-lines-of-code">(¿Megas? ¿Kilos? ¿Gigas?)</a>
		ul
			li.fragment Windows 7: \( \sim 40\times 10^6 \) líneas de código
			li.fragment Linux: \( \sim 15 \times 10^6 \) líneas de código
		

	section
		h3 ¿Qué incluye?
		ul
			li Sistema Operativo

			blockquote.fragment style="background: #B7E1CD;" Sistema Operativo = Kernel + Programas del Sistema

			li Kernel

			blockquote.fragment style="background: #B7E1CD;" Un programa que <b>siempre</b> se está ejecutando. Provee funcionalidad mínima: acceso a CPU, memoria, dispositivos.
			
			li Programas del sistema

			blockquote.fragment style="background: #B7E1CD;" Extienden las funciones del kernel.





section
	h2 Tareas del Sistema Operativo

	blockquote.fragment style="background: #F4C7C3;" <b>Administración de procesos</b>
	ul.fragment
		li Proceso
		li Tablas (árbol) de proceso
		li Comunicación entre procesos

	blockquote.fragment style="background: #F4C7C3;" <b>Administración de memoria</b>
	ul.fragment
		li Espacios de direcciones
		li Memoria Virtual


	blockquote.fragment style="background: #F4C7C3;" <b>Administración de almacenamiento</b>
	ul.fragment
		li Archivos
		li Directorios
		li Rutas absolutas y relativas



section
	h2 ¿Cómo funciona el Sistema Operativo?
	
	p El Sistema Operativo está siempre en ejecución <span class="fragment">¿y el usuario?</span>

	blockquote.fragment style="background: #F4C7C3;" Los Sistemas Operativos son manejados por <b>interrupciones</b> / <b>traps</b>.

	p.fragment Mientras nadie (usuario/programa) lo llame, el Sistema Operativo no hace nada.
	ul.fragment
		li <em>Trap</em>: interrupción generada por software
		
		li S.O. debe asegurar que errores en un programa no afecten a otro
		ul
			li ¿Qué pasa si un programa entra en un loop infinito?
			li ¿Si un programa trata de modificar memoria de otro programa? ¿o del S.O.?
			li Habría que asegurar que solo un proceso puede estar en modo ejecutable

		li Pero el S.O. sí debería poder modificar la memoria de otro programa, para cargarlo/descargarlo



section
	h2 Modos de operación de un Sistema Operativo
	
	section

		br

		div 
			img src="/images/figures/00-1_10.pdf.png" width="60%" style="background:none; border:none; box-shadow:none;"

		p Modo dual suportado por hardware: mode bit (0=kernel/1=user)

		p <b>Solo puede ser modificado por el S.O.</b> (¿por qué?)
		p Kernel mode, a.k.a. (<i>Privileged</i> | <i>Supervised</i> | <i>Monitor</i> | <i>System</i>) mode

		blockquote.fragment style="background: #F4C7C3;" Instrucciones privilegiadas solo pueden ejecutar en modo <b>kernel</b>. <br/> Si se intenta ejecutar en modo <b>user</b>, el <i>hardware</i> no la ejecuta y genera una interrupción para el Sistema Operativo.

		p.fragment Ej: cambio mode bit, llamada I/O, manejo timer, manejo de interrupciones


	/section
		/p Multi-modos: Más de dos modos de operación, ¿para qué?

		/ul
			/li.fragment Útil para virtualización
			/li.fragment VMM (<em>Virtual Machine Manager</em>) opera en modo intermedio
			/ul.fragment
				/li Menos privilegios que S.O.
				/li Más privilegios que cada <em>Virtual Machine</em>

		/.fragment
			/== image_tag "images/figures/00-1_20.pdf.png", :width=>"40%"


	/section
		/p Programas de usuario hacen llamadas al S.O para que ejecute acciones a nombre de ellos

		/ul
			/li.fragment <em>syscall</em>, <em>trap</em>

		/br
		/br
		/p.fragment ¿Qué puede pasar si no hay bit mode? (Intel 8088 no lo tenía)
		/ caso de 8088 y MS-DOS. Un proceso en MS-DOS podía echarse el SO

		/ul
			/li.fragment Mode bit permite protección de hardware
			/li.fragment Si un programa comete un acceso indebido o error, trap al S.O.
			/ul
			/	li.fragment S.O. termina el programa <em>abnormally</em>

			/li.fragment ¿Cómo evitar que un programa no devuelva el control al SO?
			/ul
			/	li.fragment S.O. usa un timer que genera un trap a intervalo definido
			/	li.fragment Timer también debe ser establecido en modo Kernel






section
	h2 Llamadas al sistema
	/  -------------------

	section
		h4 System Calls
		p Programas utilizan llamadas al sistemas frecuentemente
		p Ej: <code>copy source.txt dest.txt</code>... ¿qué requiere?

		ul
			div.fragment
				li Abrir <code>source.txt</code>
				ul
					li ¿Existe? ¿Tiene permisos?

			div.fragment
				li Abrir <code>dest.txt</code>
				ul
					li ¿Existe? ¿se reemplaza? ¿Se puede escribir?

			li.fragment Lectura/escritura en disco requiere llamadas al sistema
			li.fragment Terminar el programa en caso de error, requiere llamadas al sistema

		/p.fragment ...pero el programador no quiere programar todas las llamadas


	section
		h4 API: Application Programming Interface

		p Sistemas Operativos proveen una API para el programador.
		ul
			li.fragment Windows API
			li.fragment POSIX API (UNIX, Linux, MacOS X), a través de <span style="font-family:'Lucida Console', monospace">libc</span>
			li.fragment Java API (para la JVM)

		br
		p.fragment ¿Cómo usarla?
		div.fragment
			p eg:
			pre style="width:50%;"
				code.hljs
					| count = read(fd, buffer, nbytes);

	section
		= image_tag "/images/figures/00-2_06.pdf.png", :style => 'max-width:60%; max-height:60%'

	section
		= image_tag "/images/figures/00-syscall-read.png", :style => 'max-width:60%; max-height:60%'


	section
		= image_tag "/images/figures/00-syscalls-posix.png", :style => 'max-width:50%; max-height:50%'

	section
		= image_tag "/images/figures/00-syscalls-posix-win32.png", :style => 'max-width:50%; max-height:50%'


section
	h2 Elementos y Servicios de un Sistema Operativo
	/  ---------------------------------------------

	section
		p At a glance...

		= image_tag '/images/figures/00-2_01.pdf.png', :width => "80%"



section
	h2 Interfaces de Usuario (UI)
	/  --------------------------

	section
		p Varias alternativas...
		ul
			li.fragment <em>Command-Line Inteface (CLI):</em> Comandos se ingresan por teclado
			li.fragment <em>Batch interface:</em> Comandos se ingresan en archivos
			li.fragment <em>Graphical User Interface (GUI):</em> Sistema de ventanas + <em>pointing-device</em>

	section
		h4 Command-Line (línea de comandos) <span class="fragment">(<strong>shells</strong>)</span>

		p.fragment Para UNIX
		div.fragment
			ul
				li <em>Bourne shell</em>: Stephen Bourne, 1977, UNIX, <code>sh</code>
				li <em>C shell</em>: Bill Joy, 1978, BSD UNIX, <code>csh</code>
				li <em>TENEX C Shell</em>: Ken Greer, 1983, <code>tcsh</code>
				li <em>Korn shell</em>: David Korn, 1983, <code>ksh</code>
				li <em>Bourne-Again shell</em>: Brian Fox, 1989, <code>bash</code>
				li <em>Z shell</em>: Paul Fastad, 1990, <code>zsh</code>

		p.fragment En windows
		div.fragment
			ul
				li <em>MS-DOS prompt</em>: MS-DOS, Win95/98/Me, <code>COMMAND.COM</code>
				li <em>Command Prompt</em>: <code>cmd.exe</code>
				li <em>PowerShell</em>


	section
		h4 Command-Line (línea de comandos)

		p Uso común:
		ul
			li Solicitar comando/instrucción al usuario y ejecutarlo
			li Formato: <code>prompt comando [parametros]</code>

		div.fragment
			p <em>Command Prompt</em> (símbolo del sistema)
			ul
				li.fragment Indica que el sistema está lista para recibir un comando
				li.fragment Usualmente un texto terminado en <code>$, %, #, :, ></code>

		div.fragment
			pre
				code.hljs
					| cruz$ ls
					 
					 jabaier@grima$ cp clase-01.tex backup/
					 
					 jnavon@www[15:35]:> rm tareaSistOp.*
					 
					 dietr1ch@nb ~/SO/Tareas 
					 ls -d */ | parallel --tag 'cd {} && make'


	section
		h4 Graphical User Interface (GUI)

		p Interfaz gráfica (para quienes no les gusta escribir comandos)
		div.fragment
			ul
				li Usualmente con un <em>pointing-device</em> y ventanas
				li Métaforas: escritorio, íconos, carpetas, menúes
				li Más allá de <em>pointing-device</em>: gestos y acciones visuales

		p.fragment Vienen de los \(\sim\) 1970's
		div.fragment
			ul
				li Investigación de Xerox Palo Alto Research Center (PARC)
				li Primera interfaz gráfica: 1973
				li Popularizados en 1980s: Apple Macintosh (Mac OS)
				li Windows 1.0 agregó GUI a MS-DOS


	section
		h4 Graphical User Interface (GUI)

		p Tradicionalmente UNIX/Linux han sido manejados por CLI,
		p.fragment pero se han desarrollado muchas GUIs

		ul
			li.fragment CDE (<em>Common Desktop Environment</em>): Unix, OpenVMS
			li.fragment X-Windows Systems: Xfce, KDE, GNOME (Unix/Linux)
			li.fragment <a href="https://wayland.freedesktop.org/">Wayland</a>: Nueva API de GUI (Linux)

		= image_tag "/images/figures/00-Xwindows.png", :style => "max-width:50%;float:right;"


	section
		= image_tag "/images/figures/00-CDE.png", :style => 'max-width:50%; max-height:50%'
		p CDE (Common Desktop Environment)


	section
		= image_tag "/images/figures/00-XFCE.png", :style => 'max-width:50%; max-height:50%'
		p Xfce


	section
		= image_tag "/images/figures/00-GNOME.png", :style => 'max-width:50%; max-height:50%'
		p GNOME


	section
		= image_tag "/images/figures/00-KDE.png", :style => 'max-width:50%; max-height:50%'
		p KDE (K Desktop Environment)








section
	h2 Estructura: MS-DOS
	/  ------------------

	section
		p ¿Sistemas <strong>monolíticos</strong> o sistemas <strong>modulares</strong>?
		p.fragment Algunos ni siquiera tienen estructura
		ul
			li.fragment MS-DOS: sistema monolítico simple
			li.fragment Nadie pensó que sería tan popular
			li.fragment Intel 8088 no tenía protección de <em>dual mode</em>
			li.fragment ¿Problemas? <span class="fragment">Seguridad</span>

		br
		= image_tag "/images/figures/00-2_11.pdf.png", :style=>"float;right;", :height=>"25%", :width=>"25%"



section
	h2 Estructura: UNIX
	/  ----------------

	section
		p UNIX: Estructura monolítica diseñada de acuerdo al <em>hardware</em>

		= image_tag "/images/figures/00-2_12.pdf.png", :width => '50%'

		p.fragment ¿Problemas? <span class="fragment">Dificultad de mantenimiento</span>



section
	h2 Estructura: diseño por capas
	/  ----------------------------

	section
		p Capas se diseñan por niveles más <em>abstractos</em> de funcionalidad

		ul
			li          Capa \(M\) invoca llamadas sobre capa \(M-1\)
			li.fragment Ventaja: Facilidad de <em>debugging</em>
			li.fragment Desventaja: dificultad de definición de capas, eficiencia


		= image_tag "/images/figures/00-2_13.pdf.png", :width => '25%'


		p.fragment THE (Technische Hogeschool Eindhoven), E. W. Dijkstra (1968) y estudiantes. 6 capas.


section
	h2 Estructura: <em>microkernels</em>
	/  ---------------------------------

	section
		p <b>Mach</b>: versión de UNIX usando diseño de <em>microkernel</em> (CMU)

		ul
			li.fragment Set de funcionalidades mínimas
			li.fragment Otras funcionalidades agregadas como programas de usuario ¿dónde poner el límite?
			li.fragment Ventaja: Sistemas pequeño y fácil de portar
			li.fragment Desventaja: Mucha más interacción a través de <em>syscalls</em>!
			li.fragment <b>Darwin</b> (MacOS X kernel) basado parcialmente en modelo Mach
			li.fragment <b>Windows NT</b> usaba microkernel pero era más lento que Win95.
			li.fragment <b>GNU/Hurd</b> es más lento que Linux.

		= image_tag "/images/figures/00-2_14.pdf.png", :width=>'50%'


section
	h2 Estructura: <i>Monolíticos</i> vs <i>microkernels</i>
	/  ---------------------------------

	section

		= image_tag "/images/figures/00-mono-micro.png", :width=>'100%'



section
	h2 Estructura: <em>módulos</em>
	/  ----------------------------

	section
		p Lo más común: <strong>loadable kernel modules</strong>

		ul
			li Kernel tiene un conjunto de componentes principales (<em>core</em>)
			li Módulos necesarios se agregan durante ejecución
			li Evita recompilar el kernel para cada nueva funcionalidad
			li Solaris, Linux, MacOS X, Windows
			li Ej: kernel con soporte de manejo de archivo + módulos por cada <em>filesystem</em>

		= image_tag "/images/figures/00-2_15.pdf.png", :width=>'50%'



section
	h2 Al final: Estructuras híbridas
	/  ------------------------------

	section
		p En la práctica, pocos sistemas pueden ser encasillados

		ul
			li Linux, Solaris, Windows tienen características monolíticas (performance!)
			li Pero algunas funcionalidades siguen el diseño de <em>microkernel</em>
			li ¡Y además permiten cargar módulos dinámicamente!




