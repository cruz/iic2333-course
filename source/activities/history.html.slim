---
title: Evolución de los sistemas operativos
layout: activity
---

article
  section.top
    p Usar un computador no siempre fue tan fácil. Las primeras máquinas que siguieron el concepto de una <i>máquina programable (reconfigurable) de propósito general</i> poseían características físicas muy particulares, y nada estándar, por lo que es muy natural que cualquier <i>software</i> estuviera íntimamente ligado a la construcción de la máquina.

    p Este artículo describe algunos hitos en la evolución del <i>software</i> que conocemos como <b>sistema operativo</b> y destaca el surgimiento de conceptos que persisten en los sistemas operativos modernos.


  section
    h3 Prehistoria de sistema operativos
    /  --------
    div La primera máquina a la que se puede llamar un <i>computador digital de propósito general</i> fue diseñada por el matemático inglés <a href="https://en.wikipedia.org/wiki/Charles_Babbage">Charles Babbage (1791-1871)</a>, quien diseñó una máquina mecánica <a href=#" title="Digital&colon; capaz de trabajar con dígitos">digital</a>, conocida como la <a href =""https://en.wikipedia.org/wiki/Analytical_Engine"><i>analytical engine</i></a>, o <i>máquina de Babbage</i>. Si bien desarrolló todos los planos, nunca pudo terminar de construirla.
    br

    div style="display:inline-block; width=50px; vertical-align:middle; border:none; text-align:center;"
      div 
        img src='/images/figures/00-babbage.jpg' width="20%"  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
        img src='/images/figures/00-babbage-analytical.jpg' width="25%" 
      div style="font-size:14px; border:none;" <i>Charles Babbage (1791-1871) and the Analytical Engine</i>. Esta reconstrucción fue hecha a partir de los diseños de Babbage.
    br
    br

    div La máquina de Babbage, sin embargo, no tenía ningún tipo de <i>software</i>. La máquina podía ser &quot;programada&quot; (un concepto nuevo para la época) mediante tarjetas perforadas, método que ya se usaba en la máquinas de la industria textil. <a href="https://en.wikipedia.org/wiki/Ada_Lovelace">Ada Lovelace</a>, matemática, escribió un conjunto de notas que describían un procedimiento para calcular una secuencia de números de Bernoulli usando la máquina de Babbage. Se considera este documento como el primer programa desarrollado para una máquina computacional, y a Ada Lovelace como <i>la primera programadora</i>. El <a href="http://www.adaic.org/">lenguaje de programación Ada</a> fue nombrado en su honor.
    br

    div style="display:inline-block; width=50px; vertical-align:middle; border:none; text-align:center;"
      div
        img src='/images/figures/00-AdaLovelace.jpg' width="20%" &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
        img src='/images/figures/00-AdaLovelace-algorithm.jpg' width="40%" 
      div style="font-size:14px; border:none;" <i>Ada Lovelace (1815-1852) and the First Algorithm. Ada falleció a los 36 años de cáncer uterino.</i>
    br
    br

  section
    h3 Primera Generación (1945-55): Tubos de vacío

    p Posteriormente al trabajo de Babbage, el desarrollo de máquinas programables quedó relegado al ámbito de la investigación científica, sin grandes aplicaciones prácticas. Como ha ocurrido con tantos otros inventos, fue el periodo de la Segunda Guerra Mundial el que vino a reimpulsar el interés en este tipo de máquinas.

    p Se empezaron a desarrollar las primeras máquinas electrónicas, como la máquina de <a href="https://en.wikipedia.org/wiki/Atanasoff%E2%80%93Berry_computer">Atanasoff-Berry</a> (1942), y el <a href="https://en.wikipedia.org/wiki/Z3_(computer)">Z3</a> de Konrad Zuse (1941). El flujo de cómputo de estas máquinas era controlado por <i>switch electrónicos</i> (<i>relay</i>), construidos mediante <i>tubos de vacío</i> (<i>vacuum tube</i>). Algunas de estas máquinas eran programables, si bien no todas eran de &quot;propósito general&quot; ó <a href="https://en.wikipedia.org/wiki/Turing_completeness"><i>Turing-complete</i></a>.

    p En 1944, un grupo de científicos en Bletchley Park, Inglaterra, entre los que se encontraba Alan Turing, construyó el computador <a href="https://en.wikipedia.org/wiki/Colossus_computer">Colossus</a>, cuyo modelo más conocido, el Colossus Mark 2, utilizaba 2400 tubos de vacío. Este computador, si bien, tampoco era <i>Turing-complete</i> (lo que demuestra que no basta tener a Alan Turing para ser <i>Turing-complete</i>) ya que fue diseñado para una tarea criptográfica particular, sí era programable mediante cintas de papel. Fue importante en el proceso de decriptación del criptosistema alemán Lorenz.

    div style="display:inline-block; width=50px; vertical-align:middle; border:none; text-align:center;"
      div
        img src='/images/figures/00-colossus.jpg' width="60%" 
      div style="font-size:14px; border:none;" <i>Colossus Mark 2 @ Bletchley Park. Reconstrucción.</i>
    br
    br

    p En 1946, William Mauchley y J. Presper Eckert construyeron, en la Universidad de Pennsylvania uno de los primeros computadores programables de propósito general: el <a href="https://en.wikipedia.org/wiki/ENIAC">ENIAC</a> (<i>Electronic Numerical Integrator and Computer</i>), Poseía 20000 tubos de vacío, pesaba 27 toneladas, ocupaba 167m<sup>2</sup> y consumía 150kW de electricidad. Su dispositivo de entrada era un lector de tarjetas perforadas y su salida era un perforador de tarjetas (IBM 405). Poseía un <i>clock</i> de 100kHz, y utilizaba 20 registros de 10 dígitos binarios. No existía un lenguaje de programación, ni siquiera <i>assembler</i>, de manera que toda la computación era descrita en las tarjetas perforadas mediante código de máquina.

    p 
    div style="display:inline-block; width=50px; vertical-align:middle; border:none; text-align:center;"
      div
        img src='/images/figures/00-ENIAC.jpg' width="40%" 
      div style="font-size:14px; border:none;" <i>ENIAC (fragmento) @ School of Engineering and Applied Science, University of Pennsylvania.</i>
    br
    br



  /section data-transition="fade"

    h3 Primera Generación (1945-55): Tubos de vacío
    
    div
      img src='/images/figures/00-eniac-programming.jpg' width="40%"

    ul
      li Programación via conexión de cables (y luego, tarjetas perforadas)
      li No existían los lenguajes de programación (ni siquiera assembler)
      li Aprox. 20000 tubos de vacío









    section
      h5 VM
      /  --------
      p Si ya usan Linux vayan a la sección de <a href="#programas">programas</a>.
      p Si no usan Linux, les recomendamos usar una VM, ya que no requiere particionar su disco.
      p Mientras descargan e instalan pueden comenzar a leer en paralelo la sección de <a href="#git" target="blank">git</a>.
      ul style="-webkit-columns:2; -moz-columns:2; columns:2;  list-style-position: inside;"
        li
          strong = link_to 'VirtualBox (Gratis)', 'https://www.virtualbox.org/wiki/Downloads'
        li = link_to 'VMWare', 'http://www.vmware.com/'
        li = link_to 'Parallels', 'http://www.parallels.com/'
      p En algunos computadores la virtualización debe ser habilitada desde la BIOS.
      p Existen muchas distribuciones de Linux. Todas ofrecen el kernel de Linux y un package manager, el que permite instalar paquetes de software, los que tienen programas o librerías que se instalan de manera uniforme tanto en interfaz como dentro del sistema de archivos.

    ul style="-webkit-columns:2; -moz-columns:2; columns:2;  list-style-position: inside;"
      li = link_to 'Archlinux', 'https://www.archlinux.org/download'
      li
        strong = link_to 'Manjaro (Archlinux-based)',   'https://manjaro.github.io/download'
      li = link_to 'Debian',    'https://www.debian.org/distrib/netinst'
      li
        strong = link_to 'Ubuntu (Debian-based)',    'https://www.ubuntu.com/desktop'

    p Manjaro y Ubuntu ofrecen discos de instalación bastante amigables. Desde ahora en adelante asumiremos que usan Linux.

    section#programas
      h5 Programas
      /  --------
      p Los programas necesarios son:
      ul style="-webkit-columns:2; -moz-columns:2; columns:2;  list-style-position: inside;"
        li
          dl.iinlinenline
            dt
              dfn
                abbr title="GNU Compiler Collection" GCC
            dd Un compilador de C.
        li
          dl.inline
            dt
              dfn Qemu
            dd  Un emulador.
        li
          strong git
        li Un emulador de Terminal.
        li Una <strong>shell</strong>.
        li Un editor de texto.

  section
    h3 Ambiente
    /  --------
    p Durante el proyecto y las tareas van a pasar la mayoría del tiempo trabajando con una shell, por lo que es recomendable por lo que es recomendable que inviertan un poco de tiempo en acostumbrarse y hacerla más cómoda.
    section
      h5 Terminal
      /  --------

      p Los <a href="https://en.wikipedia.org/wiki/VT100">terminales</a> son máquinas para usar remotamente un servidor, básicamente una pantalla y un teclado conectado en red al servidor. Hoy ya no se usan máquinas especiales, sólo un programa que simula una, por lo que en la práctica son sólo un programa para interactuar con una shell.
      p No hay demasiado que aprender y arreglar acá, sólo pueden cambiar la fuente y el colorscheme, así que pueden saltar a la sección de <a href="#shell">Shells</a>.
      p Varios 'prompts' usan caracteres especiales que necesitan parchar las fuentes para agregarlos, el set más usual es el de powerline, y existen paquetes con versiones parchadas de las fuentes, así que si su prompt se ve mal tienen que instalar y usar una fuente adecuada.

      p Existen varios emuladores de terminal, por lo general los escritorios tienen uno preferido, pero pueden usar cualquiera.
      ul style="-webkit-columns:2; -moz-columns:2; columns:2;  list-style-position: inside;"
        li konsole / yakuake <small>(KDE [Qt])</small>
        li gnome-terminal / guake <small>(Gnome,Unity [GTK])</small>
        li terminology <small>(Enlightenment [EFL])</small>
        li terminator <small>([GTK])</small>
        li
          small urxvt
        li
          small xterm

      p Fonts
      ul style="-webkit-columns:2; -moz-columns:2; columns:2;  list-style-position: inside;"
        li = link_to 'powerline/fonts', 'https://github.com/powerline/fonts'
        li = link_to 'AUR: powerline-fonts-git', 'https://aur.archlinux.org/packages/powerline-fonts-git/'
      p ColorSchemes
      ul style="-webkit-columns:2; -moz-columns:2; columns:2;  list-style-position: inside;"
        li = link_to 'Solarized', 'http://ethanschoonover.com/solarized'
        li = link_to 'SMYCK', 'http://color.smyck.org/'
        li = link_to 'Terminal ColorScheme Designer', 'http://ciembor.github.io/4bit/'


    section#shell
      h5 Shell
      /  -----

      p Una shell es un intérprete de comandos (al igual que el REPL de ruby/python/js/haskell/), lo que tiene de especial es que está orientada a ejecutar otros programas.

      h6 ¿Cuál usar?
      p Existen varias,
      ul
        li bash (generalmente default)
        li zsh
        p Casi 100% compatible con bash. La configuración default es mala, pero existen algunos frameworks fáciles de usar para configurarla:
        ul
          li
            strong = link_to 'prezto', 'https://github.com/sorin-ionescu/prezto'
          li = link_to 'oh-my-zsh', 'https://github.com/robbyrussell/oh-my-zsh'
        li fish
        p Muy buena por default. Tiene sintáxis distinta a la de bash, lo que quita portabilidad a sus scripts, pero no es un problema. También existe un framework para instalar plugins y themes:
        ul
          li = link_to 'oh-my-fish', 'https://github.com/oh-my-fish/oh-my-fish'
        li tsh, csh, ksh, ...

      h6 Usando la shell
      p Existe una lista de directorios donde la shell puede descubrir programas, es conocida como <code>PATH</code>. Es posible extenderla para ejecutar programas desde directorios personales.

      p Ejecutar programas es simple, basta escribir el nombre del programa<small>, o la ruta completa si no están en el PATH</small>. Se le pueden entregar argumentos separados por espacios, todos son strings.
      p Por ejemplo, podemos llamar a 'telnet' y darle un string como argumento para conectarnos a algún servidor.
      pre
        code.hljs
          | telnet towel.blinkenlights.nl

      h6 Pipes
      pre
        code.hljs
          | echo "Mooo" | cowsay
      p Acá llamamos a 'echo' con 'Mooo' como argumento, el que ejecuta y pasa su output como input de 'cowsay' sin argumentos. Esto produce el siguiente output:
      pre
        code.hljs
          |   ______
             < Mooo >
              ------
                       \   ^__^
                        \  (oo)\_______
                           (__)\       )\/\
                               ||----w |
                               ||     ||
      p El operador pipe <code>|</code> toma el output del programa de la izquierda y se lo entrega como input al de la derecha, se puede usar siempre. La ejecución se hace en paralelo y los datos se intercambian en líneas completas. Hay que notar que algunos programas no pueden generar output antes de consumir todo el input (sort).
      p Pueden encadenarse varios programas,
      pre
        code.hljs
          | echo "Moooooooo" | cowsay | cowsay -n | cowsay -n

      p Más adelante se verán con más detalle, por ahora basta que sepan que sirven para componer programas.


    section
      h5 Editor
      /  ------
      p Existen varios editores de texto. Vim y Emacs son muy configurables, por lo que es cómodo comenzar con una base.
      ul
        li vim
        ul style="-webkit-columns:2; -moz-columns:2; columns:2;  list-style-position: inside;"
          li
            strong = link_to "vim spf13", "https://github.com/spf13/spf13-vim"
          li = link_to "haskell-vim-now", "https://github.com/begriffs/haskell-vim-now"
          li = link_to "Derek Wyatt's config", "https://github.com/derekwyatt/vim-config"
          li = link_to "Vundle (Plugin Manager, DIY config)", "https://github.com/VundleVim/Vundle.vim"
        li emacs
        ul style="-webkit-columns:2; -moz-columns:2; columns:2;  list-style-position: inside;"
          li
            strong = link_to "Spacemacs", "https://github.com/syl20bnr/spacemacs"
          li = link_to "Aaron Bedra's config", "http://aaronbedra.com/emacs.d/"
          li = link_to "Sacha Chua's config", "http://pages.sachachua.com/.emacs.d/Sacha.html"
        li kate/gedit
        li atom/sublime/notepad++
        li <small>(ed)</small>

      p Lo más importante es que les sea una herramienta útil y los haga eficientes en vez de ser un obstáculo. Vim y Emacs son superiores a la mayoría, pero hay que aprender a usarlos (comenzar es fácil, gastar 30 minutos y ser más lento al principio se paga).


    section#git
      h5 Git
      /  ---
      p Git es un sistema de control de versiones distribuido que se ha convertido en una herramienta esencial para cualquier proyecto serio.

      p Para aprender git existe mucho material en internet.
      ul
        li
          strong = link_to "Book", "https://git-scm.com/book/en/v2/Getting-Started-About-Version-Control"
        li = link_to "Docs", "https://git-scm.com/docs"
        li
          strong = link_to "Simple Guide", "http://rogerdudler.github.io/git-guide/"
        li = link_to "Git Immersion", "http://gitimmersion.com/"
        li
          strong = link_to "CodeSchool", "https://try.github.io/levels/1/challenges/1"
        li = link_to "SO practical guide", "http://stackoverflow.com/questions/315911/git-for-beginners-the-definitive-practical-guide"
        li = link_to "Git Cheatsheet", "http://ndpsoftware.com/git-cheatsheet.html"
        li = link_to "Explain git with D3 (tree management)", "http://onlywei.github.io/explain-git-with-d3"

  section 
    h2 Sources
      ul
        li Tanenbaum, "Modern Operating Systems", 4th Ed. Sección 1.2.

