---
title: Evolución de los sistemas operativos
layout: activity
---

article
  section.top
    p Usar un computador no siempre fue tan fácil. Las primeras máquinas que siguieron el concepto de una <i>máquina programable (reconfigurable) de propósito general</i> poseían características físicas muy particulares, y nada estándar, por lo que es muy natural que cualquier <i>software</i> estuviera íntimamente ligado a la construcción de la máquina.

    p Este artículo describe algunos hitos en la evolución del <i>software</i> que conocemos como <b>sistema operativo</b> y destaca el surgimiento de conceptos que persisten en los sistemas operativos modernos.


  section
    h3 Prehistoria de sistema operativos
    /  --------
    div La primera máquina a la que se puede llamar un <i>computador digital de propósito general</i> fue diseñada por el matemático inglés <a href="https://en.wikipedia.org/wiki/Charles_Babbage">Charles Babbage (1791-1871)</a>, quien diseñó una máquina mecánica <a href=#" title="Digital&colon; capaz de trabajar con dígitos">digital</a>, conocida como la <a href =""https://en.wikipedia.org/wiki/Analytical_Engine"><i>analytical engine</i></a>, o <i>máquina de Babbage</i>. Si bien desarrolló todos los planos, nunca pudo terminar de construirla.
    br

    div style="display:inline-block; width=50px; vertical-align:middle; border:none; text-align:center;"
      div 
        img src='/images/figures/00-babbage.jpg' width="20%"  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
        img src='/images/figures/00-babbage-analytical.jpg' width="25%" 
      div style="font-size:14px; border:none;" <i>Charles Babbage (1791-1871) and the Analytical Engine</i>. Esta reconstrucción fue hecha a partir de los diseños de Babbage.
    br
    br

    div La máquina de Babbage, sin embargo, no tenía ningún tipo de <i>software</i>. La máquina podía ser &quot;programada&quot; (un concepto nuevo para la época) mediante tarjetas perforadas, método que ya se usaba en la máquinas de la industria textil. <a href="https://en.wikipedia.org/wiki/Ada_Lovelace">Ada Lovelace</a>, matemática, escribió un conjunto de notas que describían un procedimiento para calcular una secuencia de números de Bernoulli usando la máquina de Babbage. Se considera este documento como el primer programa desarrollado para una máquina computacional, y a Ada Lovelace como <i>la primera programadora</i>. El <a href="http://www.adaic.org/">lenguaje de programación Ada</a> fue nombrado en su honor.
    br

    div style="display:inline-block; width=50px; vertical-align:middle; border:none; text-align:center;"
      div
        img src='/images/figures/00-AdaLovelace.jpg' width="20%" &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
        img src='/images/figures/00-AdaLovelace-algorithm.jpg' width="40%" 
      div style="font-size:14px; border:none;" <i>Ada Lovelace (1815-1852) and the First Algorithm. Ada falleció a los 36 años de cáncer uterino.</i>
    br
    br

  section
    h3 Primera Generación (1945-55): Tubos de vacío

    p Posteriormente al trabajo de Babbage, el desarrollo de máquinas programables quedó relegado al ámbito de la investigación científica, sin grandes aplicaciones prácticas. Como ha ocurrido con tantos otros inventos, fue el periodo de la Segunda Guerra Mundial el que vino a reimpulsar el interés en este tipo de máquinas.

    p Se empezaron a desarrollar las primeras máquinas electrónicas, como el <a href="https://en.wikipedia.org/wiki/Z3_(computer)">Z3</a> de Konrad Zuse (1941), y la máquina de <a href="https://en.wikipedia.org/wiki/Atanasoff%E2%80%93Berry_computer">Atanasoff-Berry</a> (1942). El flujo de cómputo de estas máquinas era controlado por <i>switch electrónicos</i> (<i>relay</i>), construidos mediante <i>tubos de vacío</i> (<i>vacuum tube</i>). Algunas de estas máquinas eran programables, si bien no todas eran de &quot;propósito general&quot; ó <a href="https://en.wikipedia.org/wiki/Turing_completeness"><i>Turing-complete</i></a>.

    p En 1944, un grupo de científicos en Bletchley Park, Inglaterra, entre los que se encontraba Alan Turing, construyó el computador <a href="https://en.wikipedia.org/wiki/Colossus_computer">Colossus</a>, cuyo modelo más conocido, el Colossus Mark 2, utilizaba 2400 tubos de vacío. Este computador, si bien, tampoco era <i>Turing-complete</i> (lo que demuestra que no basta tener a Alan Turing para ser <i>Turing-complete</i>) ya que fue diseñado para una tarea criptográfica particular, sí era programable mediante cintas de papel. Fue importante en el proceso de decriptación del criptosistema alemán Lorenz.

    div style="display:inline-block; width=50px; vertical-align:middle; border:none; text-align:center;"
      div
        img src='/images/figures/00-colossus.jpg' width="60%" 
      div style="font-size:14px; border:none;" <i>Colossus Mark 2 @ Bletchley Park. Reconstrucción.</i>
    br
    br

    p En 1946, William Mauchley y J. Presper Eckert construyeron, en la Universidad de Pennsylvania uno de los primeros computadores programables de propósito general: el <a href="https://en.wikipedia.org/wiki/ENIAC">ENIAC</a> (<i>Electronic Numerical Integrator and Computer</i>), Poseía 20000 tubos de vacío, pesaba 27 toneladas, ocupaba 167m<sup>2</sup> y consumía 150kW de electricidad. Su dispositivo de entrada era un lector de tarjetas perforadas y su salida era un perforador de tarjetas (IBM 405). Poseía un <i>clock</i> de 100kHz, y utilizaba 20 registros de 10 dígitos binarios. No existía un lenguaje de programación, ni siquiera <i>assembler</i>, de manera que toda la computación era descrita en las tarjetas perforadas mediante código de máquina.

    div style="display:inline-block; width=50px; vertical-align:middle; border:none; text-align:center;"
      div
        img src='/images/figures/00-eniac-programming.jpg' width="45%" &nbsp; &nbsp; &nbsp; &nbsp; 
        img src='/images/figures/00-ENIAC.jpg' width="40%" 
      div style="font-size:14px; border:none;" <i>ENIAC (fragmento) @ School of Engineering and Applied Science, University of Pennsylvania.</i>
    br
    br


  section 
    h3 Segunda Generación (1955-65): Transistores y Sistemas <i>Batch</i>

    p La creación de los transistores en los años 1950 revolucionó la construcción de los dispositivos electrónicos reduciendo drásticamente las tasas de falla respecto al <i>hardware</i> construido con tubos de vacío y aumentando la velocidad de respuesta. Se empezaron a construir grandes computadores basados en transistores, conocidas como <b><i>mainframes</i></b>. Debido a su costo de consturcción, un computador de este tipo era solamente accesible para grandes corporaciones, gobiernos y universidades.

    p La operación de un <i>mainframe</i> requería la colaboración de varios actores. Un <i>mainframe</i> ejecuta <b><i>jobs</i></b> (trabajos), que consisten en el código de un programa, o una secuencia de programas. Los programas se ingresan mediante tarjetas perforadas y se escriben en lenguaje <i>assembler</i>. En 1953, John W. Backus, de IBM, propone una alternativa para hacer más práctica la descripción de programas en lugar de <i>assembler</i> y desarrolla el <i>FORmula TRANslating system</i>, conocido como lenguaje <b>FORTRAN</b>, junto con una herramienta para hacer la traducción hacia <i>assembler</i> llamada <b>compilador</b>.

    p Un programa escrito en FORTRAN sobre tarjetas perforadas, es entregado como <i>input</i> a un lector de tarjetas. El lector de tarjetas escribe sobre una cinta que se entrega a la máquina principal, la cual ejecuta las instrucciones, proceso que podía tardar horas dependiendo de la complejidad del cómputo, y escribe el resultado sobre otra cinta de salida. La cinta de salida es leída por otro dispositivo capaz de imprimir el contenido de la cinta a un papel. En ese momento termina la ejecución del <i>job</i>.

    p Notemos que durante el tiempo que un dispositivo está leyendo las tarjetas perforadas, tanto el dispositivo procesador como el dispositivo de salida no están haciendo ningún trabajo útil. Dado el costo del equipamiento era poco conveniente tener estas unidades en espera mientras se traduce una tarjeta perforada a una cinta magnética. Es por esto que se desarrollaron soluciones como el sistema de procesamiento <b><i>batch</i></b>, o <i>procesamiento por lotes</i>. En este modelo, un programador entrega sus tarjetas perforadas a un operador (otra persona) que se dedica a ingresar las tarjetas a una unidad lectora de tarjetas (<a href="https://en.wikipedia.org/wiki/IBM_1402">IBM 1402</a>). Cuando hay una cantidad suficiente de trabajos, el operador toma la cinta de salida y la traslada (físicamente) a un dispositivo procesador como el <a href="https://en.wikipedia.org/wiki/IBM_1401">IBM 1401</a> (3 registros, <i>word</i> de 6-bit con codificación BCD) o el más poderoso <a href="https://en.wikipedia.org/wiki/IBM_7090">IBM 7094</a> (7 registros, <i>word</i> de 36-bit, y espacio de direcciones de 15-bit: 32768 <i>words</i>, capaz de procesar a 100 KFLOP/s). El operador carga un primer programa (algo similar a un sistema operativo) que prepara al computador para leer una serie de <i>jobs</i> desde la cinta. Mientras el dispositivo procesador realiza las labores de cómputo, el IBM 1402 podía seguir leyendo el siguiente conjunto de tarjetas. La salida del dispositivo procesador iba a una cinta magnética de salida. El operador nuevamente debe tomar esta cinta, llevarla a un dispositivo impresor (<a href="https://en.wikipedia.org/wiki/IBM_1403">IBM 1403</a>) que transfiera el contenido de la cinta magnética a papel de manera <i>offline</i>. Esto es, no conectado al dispositivo procesador.

    div style="display:inline-block; width=50px; vertical-align:middle; border:none; text-align:center;"
      div
        img src='/images/figures/00-ibm1401.jpg' width="30%" &nbsp; &nbsp; &nbsp; &nbsp; 
        img src='/images/figures/00-ibm7094.jpg' width="30%" 
      div style="font-size:14px; border:none;" <i>Izquierda: IBM1402 (card reader), IBM1401 (processing), IBM1403 (printer). Derecha: IBM7094.</i>
    br
    div style="display:inline-block; width=50px; vertical-align:middle; border:none; text-align:center;"
      div
        img src='/images/figures/00-batch-manual.png' width="60%"
      div style="font-size:14px; border:none;" <i>Procesamiento por lotes (batch)</i>
    br
    br

    p Este tipo de computadores se usó principamente para cómputo científico y de ingeniería. Los programas que permitían a estos computadores procesar secuencialmente una cantidad de <b>jobs</b> fueron algunos de los primeros en cumplir la tarea de un sistema operativo, como <b>FMS</b> (<i>FORTRAN Monitor System</i>, básicamente un compilador de FORTRAN), y el sistema del IBM 7094, <b>IBSYS</b>.



  section
    h3 Tercera Generación (1965-1980): Circuitos Integrados y Multiprogramación

    p En los años 1960s, los <i>mainframes</i> de IBM, la compañía constructora de equipamiento computacional más importante de la época, requerían cada uno un <i>software</i> y periféricos distintos para funcionar, ya que las instrucciones no eran compatibles. Un programa hecho para un modelo debía ser reescrito ante la introducción de un nuevo modelo de <i>hardware</i>. La compañía decide unificar el <i>hardware</i> bajo una familia llamada <a href="https://en.wikipedia.org/wiki/IBM_System/360"><b>System/360</b></a>. Esta fue la primera línea importante basada en la nueva tecnología de <b>circuitos integrados</b> capaz de integrar grandes cantidades de pequeños transistores. Esto proporcionaba una enorme ventaja precio/rendimiento respecto a los transistores tradicionales.

    p La idea de tener una línea de <i>hardware</i> mutuamente compatible y de propósito general requería un sistema capaz de funcionar en todos los modelos. Este sistema fue el <a href="https://en.wikipedia.org/wiki/OS/360_and_successors"><b><i>OS/360</i></b></a>. El <i>software</i> resultante resultó enormemente grande (millones de líneas de <i>assembler</i>) y complejo de desarrollar, con numerosos <i>bugs</i>, en tiempos en que la ingeniería de software no se desarrollaba como disciplina aún. El director del proyecto Fred Brooks describió sus experiencias en el libro <a href="https://en.wikipedia.org/wiki/The_Mythical_Man-Month">&quot;The Mythical Man-Month&quot;</a>, un clásico de la ingeniería de software.

    div style="display:inline-block; width:100%; vertical-align:middle; border:none; text-align:center;"
      div
        img src='/images/figures/00-ibms360.jpg' width="40%" &nbsp; &nbsp; &nbsp; &nbsp;
        img src='/images/figures/00-ibm360.jpg' width="40%"
      div style="font-size:14px; border:none;" <i>IBM360. Primera gran línea en utilizar circuitos integrados</i>
    br
    br

    p A pesar de todos sus defectos, OS/360 fue ampliamente usado, e introdujo algunas ideas clave en los sistemas computacionales. Sistemas como el IBM 7094 eran procesaban un trabajo simultáneamente. Si alguna instrucción de ese trabajo requería una lectura de cinta, o alguna operación de I/O, la CPU debía esperar sin hacer nada (<i>idle</i>) hasta que la operación terminase. Los trabajos científicos suelen ser intensivos en cómputo (<i>CPU-bound</i>), por lo que esto no era un problema. Sin embargo las aplicaciones comerciales requerían operaciones de I/O el 80% a 90% de las veces (<i>I/O-bound</i>) por lo que gran parte del tiempo la CPU se encontraba <i>idle</i>.

    p La solución fue dividir el espacio de memoria en regiones, y asignar un espacio distinto a cada <i>job</i>. Se introdujo un mecanismo que permitiera que, cada vez que un <i>job</i> estuviese esperando una operación de I/O, el sistema permitiera que otro <i>job</i> pudiese ocupar la CPU. De esta manera, si hay suficiente <i>jobs</i> en la memoria, sería posible mantener a la CPU trabajando casi el 100% del tiempo. Este mecanismo fue un enorme avance que ocupamos hasta el día de hoy, y se llama <b>multiprogramación</b>.

    p Implementar <b>multiprogramación</b> requiere que cada <i>job</i> pueda funcionar de manera aislada de los demás. Se agregó en el <i>hardware</i> el mecanismo necesario para proveer esta protección y evitar que un <i>job</i> malicioso pudiese leer o escribir en memoria asignada a otro <i>job</i>.

    div style="display:inline-block; width:100%; vertical-align:middle; border:none; text-align:center;"
      div
        img src='/images/figures/00-osmultiprog-opt.svg' width="40%"
      div style="font-size:14px; border:none;" <i><b>Multiprogramación.</b> Múltiples procesos en memoria principal.</i>
    br
    br

    p Una segunda característica introducida fue la integración de los periféricos como el lector de tarjetas, y la automatización de la lectura. De esta manera, una vez que un <i>job</i> terminaba su ejecución, el sistema operativo podía leer el siguiente que estuviera disponible y cargarlo en la partición libre. Esta técnica se conoce como <b><i>spooling</i></b> (<i>Simultaneous Peripheral Operation On Line</i>). Ya no se necesitaba un dispositivo separado, y un operador que trasladara cintas.

    p Hasta el momento todo el avance había apuntado a mejorar los sistemas de procesamiento por lotes (<i>batch</i>). El programador entrega sus tarjetas, y espera hasta obtener un resultado. Por supuesto, los programadores también cometían errores y, una vez entregado el programa, debían esperar algunas horas hasta recibir el <i>output</i> que indicara que su código había fallado porque le faltaba un <code>;</code>. Medio día perdido antes de corregir el error y reenviar el <i>job</i>. No había ningún tipo de interactividad con el sistema. Dada la cantidad de usuarios que deseaban utilizar el computador, asignar horas para que cada usuario interactuara directamente y de manera individual con el computador era tremendamente ineficiente, pues el computador pasaba la mayor parte del tiempo <i>idle</i> mientras el usuario ingresaba código. El modelo <i>batch</i> seguía siendo superior. 

    p La siguiente innovación apuntó a mejorar esta situación. Si un usuario escribe código durante un minuto, y luego piensa (o se para, o toma café) durante 20 segundos, se podría permitir a otro usuario que interactuara con el computador durante esos 20 segundos. La misma idea de la multiprogramación, sin embargo los humanos no son tan rápidos para cambiar de posición frente al teclado. Se le asignó entonces un terminal (consola) <i>online</i> a cada usuario: una cantidad de dispositivos con teclado conectados al mismo sistema, y se configuró para que, en cuanto un terminal dejaba de recibir comandos o ejecutar algún trabajo, el sistema pasara a atender al siguiente terminal. De esta manera, si un usuario no estaba interactuando con el computador, el procesador podía atender a otro. Nacieron desde aquí los sistemas de <b><i>timesharing</i></b> ("compartición" de tiempo).

    p Construir un sistema de <b>timesharing</b> era inviable en los computadores previos a esta época, ya que se requería almacenar el estado de un proceso y recuperar el estado del proceso siguiente (esto se llama <i>context switch</i> o <i>cambio de contexto</i>) lo que podía ser costoso en tiempo. Sin embargo, la tecnología de esos años ya había evolucionado para permitir que este método fuera viable. Un problema, aún no resuelto en estos sistemas, es que si un usuario enviaba un trabajo largo de tipo <i>CPU-bound</i> (una compilación, un cálculo matricial, ordenar miles de registros, &hellip;), los demás usuarios tendrían que esperar hasta que este proceso terminara antes de obtener su espacio (<i>slice</i>) de tiempo.

    p El primer sistema de propósito general que permitía <b>timesharing</b> fue <a href="http://www.cozx.com/dpitts/ibm7090.html"><b>CTSS</b></a> (<i>Compatible Time Sharing System</i>), desarrollado en MIT en 1961 sobre un IBM 7094. Si bien el problema de protección de datos entre usuarios no estaba resuelto y los usuarios debían tener cuidado de no alterar el trabajo de otros, CTSS introdujo un tipo de interactividad que no había sido posible anteriormente.

    p Ante esto, MIT, Bell Labs, y General Electric, deciden crear un sistema que soporte cientos de usuarios. De la misma manera que múltiples casas podían tener acceso a la red eléctrica, en este sistema múltiples usuarios tendrían acceso a tiempo de cómputo (en la actualidad esto se llamaría &quot;Computing Time as a Service&quot;) con tan solo conectarse a este <i>mainframe</i> (una nube de cómputo). El sistema fue bautizado como <a href="http://www.multicians.org/"><b>MULTICS</b></a> (<b>MULT</b>iplexed <b>I</b>nformation and <b>C</b>omputing <b>S</b>ervice).

    p <b>MULTICS</b> tuvo un éxito parcial. Además de ser escrito en PL/I, un lenguaje poco popular y con un compilador deficiente, el proyecto resultó ser sumamente ambicioso para la época (como la máquina de Babbage) y demasiado complejo lo que demoró el desarrollo al punto que Bell Labs y General Electric abandonaron el proyecto. MIT persistió y el sistema eventualmente fue terminado. Honeywell, la compañía que continuó las operaciones de General Electric en el área de los computadores, lo adquirió y consiguió suficientes clientes para hacerlo viable. No alcanzó mucha popularidad pero su desarrollo tuvo una gran influencia en sus sucesores.

    div style="display:inline-block; width:100%; vertical-align:middle; border:none; text-align:center;"
      div 
        img src='/images/figures/00-multics.jpg' width="25%"
      div style="font-size:14px; border:none;" <i><b>MULTICS.</b> MULTiplexed Information and Computing Service. </i>
    br
    br

    p El desarrollo de la tecnología de transistores en circuitos integrados cada vez más pequeños y confiables (<i>reliable</i>) permitió que se construyeran computadores más pequeños tanto o más poderosos que los de la época. Se les llamó <i>minicomputadores</i> y uno de los más famosos fue el <a href="https://en.wikipedia.org/wiki/PDP-1">PDP-1</a> (<i>Programmed Data Processor</i>) de la compañía <a href="http://gordonbell.azurewebsites.net/digital/timeline/tmlnhome.htm">DEC</a> (<i>Digital Equipment Corporation</i>), competidora de IBM y que fue comprada por Compaq (luego HP) en 1998. El DEC PDP-1 usaba <i>words</i> de 18-bit y soportaba 4096 <i>words</i>, con ciclos de acceso a memoria de 5.35 usec. DEC construyó modelos sucesivos de la línea PDP, no compatibles entre sí, hasta el PDP-16.

    div style="display:inline-block; width:100%; vertical-align:middle; border:none; text-align:center;"
      div 
        a rel="nofollow" class="external free" href="https://www.flickr.com/photos/hiddenloop/307119987/"
          img src='/images/figures/00-PDP-1.jpg' width="40%" &nbsp; &nbsp; &nbsp; &nbsp;
        a rel="nofollow" class="external free" href="https://commons.wikimedia.org/w/index.php?curid=1587539"
          img src='/images/figures/00-PDP-1-panel.jpg' width="40%"          
      div style="font-size:14px; border:none;" <i>DEC PDP-1. Picture by Matthew Hutchinson, <a href="http://creativecommons.org/licenses/by/2.0" title="Creative Commons Attribution 2.0">CC BY 2.0</a></i><br><i>Panel de control. Picture by fjarlq / Matt <a href="http://creativecommons.org/licenses/by/2.0" title="Creative Commons Attribution 2.0">CC BY 2.0</a></i>
    br
    br

    p En Bell Labs, 1969, <a href="https://en.wikipedia.org/wiki/Ken_Thompson">Ken Thompson</a> y <a href="https://en.wikipedia.org/wiki/Dennis_Ritchie">Dennis Ritchie (1941-2011)</a>, dos de los científicos que habían trabajado en MULTICS decidieron desarrollar una versión "reducida" de MULTICS para un PDP-7 que no estaba siendo usado. Esta versión tendría un diseño mucho más simple y en sus inicios soportaba solamente a un usuario (<i>uni-task</i>) en contraposición a MULTICS que era <i>multi-task</i>. Este trabajo fue bautizado como UNICS por <i>UNIplexed Information and Computing Service</i> como un juego de palabras respecto a MULTICS, y finalmente simplificado como <a href="https://people.eecs.berkeley.edu/~brewer/cs262/unix.pdf"><b>UNIX</b></a>.

    p La versión original de UNIX, para el PDP-7 y posteriormente para el PDP-11 estaba escrita en <i>assembler</i>. Fue en este sistema que se decidió reescribirlo en otro lenguaje. Inicialmente se consideró el lenguaje B, una versión simplificada de BPCL, otro lenguaje existente. Sin embargo, B no podía aprovechar todas las características del PDP-11, y se utilizó otro lenguaje desarrollado por Dennis Ritchie: el lenguaje <a href="https://en.wikipedia.org/wiki/C_(programming_language)"><b>C</b></a>, concebido como un sucesor de B. En 1972, Dennis Ritchie reescribe UNIX en el lenguaje C. De esta manera UNIX se convirtió en uno de los primeros sistemas operativos masivos en ser implementado en un lenguaje de mayor nivel que <i>assembler</i>, y el desarrollo de C continuó estando íntimamente ligado al <i>kernel</i> de UNIX.
      
    div style="display:inline-block; width:100%; vertical-align:middle; border:none; text-align:center;"
      img src='/images/figures/00-Thompson-Ritchie-2.jpg' width="30%" style="background:none; border:none; box-shadow:none;" &nbsp;
      img src='/images/figures/00-unix.gif' width="30%" style="background:none; border:none; box-shadow:none;" &nbsp;
      img src='/images/figures/00-ThompsonRitchie.jpg' width="30%" style="background:none; border:none; box-shadow:none;"
      div style="text-align:center; font-size:14px;" <i>Izquierda: Ken Thompson y Dennis Ritchie. Centro: Libro &quot;The Unix Programming Environment&quot;, que describe los principios de diseño de Unix. Derecha: Ritchie (de pie) y Thompson en un PDP-11</i>
    br
    br

    p El código fuente de UNIX estaba disponible públicamente lo que permitió a distintas instituciones y universidad desarrollar su propia versión para sus sistemas, cada uno inspirado en los mismos principios pero incompatibles entre sí. De estas versiones, dos de las más importantes que perduraron fueron la versión comercial de AT&T llamada <a href="https://en.wikipedia.org/wiki/UNIX_System_V"><b>System V</b></a> (1983), y la versión de la Universidad de California en Berkeley, <a href="https://en.wikipedia.org/wiki/Berkeley_Software_Distribution"><b>BSD</b></a> (Berkeley Software Distribution, 1977).

    div style="display:inline-block; width:100%; vertical-align:middle; border:none; text-align:center;"
      img src='/images/figures/00-unixsystemv.jpg' width="20%" style="background:none; border:none; box-shadow:none;" &nbsp;
      img src='/images/figures/00-unixbsd.png' width="20%" style="background:none; border:none; box-shadow:none;" &nbsp;

    div style="display:inline-block; width:100%; vertical-align:middle; border:none; text-align:center;"
      a href="https://commons.wikimedia.org/w/index.php?curid=1801948"
        img src='/images/figures/00-Unix-history-simple.svg' width="50%" style="background:none; border:none; box-shadow:none;"
      div style="text-align:center; font-size:14px;" <i>Versiones de UNIX, por Eraserhead1, Infinity0, Sav_vas - Levenez Unix History Diagram, Information on the history of IBM&apos;s AIX on ibm.com, CC BY-SA 3.0</i>
    br
    br

    p Bajo esta situación no era posible escribir programas que funcionaran correctamente bajo las distintas versiones de UNIX. Para ello, la IEEE desarrolló una interfaz estándar de llamadas al sistema (<i>syscalls</i>) conocida como <a href="https://en.wikipedia.org/wiki/POSIX"><b><i>Portable Operating System Interface</i></b></a> ó <b><i>POSIX</i></b>. La X viene del hecho que se tomó UNIX como base para crear la interfaz. Al implementar POSIX (o ser &quot;POSIX-conformant&quot;), los sistemas se hicieron más interoperables. Más aún, otros sistemas operativos no basados en UNIX también han implementado POSIX (<a href="https://social.technet.microsoft.com/wiki/contents/articles/10224.posix-and-unix-support-in-windows.aspx">ejemplo</a>).

    p En 1983, todas las versiones de UNIX utilizaban licencias comerciales. En MIT, <a href="https://www.stallman.org/">Richard Stallman</a> inicia el proyecto <a href="https://www.gnu.org/">GNU</a> (<i>GNU is Not UNIX</i>, un acrónimo recursivo) con el objetivo de desarrollar una versión completamente gratuita y de código abierto de un sistema &quot;UNIX-like&quot;. Como parte de su proyecto se definió la <a href="https://www.gnu.org/licenses/gpl.html">GNU General Public License</a>, <b>GPL</b>, se publicó el <a href="https://www.gnu.org/gnu/manifesto.html">GNU Manifesto</a> y se desarrollaron múltiples herramientas como <code>gcc</code> (<i>GNU Compiler Collection</i>), <code>glibc</code> (<i>GNU C Library</i>), <code>coreutils</code> (<i>GNU Core Utilities</i>), <code>binutils</code> (<i>GNU Binary Utilities</i>), <code>bash</code> (<i>GNU Bash Shell</i>), y el entorno de escritorio GNOME (originalmente <i>GNU Network Object Model Environment</i>). Sin embargo el <i>microkernel</i>, denominado <a href="https://www.gnu.org/software/hurd/index.html"><b><i>GNU Hurd</i></b></a> (donde Hurd se define como <i>Hird of Unix-Replacing Daemons</i>, y Hird como <i>Hurd of Interfaces Representing Depth</i>, y que en el fondo suena similar a <i>herd of GNUs</i>), demoró en ser terminado (aún al año 2018 no hay una versión 1.0).

    p En 1987, <a href="http://www.cs.vu.nl/~ast/">Andrew S. Tanenbaum</a> desarrolló un clon de UNIX llamado <a href="http://www.minix3.org/">MINIX</a> con fines educacionales (POSIX-compliant), un microkernel modular de código abierto con la capacidad de detectar y reemplazar dinámicamente módulos defectuosos. Todo en 13000 líneas de código.

    p En 1991, ante la ausencia de un <i>kernel</i> gratuito de UNIX, y bajo la inspiración de MINIX, <a href="https://en.wikipedia.org/wiki/Linus_Torvalds">Linus Torvalds</a> desarrolla un clon monolítico <a href="https://groups.google.com/forum/#!original/comp.os.minix/dlNtH7RRrGA/SwRavCzVE7gJ">&quot;just for fun&quot;</a>, al cual llama <a href="https://www.kernel.org/"><b><i>Linux</i></b></a> e incluye gran parte de las herramientas desarrolladas por el proyecto GNU. Por esta razón los puristas suelen denominar al sistema operativo <a href="https://en.wikipedia.org/wiki/GNU/Linux_naming_controversy"><b>GNU/Linux</b></a>, pues se trata de un &quot;kernel Linux con herramientas GNU&quot;, de la misma manera que <b>GNU/Hurd</b> sería un kernel Hurd con herramientas GNU&quot;.

    div style="display:inline-block; width:100%; vertical-align:middle; border:none; text-align:center;"
      img src='/images/figures/00-minix3.jpg' width="20%" style="background:none; border:none; box-shadow:none;" &nbsp;
      img src='/images/figures/00-gnu.png' width="25%" style="background:none; border:none; box-shadow:none;" &nbsp;
      img src='/images/figures/00-linux.jpg' width="30%" style="background:none; border:none; box-shadow:none;"

    p En 1992, Andrew S. Tanenbaum publicó un mensaje en el <i>newsgroup</i> <code>comp.os.minix</code> con el <i>subject</i> &quot;<i>Linux is obsolete</i>&quot;, haciendo referencia a la naturaleza monolítica del recientemente publicado Linux en contraposición a la arquitectura microkernel de MINIX. Este mensaje marcó el inicio de un interesante y clásico debate conocido como <a href="http://www.oreilly.com/catalog/opensources/book/appa.html"><i>Tanenbaum-Torvalds debate</i></a>.


    div style="display:inline-block; width:100%; vertical-align:middle; border:none; text-align:center;"
      a href="https://commons.wikimedia.org/w/index.php?curid=54867596"
        img src='/images/figures/00-ast.jpg' width="20%" style="background:none; border:none; box-shadow:none;" &nbsp;
      img src='/images/figures/00-versus.png' width="20%" style="background:none; border:none; box-shadow:none;" &nbsp;
      a href="https://commons.wikimedia.org/w/index.php?curid=54706023"
        img src='/images/figures/00-linus.jpg' width="20%" style="background:none; border:none; box-shadow:none;"
      div style="text-align:center; font-size:14px;" <i>Andrew S. Tanenbaum (Andy, para los amigos), imagen de <a href="//commons.wikimedia.org/wiki/User:Jantangring" title="User:Jantangring">Jantangring</a>, <a href="https://creativecommons.org/licenses/by-sa/4.0" title="Creative Commons Attribution-Share Alike 4.0">CC BY-SA 4.0</a>. Linus Torvalds, imagen de <a href="//commons.wikimedia.org/wiki/User:Krd" title="User:Krd">Krd</a>, <a href="https://creativecommons.org/licenses/by-sa/4.0" title="Creative Commons Attribution-Share Alike 4.0">CC BY-SA 4.0</a></i>





  section
    h3 Cuarta Generación (1980-Presente): Computadores personales

    p El desarrollo tecnológico de los circuitos integrados llegó al nivel conocido como <b>VLSI</b> (<i>Very Large Scale Integration</i>), capaz de integrar hasta 1 millón de transistores en un chip de 1cm2, lo que permitía hasta 100000 celdas lógicas. Surgieron sistemas computacionales de uso personal denominados <b>microcomputadores</b>, que en principio no eran tecnológicamente muy superiores al PDP-11, pero a un precio notablemente inferior.

    p En 1974, Intel presenta el chip <a href="https://en.wikipedia.org/wiki/Intel_8080">Intel 8080</a>, una CPU de propósito general de 8-bit con un <i>clock</i> de 2MHz, sucesora del <a href="https://en.wikipedia.org/wiki/Intel_4004">4004</a> y el <a href="https://en.wikipedia.org/wiki/Intel_8008">8008</a>, los primeros microprocesadores del mercado. Fue parte del popular <a href="https://en.wikipedia.org/wiki/Altair_8800">MITS Altair 8800</a>, que dio inicio a la era de los microcomputadores.

    p Intel deseaba un sistema operativo propio para el Intel 8080, por lo cual <a href="https://en.wikipedia.org/wiki/Gary_Kildall">Gary Kildall</a> construyó un sistema operativo basado en disco (contenido en un <i>floppy disk</i> de 8&quot;) conectado al 8080, y llamado <a href="http://www.digitalresearch.biz/CPM.HTM">CP/M</a> (<i>Control Program for Microcomputers</i>). CP/M era un sistema <i>single-task</i> de 8-bit y capaz de utilizar hasta 64 KB de memoria. Si bien el sistema fue adoptado por Intel, no le veían mucho futuro a un sistema operativo residente en disco, y los derechos quedaron en manos de Gary Kildall quien formó la compañía <a href="http://www.digitalresearch.biz/">Digital Research Inc.</a> para desarrollar y vender CP/M. Digital Research adaptó CP/M para diversos microcomputadores usando el Intel 8080, pero también para otros microprocesadores de la época como el <a href="https://en.wikipedia.org/wiki/Zilog_Z80">Zilog Z80</a>, dominando el mercado durante unos 5 años. En este periodo se desarrollaron versiones <i>multitasking</i> y de 16-bit. Aplicaciones que surgieron bajo CP/M fueron <A href="https://en.wikipedia.org/wiki/WordStar">WordStar</a> (procesador de texto), <a href="https://en.wikipedia.org/wiki/DBase">dBase</a> (base de datos), <a href="https://en.wikipedia.org/wiki/Multiplan">Multiplan</a> (planilla de cálculo), y <a href="https://en.wikipedia.org/wiki/Turbo_Pascal">Turbo Pascal</a> (IDE y compilador para Pascal).

    p IBM, por su parte, que había dominado el mercado de los <i>mainframes</i> se estaba quedando atrás en el nuevo mercado de los <i>microcomputadores</i> y empezó a desarrollar su propia versión: el <a href="https://en.wikipedia.org/wiki/IBM_Personal_Computer"><b><i>IBM Personal Computer</i></b></a> (<b>IBM PC</b>) basado en el <a href="https://en.wikipedia.org/wiki/Intel_8088">Intel 8088</a> de 16-bit, 4.77MHz de <i>clock</i>, y hasta 256 kB de RAM. En 1980, IBM contactó a una pequeña compañía de nombre <a href="https://en.wikipedia.org/wiki/History_of_Microsoft"><b>Microsoft</b></a> fundada por <a href="https://en.wikipedia.org/wiki/Bill_Gates">Bill Gates</a> y <a href="https://en.wikipedia.org/wiki/Paul_Allen">Paul Allen</a> en 1975, y conocida por desarrollar un intérprete del lenguaje <a href="https://en.wikipedia.org/wiki/BASIC">BASIC</a> para el popular Altair 8800. Sin embargo, IBM deseaba un sistema operativo completo, y Bill Gates les sugirió contactar a Digital Research, que con CP/M era el dominador absoluto de los sistemas operativos. La negociación con Digital Research fracasó al no llegar a un NDA (<i>Non-Disclosure Agreement</i>) respecto al IBM PC. Si bien las <a href="https://forwardthinking.pcmag.com/software/286148-the-rise-of-dos-how-microsoft-got-the-ibm-pc-os-contract">razones no son claras</a>, se dice que Gary Kildall no quiso reunirse con IBM, que envió a Dorothy McEwen (co-fundadora de Digital Research, y su esposa) en su lugar, que no estuvo de acuerdo con el espacio de tiempo que se le dio para desarrollar una versión de CP/M para el Intel 8086 (que sería el futuro <a href="https://en.wikipedia.org/wiki/CP/M-86">CP/M-86</a>), o que simplemente no se llegó a acuerdo económico. 

    p IBM regresó con Microsoft para solicitar el desarrollo de un sistema operativo para su IBM PC. Bill Gates adquirió un clon de CP/M de una compañía más pequeña aún llamada <a href="https://en.wikipedia.org/wiki/Seattle_Computer_Products"><b>Seattle Computer Products</b></a> (SCP). En esta compañía trabajaba <a href="https://en.wikipedia.org/wiki/Tim_Paterson">Tim Paterson</a> quien, ante la demora en el desarrollo de CP/M-86, había desarrollado en 4 meses un clon llamado <b>QDOS</b> (<i>Quick and Dirty Operating System</i>) que fue renombrado a <a href="https://en.wikipedia.org/wiki/86-DOS">86-DOS</a>. Microsoft logró un acuerdo con SCP para distribuir, y posteriormente adquirir todos los derechos sobre 86-DOS llamándolo <a href="https://en.wikipedia.org/wiki/MS-DOS"><b><i>MicroSoft Disk Operating System</i></b></a> (<b>MS-DOS</b>). Este sistema operativo, junto al intérprete de BASIC fueron ofrecidos a IBM. Microsoft contrató a Tim Paterson para realizar algunas modificaciones y finalmente el IBM PC fue lanzado junto al sistema operativo renombrado por IBM como <b>PC-DOS</b>. Debido a que, en el fondo, PC-DOS había nacido como un clon de CP/M y para evitar problemas legales, IBM eventualmente distribuyó su IBM PC también con CP/M-86. Sin embargo, CP/M-86 había llegado 6 meses tarde y fue superado por la rápida popularidad de PC-DOS.

    p Microsoft, sin embargo, nunca entregó los derechos sobre MS-DOS, sino que solo entregó una licencia a IBM. El IBM PC fue tremendamente exitoso, y pronto otros manufacturadores empezaron a desarrollar clones de su <i>hardware</i>. Sin embargo, el sistema operativo no era propiedad de IBM, por lo que cada constructor podía obtener una licencia de MS-DOS lo que posicionó a Microsoft como líder en el mercado de los sistemas operativos, y desplazando definitivamente a CP/M y Digital Research Inc. del mercado. <a href="http://www.digitalresearch.biz/CPM.HTM">Años después</a>, en 1996, Digital Research Inc., en ese tiempo parte de la empresa <a href="http://www.caldera.com/">Caldera Inc.</a>, demandaría a Microsoft por sus productos MS-DOS, Windows 95 y Windows 98 bajo el argumento que todos, en el fondo, poseían código de CP/M que había sido clonado ilegalmente por SCP. El año 2000 llegaron a un acuerdo bajo el cual Microsoft Corp. compensó parcialmente a Caldera Inc. Parte del legado de CP/M en MS-DOS incluía el formato de nombre de archivos de 8.3 (8 caracteres para el nombre, y 3 para la extensión), y la manera de nombrar las unidades de disco como <code>A:</code>, <code>B:</code>, <code>C:</code>, &hellip;

    div style="display:inline-block; width:100%; vertical-align:middle; border:none; text-align:center;"
      img src='/images/figures/00-msdos.png' width="35%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"


    p En 1983, IBM lanza el IBM PC/AT, con el chip Intel 80286, de 16-bit, con <i>clock</i> de 6MHz, y con modo de protección para soportar <i>multitasking</i>. MS-DOS continuó siendo el sistema operativo de preferencia de los consumidores, distribuido como PC-DOS en las máquinas originales de IBM. Este soporte continuó con la introducción de los Intel 80386 y 80486. MS-DOS también evolucionó incorporando características de UNIX como <i>multitasking</i> y soporte de nombres de archivos largo. Eventualmente Microsoft produjo su propia implementación de UNIX llamada <a href="https://en.wikipedia.org/wiki/Xenix">Xenix</a>.

    p Tanto MS-DOS como CP/M-86 seguían interactuando con el usuario a través de líneas de comando y teclado. Esto cambiaría debido a una investigación en interacción humano-computador que venía siendo desarrollada desde los años 1960s por <a href="https://en.wikipedia.org/wiki/Douglas_Engelbart">Doug Engelbart</a> (1925-2013) en el Stanford Research Institute (SRI). quien creó las <b>GUI</b> (<i>Graphical User Interface</i>) como medio de interactuar con el computador mediante un conjunto de abstracciones gráficas como ventanas, íconos, menúes, hipertexto, y un dispositivo apuntador llamado <i>mouse</i>. Su trabajo, el sistema <a href="https://en.wikipedia.org/wiki/NLS_(computer_system)"><b>NLS</b></a> (<i>oN-Line System</i>) fue presentado en un evento que se conoce como <a href="https://www.youtube.com/watch?v=yJDv-zdhzMY"><i>The Mother of All Demos</i></a>. Tuvo tanta influencia que este tipo de interfaces se empezó a usar en el centro de investigación de <a href="http://www.parc.com/">Xerox PARC</a> (<i>Xerox Palo Alto Research Center</i>) y en particular en su computador <a href="https://en.wikipedia.org/wiki/Xerox_Alto">Xerox Alto</a>.

    div style="display:inline-block; width:100%; vertical-align:middle; border:none; text-align:center;"
      img src='/images/figures/00-mouse.jpg' width="20%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"


    p No sería, hasta el desarrollo del <a href="https://en.wikipedia.org/wiki/Apple_Lisa">Apple Lisa</a> (1983) y el <a href="https://en.wikipedia.org/wiki/Compact_Macintosh">Apple Macintosh</a> (1984), los primeros computadores personales en incluir una interfaz gráfica que las GUIs se harían populares al acercar el uso del computador al público general e incorporar el concepto de <i>user friendly</i>. Se dice que Steve Jobs, co-fundador de <a href="http://apple.com/">Apple Computer Inc.</a> habría tenido la idea incorporar la GUI a su próximo computador (Lisa) luego de una visita que realizó en 1979 a Xerox PARC, sin embargo hay <a href="https://web.stanford.edu/dept/SUL/sites/mac/parc.html">testimonios</a> que indican que el plan de incorporar una GUI al Apple Lisa existía <a href="http://www.mac-history.net/computer-history/2012-03-22/apple-and-xerox-parc">de manera previa</a> a dicha visita (Steve Jobs y los ingenieros de Apple tenían suficientes motivos para visitar Xerox PARC, en cualquier caso, y la visita efectivamente ocurrió). En cualquier caso el Apple Macintosh fue ampliamente popular en particular en el ámbito del diseño gráfico.

    p Hasta 1999, el sistema operativo de los computadores de Apple se trataba de un <i>kernel</i> monolítico desarrollado para chips Motorola 68k. Su última versión fue el <a href="https://en.wikipedia.org/wiki/Classic_Mac_OS">Mac OS 9</a>. El próximo <i>kernel</i> toma como punto de origen <a href="http://www.cs.cmu.edu/afs/cs/project/mach/public/www/mach.html">Mach</a>, una reimplementación de BSD Unix con arquitectura de microkernel desarollado en Carnegie Mellon University. La compañía <a href="https://web.archive.org/web/19970412194822/http://www.next.com/">NeXT</a>, fundada por Steve Jobs durante su periodo fuera de Apple, había desarrollado el sistema operativo <a href="https://en.wikipedia.org/wiki/NeXTSTEP">NeXTSTEP</a> a partir de Mach, y escrito en C y Objective-C. Cuando Apple adquirió NeXT (y a Steve Jobs de regreso), se introdujo el <i>kernel</i> híbrido <a href="http://opensource.apple.com/source/xnu">XNU</a> (<i>XNU is Not Unix</i>) combinando ideas del <i>kernel</i> Mach 2.5 y de UNIX BSD 4.3. Se incorporó código del kernel de NeXTSTEP (y su siguiente versión OPENSTEP), y del proyecto <a href="https://www.freebsd.org/">FreeBSD</a> una implementación opensource de BSD UNIX. Con base en el kernel XNU se construyó el sistema operativo que se conoce como <a href="https://opensource.apple.com/">Darwin</a> (opensource y POSIX-compliant), que junto con herramientas propietarias de Apple (como Finder y la interface gráfica Aqua) conformaron el sistema operativo <a href="https://www.apple.com/macos">Mac OS X</a>.

    p Por otro lado, Microsoft planeaba un sucesor para MS-DOS, fuertemente influenciado por el éxito del Apple Macintosh. Su primer intento fue un sistema administrador de ventana llamado <a href="https://en.wikipedia.org/wiki/Windows_1.0">Windows 1.0</a> (1985) que funcionaba como una aplicación sobre MS-DOS. La versión que consiguió mayor adopción fue Windows <a href="https://en.wikipedia.org/wiki/Windows_3.1x">3.11</a>, aún para sistemas de 16-bit. Fue en 1995, con el lanzamiento de <a href="https://en.wikipedia.org/wiki/Windows_9x">Windows 95</a> y luego Windows 98, que se incorporó código para aprovechar las nuevas CPU de 32-bit, aun cuando parte del sistema operativo debía soportar aún aplicaciones de 16-bit por retrocompatibilidad. MS-DOS seguía siendo usado para iniciar el sistema y como soporte subyacente para aplicaciones antiguas.

    p Ya desde 1987, Microsoft había trabajado en conjunto con IBM para construir un sistema operativo con GUI. Este sistema se conoció como <a href="https://en.wikipedia.org/wiki/OS/2">OS/2</a>, sin embargo nunca alcanzó gran popularidad ante Machintosh y los mismos Windows 9x. Eventualmente Microsoft tomó parte del trabajo desarrollado para OS/2 y reimplementó Windows usando código completamente de 32-bit. Este nuevo sistema se llamó <a href="https://en.wikipedia.org/wiki/Windows_NT"><b>Windows NT</b></a> (<i>Windows New Technology</i>), mientras OS/2 fue eventualmente abandonado por IBM.

    p Windows NT fue desarrollado bajo el concepto de portabilidad. Implementó <i>preemptive multitasking</i>, soporte para múltiples arquitecturas modernas como IA-32, MIPS y DEC-Alpha, soporte para Windows API y POSIX, e introdujo un nuevo sistema de archivos, NTFS. La línea de Windows NT continuó con Windows XP, Windows Vista, Windows 7, Windows 8, y Windows 10. Paralelamente se introdujo una línea para servidores con Windows 2000, Windows Server 2003, Windows Server 2008, Windows Server 2012, y Windows Server 2016.



  section 
    h3 Quinta Generación (1990-Presente): Computadores Móviles

    p Hasta 1993, los dispositivos telefónicos móviles no era más que dispositivos de comunicación que usaban sistemas embebidos, dedicados, para administrar su <i>hardware</i>. El concepto de utilizar estos dispositivos para realizar actividades más allá de la telefonía surgió con los dispositivos conocidos como <b>PDA</b> (<i>Personal Digital Assistant</i>), entre los cuales se encuentra el <a href="https://en.wikipedia.org/wiki/Apple_Newton">Apple Newton</a> que incluía un sistema operativo <a href="https://en.wikipedia.org/wiki/Newton_OS">Newton OS</a> escrito en C++, y con un pionero uso de reconocimiento de escritura manual. Poseía una API para aplicaciones desarrolladas por terceros, sin embargo no obtuvo gran adopción.

    p Talvez el primer dispositivo llamado un <i>smartphone</i> fue el <a href="https://en.wikipedia.org/wiki/IBM_Simon">IBM Simon</a>, con una interfaz de pantalla <i>touch</i> (con stylus) y un sistema operativo <a href="https://en.wikipedia.org/wiki/Datalight#ROM-DOS">ROM-DOS</a>, compatible con MS-DOS y desarrollado por la empresa Datalight. Su batería de una hora de duración no le permitió competir con los nuevos dispositivos.

    p Fue finalmente en 1997 que la ya extinta compañía <a href="https://en.wikipedia.org/wiki/Palm,_Inc.">Palm, Inc.</a>  popularizó los dispositivos PDA mediante su <a href="https://en.wikipedia.org/wiki/PalmPilot">PalmPilot</a>, y su sistema operativo <a href="https://en.wikipedia.org/wiki/Palm_OS">Palm OS 2.0</a> como el primer sistema operativo móvil exitoso. Incorporaba el sistema <i>Graffiti</i> de reconocimiento de escritura manual, y el <i>stack</i> de protocolos TCP/IP para soportar sincronización por red en lugar de cable serial.

    p El éxito de Palm llevó a otros protagonistas de la telefonía móvil como <b>Nokia</b> a co-fundar y posteriormente adquirir completamente a <a href="https://en.wikipedia.org/wiki/Symbian_Ltd.">Symbian Ltd.</a>. El consorcio fundador incluía a <a href="https://en.wikipedia.org/wiki/Psion_(company)">Psion</a>, una compañía que estaba detrás de <a href="https://en.wikipedia.org/wiki/EPOC_(operating_system)">EPOC</a>, un sistema operativo <i>single-user</i> de 32-bit con <i>preemptive multitasking</i> que bajo Symbian se convertiría en <a href="https://en.wikipedia.org/wiki/Symbian_OS"><b>Symbian OS</b></a>. Symbian OS corría sobre procesadores <a href="https://en.wikipedia.org/wiki/ARM_architecture">ARM</a>, una arquitectura RISC. En su mejor momento, Symbian OS fue el sistema preferido por manufacturadores como Samsung, Motorola, Sony Ericsson, y principalmente Nokia. Poseía un <i>microkernel</i> llamado <a href="https://en.wikipedia.org/wiki/EKA2">EKA2</a> que soportaba <i>preemptive multithreading</i>, protección de memoria, y <i>scheduling</i> para tareas de tiempo real (<i>RTOS</i>). Poseía un diseño orientado a objetos y estaba escrito en C++. Symbian OS dominó gran parte del mercado de los sistemas operativos móviles hasta su abandono paulatino por Samsung, Sony Ericsson y eventualmente Nokia (que lo reemplazaría por Windows Phone), lo que lo hizo perder terreno ante la irrupción de iOS y Android.

    p Microsoft había desarrollado desde 1996 un sistema operativo embebido llamado <a href="http://msdn.microsoft.com/en-ph/embedded/"><b>Windows CE</b></a> (actualmente Windows Embedded Compact) diseñado para una especificación de plataformas incialmente denominado <a href="https://en.wikipedia.org/wiki/Pocket_PC">Pocket PC</a>. Los primeros dispositivos con Windows CE se lanzaron en 2002. Windows CE contenía un kernel híbrido escrito en C y soportaba arquitecturas x86, ARM, MIPS y PowerPC. La serie de sistemas operativos móviles basados en Windows CE fue conocida como <a href="https://en.wikipedia.org/wiki/Windows_Mobile">Windows Mobile</a> (incluyendo el <i>media player</i> <a href="https://en.wikipedia.org/wiki/Zune">Zune</a>) y fue desarrollado hasta 2010. Posteriormente Microsoft reimplementaría su sistema operativo móvil basado en la línea de Windows NT, dando inicio a <a href="https://en.wikipedia.org/wiki/Windows_Phone">Windows Phone</a>, línea que fue descontinuada en 2017 debido al poco interés de los desarrolladores en generar aplicaciones para esta plataforma ante la dominancia de iOS y Android.

    p En 2002 la compañía canadiense <b>Research In Motion</b> (RIM) desarrolló su propia línea de dispositivos móviles conocidos como <a href="https://en.wikipedia.org/wiki/BlackBerry"><b>BlackBerry</b></a> y su propio sistema operativo <a href="https://en.wikipedia.org/wiki/BlackBerry_OS"><b>BlackBerry OS</b></a> (RIM con el tiempo cambiaría su nombre a BlacBerry Ltd.). BlackBerry OS era un sistema <i>multitasking</i> con soporte para aplicaciones mediante la plataforma especial para dispositivos embebidos Java Micro Edition (JavaME). Incluía soporte para WAP, un <i>stack</i> de protocolos de comunicación para móviles que dejó de ser adoptado cuando los dispositivos móviles fueron suficientemente poderosos para procesar el tradicional <i>stack</i> TCP/IP. En 2010, BlackBerry OS fue reemplazado por <a href="https://en.wikipedia.org/wiki/BlackBerry_10"><b>BlackBerry 10</b></a>, un sistema basado en el <i>microkernel</i> de tiempo real (RTOS) <a href="https://en.wikipedia.org/wiki/QNX">QNX</a>. Desde 2016, los dispositivos producidos por BlackBerry empezaron a usar Android en lugar de BlackBerry 10, cuyo soporte ha sido anunciado al menos hasta 2019.

    p El año 2007 vio la entrada de uno de los principales competidores cuando Apple presentó su <a href="https://en.wikipedia.org/wiki/IPhone">iPhone</a> junto con su sistema operativo <a href="https://en.wikipedia.org/wiki/IOS"><b>iOS</b></a> (originalmente <i>iPhone OS</i>). iOS, al igual que MacOSX se basa en el kernel híbrido XNU y el sistema operativo (UNIX-like) Darwin. Desde el año 2010, con iOS 4, el sistema añadió soporte de APIs para <i>multitasking</i> por parte de aplicaciones de usuario. Previamente el <i>multitasking</i> estaba restringido solo a ciertos servicios del sistema. La disponibilidad del <a href="https://developer.apple.com/">iOS SDK</a> (<i>Software Development Kit</i>) atrajo el desarrollo de múltiples aplicaciones nativas disponibles desde una tienda <i>online</i> (App Store), popularizando rápidamente el uso del iPhone y posicionándolo como uno de los principales competidores.

    p Meses después del lanzamiento del primer iPhone, un conjunto de compañías lideradas por <a href="http://google.com/"><b>Google</b></a>, incluyendo a HTC, Sony, Dell, Intel, Motorola, Samsung, LG, Nvidia, entre otros, forman la <a href="http://www.openhandsetalliance.com/"><b>Open Handset Alliance</b></a> (OHA). Con el soporte de OHA, Google lanza en 2008 la primera versión de <a href="https://android.com/"><b><i>Android</i></b></a>, un sistema operativo monolítico (UNIX-like) de código abierto basado en el <i>kernel</i> Linux. Android inició su desarrollo bajo la compañía Android, Inc. fundada en 2003. El año 2005 Google adquirió Android, Inc. y fue bajo su alero que el equipo de desarrollo terminó la primera versión <a href="https://en.wikipedia.org/wiki/Android_version_history#Android_1.0.0_(API_1)">Android 1.0</a>. De manera similar a App Store, Android lanzó el <i>Android Market</i> (más tarde <i>Google Play Store</i>), y el <a href="http://developer.android.com/sdk/index.html">Android SDK</a> para el desarrollo de aplicaciones (escritas principalmente en Java, y recientemente en Kotlin) para terceros. El soporte de OHA, integrado por importantes actores del mercado <i>smartphone</i> fue clave para posicionar a Android como el sistema operativo dominador en los dispositivos móviles desde el año 2010, con iOS como su único (y distante) competidor real.

    p A diferencia de Linux, el kernel de Android no utiliza la tradicional GNU C Library <code>glibc</code>, sino que utiliza una implementación alternativa de la biblioteca de C desarrollado por Google, llamada <a href="https://en.wikipedia.org/wiki/Bionic_(software)">Bionic</a>, la cual posee un menor <i>memory footprint</i> que <code>glibc</code> y fue diseñado para CPUs funcionando a menor frecuencia de <i>clock</i> (y por lo tanto, optimizada para menor consumo energético). Bionic, sin embargo, no implementa toda la interfaz POSIX, haciendo que Android sea <i>Non-POSIX compliant</i>.

    p webOS

    p MeeGo

    p Bada

    p maemo



    blockquote style="background: #B7E1CD;" Microsoft adopta GUIs: <b><a src="https://www.youtube.com/watch?v=U7PxUYnbOf4">Windows</a></b>

    img src='/images/figures/00-windows.png' width="30%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"

    ul
      li MIT produce un sistema de ventanas para UNIX: <b>X Windows System</b> (luego X11, Xorg).
      li UNIX adopta GUIs que funcionan sobre X11 (Gnome, KDE, XFCE, etc)
      li Múltiples <a href="http://futurist.se/gldt/wp-content/uploads/12.10/gldt1210.png">distribuciones de Linux</a>

    img src='/images/figures/00-linuxes.png' width="20%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"
  
    img src='/images/figures/00-linux.jpg' width="30%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"


    div style="width:25%; vertical-align:middle; display:inline-block;"
    
      img src='/images/figures/00-simon.jpg' width="100%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"

      img src='/images/figures/00-mobiles.jpg' width="100%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"
    












    section
      h5 VM
      /  --------
      p Si ya usan Linux vayan a la sección de <a href="#programas">programas</a>.
      p Si no usan Linux, les recomendamos usar una VM, ya que no requiere particionar su disco.
      p Mientras descargan e instalan pueden comenzar a leer en paralelo la sección de <a href="#git" target="blank">git</a>.
      ul style="-webkit-columns:2; -moz-columns:2; columns:2;  list-style-position: inside;"
        li
          strong = link_to 'VirtualBox (Gratis)', 'https://www.virtualbox.org/wiki/Downloads'
        li = link_to 'VMWare', 'http://www.vmware.com/'
        li = link_to 'Parallels', 'http://www.parallels.com/'
      p En algunos computadores la virtualización debe ser habilitada desde la BIOS.
      p Existen muchas distribuciones de Linux. Todas ofrecen el kernel de Linux y un package manager, el que permite instalar paquetes de software, los que tienen programas o librerías que se instalan de manera uniforme tanto en interfaz como dentro del sistema de archivos.

    ul style="-webkit-columns:2; -moz-columns:2; columns:2;  list-style-position: inside;"
      li = link_to 'Archlinux', 'https://www.archlinux.org/download'
      li
        strong = link_to 'Manjaro (Archlinux-based)',   'https://manjaro.github.io/download'
      li = link_to 'Debian',    'https://www.debian.org/distrib/netinst'
      li
        strong = link_to 'Ubuntu (Debian-based)',    'https://www.ubuntu.com/desktop'

    p Manjaro y Ubuntu ofrecen discos de instalación bastante amigables. Desde ahora en adelante asumiremos que usan Linux.

    section#programas
      h5 Programas
      /  --------
      p Los programas necesarios son:
      ul style="-webkit-columns:2; -moz-columns:2; columns:2;  list-style-position: inside;"
        li
          dl.iinlinenline
            dt
              dfn
                abbr title="GNU Compiler Collection" GCC
            dd Un compilador de C.
        li
          dl.inline
            dt
              dfn Qemu
            dd  Un emulador.
        li
          strong git
        li Un emulador de Terminal.
        li Una <strong>shell</strong>.
        li Un editor de texto.

  section
    h3 Ambiente
    /  --------
    p Durante el proyecto y las tareas van a pasar la mayoría del tiempo trabajando con una shell, por lo que es recomendable por lo que es recomendable que inviertan un poco de tiempo en acostumbrarse y hacerla más cómoda.
    section
      h5 Terminal
      /  --------

      p Los <a href="https://en.wikipedia.org/wiki/VT100">terminales</a> son máquinas para usar remotamente un servidor, básicamente una pantalla y un teclado conectado en red al servidor. Hoy ya no se usan máquinas especiales, sólo un programa que simula una, por lo que en la práctica son sólo un programa para interactuar con una shell.
      p No hay demasiado que aprender y arreglar acá, sólo pueden cambiar la fuente y el colorscheme, así que pueden saltar a la sección de <a href="#shell">Shells</a>.
      p Varios 'prompts' usan caracteres especiales que necesitan parchar las fuentes para agregarlos, el set más usual es el de powerline, y existen paquetes con versiones parchadas de las fuentes, así que si su prompt se ve mal tienen que instalar y usar una fuente adecuada.

      p Existen varios emuladores de terminal, por lo general los escritorios tienen uno preferido, pero pueden usar cualquiera.
      ul style="-webkit-columns:2; -moz-columns:2; columns:2;  list-style-position: inside;"
        li konsole / yakuake <small>(KDE [Qt])</small>
        li gnome-terminal / guake <small>(Gnome,Unity [GTK])</small>
        li terminology <small>(Enlightenment [EFL])</small>
        li terminator <small>([GTK])</small>
        li
          small urxvt
        li
          small xterm

      p Fonts
      ul style="-webkit-columns:2; -moz-columns:2; columns:2;  list-style-position: inside;"
        li = link_to 'powerline/fonts', 'https://github.com/powerline/fonts'
        li = link_to 'AUR: powerline-fonts-git', 'https://aur.archlinux.org/packages/powerline-fonts-git/'
      p ColorSchemes
      ul style="-webkit-columns:2; -moz-columns:2; columns:2;  list-style-position: inside;"
        li = link_to 'Solarized', 'http://ethanschoonover.com/solarized'
        li = link_to 'SMYCK', 'http://color.smyck.org/'
        li = link_to 'Terminal ColorScheme Designer', 'http://ciembor.github.io/4bit/'


    section#shell
      h5 Shell
      /  -----

      p Una shell es un intérprete de comandos (al igual que el REPL de ruby/python/js/haskell/), lo que tiene de especial es que está orientada a ejecutar otros programas.

      h6 ¿Cuál usar?
      p Existen varias,
      ul
        li bash (generalmente default)
        li zsh
        p Casi 100% compatible con bash. La configuración default es mala, pero existen algunos frameworks fáciles de usar para configurarla:
        ul
          li
            strong = link_to 'prezto', 'https://github.com/sorin-ionescu/prezto'
          li = link_to 'oh-my-zsh', 'https://github.com/robbyrussell/oh-my-zsh'
        li fish
        p Muy buena por default. Tiene sintáxis distinta a la de bash, lo que quita portabilidad a sus scripts, pero no es un problema. También existe un framework para instalar plugins y themes:
        ul
          li = link_to 'oh-my-fish', 'https://github.com/oh-my-fish/oh-my-fish'
        li tsh, csh, ksh, ...

      h6 Usando la shell
      p Existe una lista de directorios donde la shell puede descubrir programas, es conocida como <code>PATH</code>. Es posible extenderla para ejecutar programas desde directorios personales.

      p Ejecutar programas es simple, basta escribir el nombre del programa<small>, o la ruta completa si no están en el PATH</small>. Se le pueden entregar argumentos separados por espacios, todos son strings.
      p Por ejemplo, podemos llamar a 'telnet' y darle un string como argumento para conectarnos a algún servidor.
      pre
        code.hljs
          | telnet towel.blinkenlights.nl

      h6 Pipes
      pre
        code.hljs
          | echo "Mooo" | cowsay
      p Acá llamamos a 'echo' con 'Mooo' como argumento, el que ejecuta y pasa su output como input de 'cowsay' sin argumentos. Esto produce el siguiente output:
      pre
        code.hljs
          |   ______
             < Mooo >
              ------
                       \   ^__^
                        \  (oo)\_______
                           (__)\       )\/\
                               ||----w |
                               ||     ||
      p El operador pipe <code>|</code> toma el output del programa de la izquierda y se lo entrega como input al de la derecha, se puede usar siempre. La ejecución se hace en paralelo y los datos se intercambian en líneas completas. Hay que notar que algunos programas no pueden generar output antes de consumir todo el input (sort).
      p Pueden encadenarse varios programas,
      pre
        code.hljs
          | echo "Moooooooo" | cowsay | cowsay -n | cowsay -n

      p Más adelante se verán con más detalle, por ahora basta que sepan que sirven para componer programas.


    section
      h5 Editor
      /  ------
      p Existen varios editores de texto. Vim y Emacs son muy configurables, por lo que es cómodo comenzar con una base.
      ul
        li vim
        ul style="-webkit-columns:2; -moz-columns:2; columns:2;  list-style-position: inside;"
          li
            strong = link_to "vim spf13", "https://github.com/spf13/spf13-vim"
          li = link_to "haskell-vim-now", "https://github.com/begriffs/haskell-vim-now"
          li = link_to "Derek Wyatt's config", "https://github.com/derekwyatt/vim-config"
          li = link_to "Vundle (Plugin Manager, DIY config)", "https://github.com/VundleVim/Vundle.vim"
        li emacs
        ul style="-webkit-columns:2; -moz-columns:2; columns:2;  list-style-position: inside;"
          li
            strong = link_to "Spacemacs", "https://github.com/syl20bnr/spacemacs"
          li = link_to "Aaron Bedra's config", "http://aaronbedra.com/emacs.d/"
          li = link_to "Sacha Chua's config", "http://pages.sachachua.com/.emacs.d/Sacha.html"
        li kate/gedit
        li atom/sublime/notepad++
        li <small>(ed)</small>

      p Lo más importante es que les sea una herramienta útil y los haga eficientes en vez de ser un obstáculo. Vim y Emacs son superiores a la mayoría, pero hay que aprender a usarlos (comenzar es fácil, gastar 30 minutos y ser más lento al principio se paga).


    section#git
      h5 Git
      /  ---
      p Git es un sistema de control de versiones distribuido que se ha convertido en una herramienta esencial para cualquier proyecto serio.

      p Para aprender git existe mucho material en internet.
      ul
        li
          strong = link_to "Book", "https://git-scm.com/book/en/v2/Getting-Started-About-Version-Control"
        li = link_to "Docs", "https://git-scm.com/docs"
        li
          strong = link_to "Simple Guide", "http://rogerdudler.github.io/git-guide/"
        li = link_to "Git Immersion", "http://gitimmersion.com/"
        li
          strong = link_to "CodeSchool", "https://try.github.io/levels/1/challenges/1"
        li = link_to "SO practical guide", "http://stackoverflow.com/questions/315911/git-for-beginners-the-definitive-practical-guide"
        li = link_to "Git Cheatsheet", "http://ndpsoftware.com/git-cheatsheet.html"
        li = link_to "Explain git with D3 (tree management)", "http://onlywei.github.io/explain-git-with-d3"

  section 
    h2 Sources
      ul
        li Tanenbaum, "Modern Operating Systems", 4th Ed. Sección 1.2.

