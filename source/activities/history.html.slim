---
title: Evolución de los sistemas operativos
layout: activity
---

article

  h1 Evolución de los sistemas operativos

  section.top
    p Usar un computador no siempre fue tan fácil. Los sistemas operativos surgieron como una necesidad para poder utilizar máquinas muy complejas en tiempos que se necesitaba personal muy especializado para poder operarlas. La evolución de los sistemas operativos estuvo, por lo tanto, muy ligada a las características y necesidades particulares de las máquinas disponibles. Resulta difícil hablar de los sistemas operativos sin referirse al mismo tiempo a la evolución del <i>hardware</i>, pues ambos aspectos han avanzado de la mano durante gran parte de la historia.

    p Este artículo describe algunos hitos en la evolución del <i>software</i> que conocemos como <b>sistema operativo</b> y destaca el surgimiento de conceptos que persisten en los sistemas operativos modernos. La división de generaciones es aproximada en cuanto a años, y esta guiada principalmente por los hitos que marcaron al <i>hardware</i>. 


  section
    h3 Prehistoria de sistema operativos
    /  --------
    div La primera máquina a la que se puede llamar un <i>computador digital de propósito general</i> fue diseñada por el matemático inglés <a href="https://en.wikipedia.org/wiki/Charles_Babbage">Charles Babbage (1791-1871)</a>, quien diseñó una máquina mecánica <i>digital</i> (digital&colon; capaz de trabajar con dígitos), conocida como la <a href ="https://en.wikipedia.org/wiki/Analytical_Engine"><i>analytical engine</i></a>, o <i>máquina de Babbage</i>. Si bien desarrolló todos los planos, nunca pudo terminar de construirla.
    br

    div style="display:inline-block; width=50px; vertical-align:middle; border:none; text-align:center;"
      div 
        img src='/images/figures/00-babbage.jpg' width="20%"  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
        img src='/images/figures/00-babbage-analytical.jpg' width="25%" 
      div style="font-size:14px; border:none;" <i>Charles Babbage (1791-1871) and the Analytical Engine</i>. Esta reconstrucción fue hecha a partir de los diseños de Babbage.
    br
    br

    div La máquina de Babbage, sin embargo, no tenía ningún tipo de <i>software</i>. La máquina podía ser &quot;programada&quot; (un concepto nuevo para la época) mediante tarjetas perforadas, método que ya se usaba para configurar máquinas en la industria textil. <a href="https://en.wikipedia.org/wiki/Ada_Lovelace">Ada Lovelace</a>, matemática, escribió un conjunto de notas que describían un procedimiento para calcular una secuencia de números de Bernoulli usando la máquina de Babbage. Se considera este documento como el primer programa desarrollado para una máquina computacional, y a Ada Lovelace como <i>la primera programadora</i>. El <a href="http://www.adaic.org/">lenguaje de programación Ada</a> fue nombrado en su honor.
    br

    div style="display:inline-block; width=50px; vertical-align:middle; border:none; text-align:center;"
      div
        img src='/images/figures/00-AdaLovelace.jpg' width="20%" &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
        img src='/images/figures/00-AdaLovelace-algorithm.jpg' width="40%" 
      div style="font-size:14px; border:none;" <i>Ada Lovelace (1815-1852) y el primer algoritmo para una máquina de cómputo. Ada falleció a los 36 años de cáncer uterino.</i>
    br
    br

  section
    h3 Primera Generación (1945-55): Tubos de vacío

    p Posteriormente al trabajo de Babbage, el desarrollo de máquinas programables quedó relegado al ámbito de la investigación científica, sin grandes aplicaciones prácticas. Como ha ocurrido con tantos otros inventos, fue el periodo de la Segunda Guerra Mundial el que vino a reimpulsar el interés en este tipo de máquinas.

    p Se empezaron a desarrollar las primeras máquinas electrónicas, como el <a href="https://en.wikipedia.org/wiki/Z3_(computer)">Z3</a> de Konrad Zuse (1941), y la máquina de <a href="https://en.wikipedia.org/wiki/Atanasoff%E2%80%93Berry_computer">Atanasoff-Berry</a> (1942). El flujo de cómputo de estas máquinas era controlado por <i>switch electrónicos</i> (<i>relay</i>), construidos mediante <i>tubos de vacío</i> (<i>vacuum tube</i>). Al estar compuestas por cientos o miles de estos tubos, no era extraño que uno o varios fallaran durante la operación. Algunas de estas máquinas eran programables, si bien no todas eran de &quot;propósito general&quot; ó <a href="https://en.wikipedia.org/wiki/Turing_completeness"><i>Turing-complete</i></a>.

    p En 1944, un grupo de científicos en Bletchley Park, Inglaterra, entre los que se encontraba Alan Turing, construyó el computador <a href="https://en.wikipedia.org/wiki/Colossus_computer">Colossus</a>, cuyo modelo más conocido, el Colossus Mark 2, utilizaba 2400 tubos de vacío. Este computador, si bien, tampoco era <i>Turing-complete</i> (lo que demuestra que no basta tener a Alan Turing para ser <i>Turing-complete</i>) ya que fue diseñado para una tarea criptográfica particular, sí era programable mediante cintas de papel. Fue importante en el proceso de decriptación del criptosistema alemán Lorenz.

    div style="display:inline-block; width=50px; vertical-align:middle; border:none; text-align:center;"
      div
        img src='/images/figures/00-colossus.jpg' width="60%" 
      div style="font-size:14px; border:none;" <i>Colossus Mark 2 @ Bletchley Park. Reconstrucción.</i>
    br
    br

    p En 1946, William Mauchley y J. Presper Eckert construyeron, en la Universidad de Pennsylvania uno de los primeros computadores programables de propósito general: el <a href="https://en.wikipedia.org/wiki/ENIAC">ENIAC</a> (<i>Electronic Numerical Integrator and Computer</i>). Poseía 20000 tubos de vacío, pesaba 27 toneladas, ocupaba 167m<sup>2</sup> y consumía 150kW de electricidad. Su dispositivo de entrada era un lector de tarjetas perforadas y su salida era un perforador de tarjetas (<a href="https://en.wikipedia.org/wiki/Tabulating_machine">IBM 405</a>). Poseía un <i>clock</i> de 100kHz, y utilizaba 20 registros de 10 dígitos binarios. No existía un lenguaje de programación, ni siquiera <i>assembler</i>, de manera que toda la computación era descrita en las tarjetas perforadas mediante código de máquina.

    div style="display:inline-block; width:100%; vertical-align:middle; border:none; text-align:center;"
      div
        img src='/images/figures/00-eniac-programming.jpg' width="45%" &nbsp; &nbsp; &nbsp; &nbsp; 
        img src='/images/figures/00-ENIAC.jpg' width="40%" 
      div style="font-size:14px; border:none;" <i>ENIAC (fragmento) @ School of Engineering and Applied Science, University of Pennsylvania.</i>
    br
    br


  section 
    h3 Segunda Generación (1955-65): Transistores y Sistemas <i>Batch</i>

    p La creación de los transistores en los años 1950 revolucionó la construcción de los dispositivos electrónicos reduciendo drásticamente las tasas de falla respecto al <i>hardware</i> construido con tubos de vacío y aumentando la velocidad de respuesta. Se empezaron a construir grandes computadores basados en transistores, conocidas como <b><i>mainframes</i></b>. Debido a su costo de construcción, un computador de este tipo era solamente accesible para grandes corporaciones, gobiernos y universidades.

    p La operación de un <i>mainframe</i> requería la colaboración de varios actores. Un <i>mainframe</i> ejecuta <b><i>jobs</i></b> (trabajos), que consisten en el código de un programa, o una secuencia de programas. Los programas se ingresan mediante tarjetas perforadas y se escriben en lenguaje <i>assembler</i>. En 1953, <a href="https://en.wikipedia.org/wiki/John_Backus">John W. Backus</a>, de IBM, propone una alternativa para hacer más práctica la descripción de programas en lugar de <i>assembler</i> y desarrolla el <i>FORmula TRANslating system</i>, conocido como lenguaje <b>FORTRAN</b>, junto con una herramienta para hacer la traducción hacia <i>assembler</i> llamada <b>compilador</b>. Este trabajo le otorgaría el <a href="https://amturing.acm.org/award_winners/backus_0703524.cfm">Turing Award en 1977</a>.

    p Un programa escrito en FORTRAN sobre tarjetas perforadas es entregado como <i>input</i> a un lector de tarjetas. El lector de tarjetas escribe sobre una cinta que se entrega a la máquina principal, la cual ejecuta las instrucciones, proceso que podía tardar horas dependiendo de la complejidad del cómputo, y escribe el resultado sobre otra cinta de salida. La cinta de salida es leída por otro dispositivo capaz de imprimir el contenido de la cinta a un papel. En ese momento termina la ejecución del <i>job</i>.

    p Notemos que durante el tiempo que un dispositivo está leyendo las tarjetas perforadas, tanto el dispositivo procesador como el dispositivo de salida no están haciendo ningún trabajo útil. Dado el costo del equipamiento era poco conveniente tener estas unidades en espera mientras se traduce una tarjeta perforada a una cinta magnética. Es por esto que se desarrollaron soluciones como el sistema de procesamiento <b><i>batch</i></b>, o <i>procesamiento por lotes</i>. En este modelo, un programador entrega sus tarjetas perforadas a un operador (otra persona) que se dedica a ingresar las tarjetas a una unidad lectora de tarjetas (<a href="https://en.wikipedia.org/wiki/IBM_1402">IBM 1402</a>). Cuando hay una cantidad suficiente de trabajos, el operador toma la cinta de salida y la traslada (físicamente) a un dispositivo procesador como el <a href="https://en.wikipedia.org/wiki/IBM_1401">IBM 1401</a> (3 registros, <i>word</i> de 6-bit con codificación BCD) o el más poderoso <a href="https://en.wikipedia.org/wiki/IBM_7090">IBM 7094</a> (7 registros, <i>word</i> de 36-bit, y espacio de direcciones de 15-bit: 32768 <i>words</i>). El operador carga un primer programa (algo similar a un sistema operativo) que prepara al computador para leer una serie de <i>jobs</i> desde la cinta. Mientras el dispositivo procesador realiza las labores de cómputo, el IBM 1402 podía seguir leyendo el siguiente conjunto de tarjetas. La salida del dispositivo procesador iba a una cinta magnética de salida. El operador nuevamente debe tomar esta cinta, llevarla a un dispositivo impresor (<a href="https://en.wikipedia.org/wiki/IBM_1403">IBM 1403</a>) que transfiera el contenido de la cinta magnética a papel de manera <i>offline</i>. Esto es, no conectado al dispositivo procesador.

    div style="display:inline-block; width=50px; vertical-align:middle; border:none; text-align:center;"
      div
        img src='/images/figures/00-ibm1401.jpg' width="30%" &nbsp; &nbsp; &nbsp; &nbsp; 
        img src='/images/figures/00-ibm7094.jpg' width="30%" 
      div style="font-size:14px; border:none;" <i>Izquierda: IBM1402 (card reader), IBM1401 (processing), IBM1403 (printer). Derecha: IBM7094.</i>
    br
    div style="display:inline-block; width=50px; vertical-align:middle; border:none; text-align:center;"
      div
        img src='/images/figures/00-batch-manual.png' width="60%"
      div style="font-size:14px; border:none;" <i>Procesamiento por lotes (batch)</i>
    br
    br

    p Este tipo de computadores se usó principamente para cómputo científico y de ingeniería. Los programas que permitían a estos computadores procesar secuencialmente una cantidad de <b>jobs</b> fueron algunos de los primeros en cumplir la tarea de un sistema operativo, como <b>FMS</b> (<i>FORTRAN Monitor System</i>, básicamente un compilador de FORTRAN), y el sistema del IBM 7094, <b>IBSYS</b>.


    div style="display:inline-block; width:100%; vertical-align:middle; border:none; text-align:center;"
      div
        img src='/images/figures/00-ibm-1620.jpg' width="34%" 
      div style="font-size:14px; border:none;" <i>Un <a href="https://en.wikipedia.org/wiki/IBM_1620"><b>IBM 1620</b></a>, como el que está en el DCC. Utiliza <i>words</i> codificados en BCD, y era capaz de almacenar hasta 20000 digitos. No poseía ALU. Utilizaba tablas de 100 dígitos para efectuar sumas y restas, y una tabla de 200 dígitos para multiplicaciones. La división se efectuaba mediante subrutinas de software. Tenía un clock 1MHz, y tiempo de acceso a memoria de 20usec.</i>
    br
    br



  section
    h3 Tercera Generación (1965-1980): Circuitos Integrados y Multiprogramación

    p En los años 1960s, los <i>mainframes</i> de <a href="https://en.wikipedia.org/wiki/IBM"><b>IBM</b></a> (<i>International Business Machines Corporation</i>), la compañía constructora de equipamiento computacional más importante de la época, requerían cada uno un <i>software</i> y periféricos distintos para funcionar, ya que las instrucciones no eran compatibles. Un programa hecho para un modelo debía ser reescrito ante la introducción de un nuevo modelo de <i>hardware</i>. La compañía decide unificar el <i>hardware</i> bajo una familia llamada <a href="https://en.wikipedia.org/wiki/IBM_System/360"><b>System/360</b></a>. Ésta fue la primera línea importante basada en la nueva tecnología de <b>circuitos integrados</b> capaz de integrar grandes cantidades de pequeños transistores, lo que proporcionaba una enorme ventaja precio/rendimiento respecto a los transistores tradicionales.

    h4 OS/360, y la multiprogramación

    p La idea de tener una línea de <i>hardware</i> mutuamente compatible y de propósito general requería un sistema capaz de funcionar en todos los modelos. Este sistema fue el <a href="https://en.wikipedia.org/wiki/OS/360_and_successors"><b><i>OS/360</i></b></a>. El <i>software</i> resultante resultó enormemente grande (millones de líneas de <i>assembler</i>) y complejo de desarrollar, con numerosos <i>bugs</i>, en tiempos en que la ingeniería de software no se desarrollaba como disciplina aún. El director del proyecto <a href="https://en.wikipedia.org/wiki/Fred_Brooks">Fred Brooks</a> describió sus experiencias en el libro <a href="https://en.wikipedia.org/wiki/The_Mythical_Man-Month">&quot;The Mythical Man-Month&quot;</a>, un clásico de la ingeniería de software. Sus contribuciones a esta nueva disciplina le valieron el otorgamiento del <a href="https://amturing.acm.org/award_winners/brooks_1002187.cfm">Turing Award en 1999</a>.

    div style="display:inline-block; width:100%; vertical-align:middle; border:none; text-align:center;"
      div
        img src='/images/figures/00-ibms360.jpg' width="40%" &nbsp; &nbsp; &nbsp; &nbsp;
        img src='/images/figures/00-ibm360.jpg' width="40%"
      div style="font-size:14px; border:none;" <i>IBM360. Primera gran línea en utilizar circuitos integrados</i>
    br
    br

    p A pesar de todos sus defectos, OS/360 fue ampliamente usado, e introdujo algunas ideas clave en los sistemas computacionales. Sistemas como el IBM 7094 eran máquinas que procesaban un trabajo simultáneamente. Si alguna instrucción de ese trabajo requería una lectura de cinta, o alguna operación de I/O, la CPU debía esperar sin hacer nada (<i>idle</i>) hasta que la operación terminase. Los trabajos científicos suelen ser intensivos en cómputo (<i>CPU-bound</i>), por lo que esto no era un problema. Sin embargo las aplicaciones comerciales requerían operaciones de I/O el 80% a 90% de las veces (<i>I/O-bound</i>) por lo que gran parte del tiempo la CPU se encontraba <i>idle</i>.

    p La solución fue dividir el espacio de memoria en regiones, y asignar un espacio distinto a cada <i>job</i>. Se introdujo un mecanismo que permitiera que, cada vez que un <i>job</i> estuviese esperando una operación de I/O, el sistema permitiera que otro <i>job</i> pudiese ocupar la CPU. De esta manera, si hay suficiente <i>jobs</i> en la memoria, sería posible mantener a la CPU trabajando casi el 100% del tiempo. Este mecanismo fue un enorme avance que ocupamos hasta el día de hoy, y se llama <b>multiprogramación</b>.

    p Implementar <b>multiprogramación</b> requiere que cada <i>job</i> pueda funcionar de manera aislada de los demás. Se agregó en el <i>hardware</i> el mecanismo necesario para proveer esta protección y evitar que un <i>job</i> malicioso pudiese leer o escribir en memoria asignada a otro <i>job</i>.

    div style="display:inline-block; width:100%; vertical-align:middle; border:none; text-align:center;"
      div
        img src='/images/figures/00-osmultiprog-opt.svg' width="40%"
      div style="font-size:14px; border:none;" <i><b>Multiprogramación.</b> Múltiples procesos en memoria principal.</i>
    br
    br

    p Una segunda característica introducida fue la integración de los periféricos como el lector de tarjetas, y la automatización de la lectura. De esta manera, una vez que un <i>job</i> terminaba su ejecución, el sistema operativo podía leer el siguiente <i>job</i> que estuviera disponible y cargarlo en la partición libre. Esta técnica se conoce como <b><i>spooling</i></b> (<i>Simultaneous Peripheral Operation On Line</i>). Ya no se necesitaba un dispositivo separado, y un operador que trasladara cintas.

    h4 <i>Timesharing</i> para múltiples usuarios

    p Hasta el momento todo el avance había apuntado a mejorar los sistemas de procesamiento por lotes (<i>batch</i>). El programador entrega sus tarjetas, y espera hasta obtener un resultado. Por supuesto, los programadores también cometían errores y, una vez entregado el programa, debían esperar algunas horas hasta recibir el <i>output</i> que indicara que su código había fallado porque le faltaba un <code>;</code>. Medio día perdido antes de corregir el error y reenviar el <i>job</i>. No había ningún tipo de interactividad con el sistema. Dada la cantidad de usuarios que deseaban utilizar el computador, asignar horas para que cada usuario interactuara directamente y de manera individual con el computador era tremendamente ineficiente, pues el computador pasaba la mayor parte del tiempo <i>idle</i> mientras el usuario ingresaba código. El modelo <i>batch</i> seguía siendo superior. 

    p La siguiente innovación apuntó a mejorar esta situación. Si un usuario escribe código durante un minuto, y luego piensa (o se para, o toma café) durante 20 segundos, se podría permitir a otro usuario que interactuara con el computador durante esos 20 segundos. La misma idea de la multiprogramación, sin embargo los humanos no son tan rápidos para cambiar de posición frente al teclado. Se le asignó entonces un terminal (consola) <i>online</i> a cada usuario: una cantidad de dispositivos con teclado conectados al mismo sistema, y se configuró para que, en cuanto un terminal dejaba de recibir comandos o ejecutar algún trabajo, el sistema pasara a atender al siguiente terminal. De esta manera, si un usuario no estaba interactuando con el computador, el procesador podía atender a otro. Nacieron desde aquí los sistemas de <b><i>timesharing</i></b> ("compartición" de tiempo). 

    p Construir un sistema de <i>timesharing</i> era inviable en los computadores previos a esta época, ya que se requería almacenar el estado de un proceso y recuperar el estado del proceso siguiente (esto se llama <i>context switch</i> o <i>cambio de contexto</i>) lo que podía ser costoso en tiempo. Sin embargo, la tecnología de esos años ya había evolucionado para permitir que este método fuera viable. Los sistemas consultaba alternadamente a cada terminal si éste tenía un comando que ejecutar, lo que se conoce como <i>polling</i>. Un problema, aún no resuelto en estos sistemas, era que si un usuario enviaba un trabajo largo de tipo <i>CPU-bound</i> (una compilación, un cálculo matricial, ordenar miles de registros, &hellip;), los demás usuarios tendrían que esperar hasta que este proceso terminara antes de obtener su espacio (<i>slice</i>) de tiempo. Este problema sería resuelto en los sistema posteriores con la introducción del <b><i>multitasking</i></b> expropiativo (<i>preemptive multitasking</i>) en que los trabajos reciben <i>slices</i> de tiempo definidas para ejecutar antes de entregar el turno forzosamente al siguiente.

    p El primer sistema de propósito general que permitía <b>timesharing</b> fue <a href="http://www.cozx.com/dpitts/ibm7090.html"><b>CTSS</b></a> (<i>Compatible Time Sharing System</i>), desarrollado en MIT en 1961 sobre un IBM 7094. Si bien el problema de protección de datos entre usuarios no estaba resuelto y los usuarios debían tener cuidado de no alterar el trabajo de otros, CTSS introdujo un tipo de interactividad que no había sido posible anteriormente.

    h4 <b>MULTICS</b>: una nube de cómputo del pasado

    p Ante las posibilidades que prometía el <i>timesharing</i> MIT, Bell Labs, y General Electric, deciden crear un sistema que soporte cientos de usuarios. De la misma manera que múltiples casas podían tener acceso a la red eléctrica, en este sistema múltiples usuarios tendrían acceso a tiempo de cómputo (en la actualidad esto se llamaría &quot;Computing Time as a Service&quot;) con tan solo conectarse a este <i>mainframe</i> (una nube de cómputo). El sistema fue bautizado como <a href="http://www.multicians.org/"><b>MULTICS</b></a> (<b>MULT</b>iplexed <b>I</b>nformation and <b>C</b>omputing <b>S</b>ervice).

    p <b>MULTICS</b> tuvo un éxito parcial. Además de ser escrito en PL/I, un lenguaje poco popular y con un compilador deficiente, el proyecto resultó ser sumamente ambicioso para la época (como la máquina de Babbage) y demasiado complejo, lo que demoró el desarrollo al punto que Bell Labs y General Electric abandonaron el proyecto. MIT persistió y el sistema eventualmente fue terminado. Honeywell, la compañía que continuó las operaciones de General Electric en el área de los computadores, lo adquirió y consiguió suficientes clientes para hacerlo viable. No alcanzó mucha popularidad pero su desarrollo tuvo una gran influencia en sus sucesores.

    div style="display:inline-block; width:100%; vertical-align:middle; border:none; text-align:center;"
      div 
        img src='/images/figures/00-multics.jpg' width="25%"
      div style="font-size:14px; border:none;" <i><b>MULTICS.</b> MULTiplexed Information and Computing Service. </i>
    br
    br

    h4 <b>UNIX</b>: una simplificación de MULTICS

    p El desarrollo de la tecnología de transistores en circuitos integrados cada vez más pequeños y confiables (<i>reliable</i>) permitió que se construyeran computadores más pequeños tanto o más poderosos que los de la época. Se les llamó <i>minicomputadores</i> y uno de los más famosos fue el <a href="https://en.wikipedia.org/wiki/PDP-1">PDP-1</a> (<i>Programmed Data Processor</i>) de la compañía <a href="http://gordonbell.azurewebsites.net/digital/timeline/tmlnhome.htm">DEC</a> (<i>Digital Equipment Corporation</i>), competidora de IBM y que fue comprada por Compaq (luego HP) en 1998. El DEC PDP-1 usaba <i>words</i> de 18-bit y soportaba 4096 <i>words</i>, con ciclos de acceso a memoria de 5.35 usec. DEC construyó modelos sucesivos de la línea PDP, no compatibles entre sí, hasta el PDP-16.

    div style="display:inline-block; width:100%; vertical-align:middle; border:none; text-align:center;"
      div 
        a rel="nofollow" class="external free" href="https://www.flickr.com/photos/hiddenloop/307119987/"
          img src='/images/figures/00-PDP-1.jpg' width="40%" &nbsp; &nbsp; &nbsp; &nbsp;
        a rel="nofollow" class="external free" href="https://commons.wikimedia.org/w/index.php?curid=1587539"
          img src='/images/figures/00-PDP-1-panel.jpg' width="40%"          
      div style="font-size:14px; border:none;" <i>DEC PDP-1. Picture by Matthew Hutchinson, <a href="http://creativecommons.org/licenses/by/2.0" title="Creative Commons Attribution 2.0">CC BY 2.0</a></i><br><i>Panel de control. Picture by fjarlq / Matt <a href="http://creativecommons.org/licenses/by/2.0" title="Creative Commons Attribution 2.0">CC BY 2.0</a></i>
    br
    br

    p En Bell Labs, 1969, <a href="https://en.wikipedia.org/wiki/Ken_Thompson">Ken Thompson</a> y <a href="https://en.wikipedia.org/wiki/Dennis_Ritchie">Dennis Ritchie (1941-2011)</a>, dos de los científicos que habían trabajado en MULTICS decidieron desarrollar una versión "reducida" de MULTICS para un PDP-7 que no estaba siendo usado. Esta versión tendría un diseño mucho más simple y en sus inicios soportaba solamente a un usuario (<i>uni-task</i>) en contraposición a MULTICS que era <i>multi-task</i>. Este trabajo fue bautizado como UNICS por <i>UNIplexed Information and Computing Service</i> como un juego de palabras respecto a MULTICS, y finalmente simplificado como <a href="https://people.eecs.berkeley.edu/~brewer/cs262/unix.pdf"><b>UNIX</b></a>.

    p La versión original de UNIX, para el PDP-7 y posteriormente para el PDP-11 estaba escrita en <i>assembler</i>. Fue en este sistema que se decidió reescribirlo en otro lenguaje de más alto nivel. Inicialmente se consideró el lenguaje B, una versión simplificada de BPCL, otro lenguaje ya existente. Sin embargo, B no podía aprovechar todas las características del PDP-11, y se utilizó otro lenguaje desarrollado por Dennis Ritchie: el lenguaje <a href="https://en.wikipedia.org/wiki/C_(programming_language)"><b>C</b></a>, concebido como un sucesor de B. En 1972, Dennis Ritchie reescribe UNIX en el lenguaje C. De esta manera UNIX se convirtió en uno de los primeros sistemas operativos masivos en ser implementado en un lenguaje de mayor nivel que <i>assembler</i>, y el desarrollo de C continuó estando íntimamente ligado al <i>kernel</i> de UNIX. Thompson y Ritchie obtuvieron el <a href="https://amturing.acm.org/award_winners/thompson_4588371.cfm">Turing Award en 1983</a>.
      
    div style="display:inline-block; width:100%; vertical-align:middle; border:none; text-align:center;"
      img src='/images/figures/00-Thompson-Ritchie-2.jpg' width="20%" style="background:none; border:none; box-shadow:none;" &nbsp;
      img src='/images/figures/00-unix.gif' width="20%" style="background:none; border:none; box-shadow:none;" &nbsp;
      img src='/images/figures/00-ThompsonRitchie.jpg' width="20%" style="background:none; border:none; box-shadow:none;"
      img src='/images/figures/00-unix-architecture.gif' width="30%" style="background:none; border:none; box-shadow:none;"
      div style="text-align:center; font-size:14px;" <i>Izquierda: Ken Thompson y Dennis Ritchie. Centro: Libro &quot;The Unix Programming Environment&quot;, que describe los principios de diseño de Unix. Derecha: Ritchie (de pie) y Thompson en un PDP-11. Arquitecture general de UNIX.</i>
    br
    br

    p El código fuente de UNIX estaba disponible públicamente lo que permitió a distintas instituciones y universidades desarrollar su propia versión para sus sistemas, cada uno inspirado en los mismos principios pero incompatibles entre sí. De estas versiones, dos de las más importantes que perduraron fueron la versión comercial de AT&T llamada <a href="https://en.wikipedia.org/wiki/UNIX_System_V"><b>System V</b></a> (1983), y la versión de la Universidad de California en Berkeley, <a href="https://en.wikipedia.org/wiki/Berkeley_Software_Distribution"><b>BSD</b></a> (Berkeley Software Distribution, 1977).

    div style="display:inline-block; width:100%; vertical-align:middle; border:none; text-align:center;"
      img src='/images/figures/00-unixsystemv.jpg' width="20%" style="background:none; border:none; box-shadow:none;" &nbsp;
      img src='/images/figures/00-unixbsd.png' width="20%" style="background:none; border:none; box-shadow:none;" &nbsp;
      div style="text-align:center; font-size:14px;" <i>AT&T's System V, y <b>Beastie</b>, la mascota clásica de los sistemas basados en BSD</i>
    br
    br

    div style="display:inline-block; width:100%; vertical-align:middle; border:none; text-align:center;"
      a href="https://commons.wikimedia.org/w/index.php?curid=1801948"
        img src='/images/figures/00-Unix-history-simple.svg' width="50%" style="background:none; border:none; box-shadow:none;"
      div style="text-align:center; font-size:14px;" <i>Versiones de UNIX, por Eraserhead1, Infinity0, Sav_vas - Levenez Unix History Diagram, Information on the history of IBM&apos;s AIX on ibm.com, CC BY-SA 3.0</i>
    br
    br

    p Bajo esta situación no era posible escribir programas que funcionaran correctamente bajo las distintas versiones de UNIX. Para ello, la IEEE propuso una interfaz estándar de llamadas al sistema (<i>syscalls</i>) conocida como <a href="https://en.wikipedia.org/wiki/POSIX"><b><i>Portable Operating System Interface</i></b></a> ó <b><i>POSIX</i></b>. La X viene del hecho que se tomó la interfaz existente en UNIX como base para la propuesta (es por esto que la mayoría de las llamadas suenan <i>UNIX-like</i>). Al implementar POSIX (o ser &quot;POSIX-conformant&quot;), los sistemas se hicieron más interoperables. Más aún, otros sistemas operativos no basados en UNIX también han implementado POSIX (<a href="https://social.technet.microsoft.com/wiki/contents/articles/10224.posix-and-unix-support-in-windows.aspx">ejemplo</a>).

    h4 GNU, el software libre, y Linux

    p En 1983, todas las versiones de UNIX utilizaban licencias comerciales. En MIT, <a href="https://www.stallman.org/">Richard Stallman</a> inicia el proyecto <a href="https://www.gnu.org/">GNU</a> (<i>GNU is Not UNIX</i>, un acrónimo recursivo) con el objetivo de desarrollar una versión completamente gratuita y de código abierto de un sistema &quot;UNIX-like&quot;. Como parte de su proyecto se definió la <a href="https://www.gnu.org/licenses/gpl.html">GNU General Public License</a>, <b>GPL</b>, se publicó el <a href="https://www.gnu.org/gnu/manifesto.html">GNU Manifesto</a> y se desarrollaron múltiples herramientas como <code>gcc</code> (<i>GNU Compiler Collection</i>), <code>glibc</code> (<i>GNU C Library</i>), <code>coreutils</code> (<i>GNU Core Utilities</i>), <code>binutils</code> (<i>GNU Binary Utilities</i>), <code>bash</code> (<i>GNU Bash Shell</i>), y el entorno de escritorio GNOME (originalmente <i>GNU Network Object Model Environment</i>). Sin embargo el <i>microkernel</i>, denominado <a href="https://www.gnu.org/software/hurd/index.html"><b><i>GNU Hurd</i></b></a> (donde &quot;Hurd&quot; se define como <i>Hird of Unix-Replacing Daemons</i>, y &quot;Hird&quot; como <i>Hurd of Interfaces Representing Depth</i>, y que en el fondo suena similar a <i>herd of GNUs</i>), demoró en ser terminado (aún al año 2018 no hay una versión 1.0).

    p En 1987, <a href="http://www.cs.vu.nl/~ast/">Andrew S. Tanenbaum</a> desarrolló un clon de UNIX llamado <a href="http://www.minix3.org/">MINIX</a> con fines educacionales (POSIX-compliant), un microkernel modular de código abierto con la capacidad de detectar y reemplazar dinámicamente módulos defectuosos. Todo en 13000 líneas de código.

    p En 1991, ante la ausencia de un <i>kernel</i> gratuito de UNIX, y bajo la inspiración de MINIX, <a href="https://en.wikipedia.org/wiki/Linus_Torvalds">Linus Torvalds</a> desarrolla un clon monolítico <a href="https://groups.google.com/forum/#!original/comp.os.minix/dlNtH7RRrGA/SwRavCzVE7gJ">&quot;just for fun&quot;</a>, al cual llama <a href="https://www.kernel.org/"><b><i>Linux</i></b></a> e incluye gran parte de las herramientas desarrolladas por el proyecto GNU. Los puristas suelen denominar al sistema operativo <a href="https://en.wikipedia.org/wiki/GNU/Linux_naming_controversy"><b>GNU/Linux</b></a>, pues se trata de un &quot;kernel Linux con herramientas GNU&quot;, de la misma manera que <b>GNU/Hurd</b> sería un kernel Hurd con herramientas GNU&quot;.

    div style="display:inline-block; width:100%; vertical-align:middle; border:none; text-align:center;"
      img src='/images/figures/00-minix3.jpg' width="20%" style="background:none; border:none; box-shadow:none;" &nbsp;
      img src='/images/figures/00-gnu.png' width="25%" style="background:none; border:none; box-shadow:none;" &nbsp;
      img src='/images/figures/00-linux.jpg' width="30%" style="background:none; border:none; box-shadow:none;"
      div style="text-align:center; font-size:14px;" <i>Rocky Racoon, la mascota de MINIX 3. La cabeza de GNU por Aurelio Heckert. Tux, creado por Larry Ewing, la mascota de Linux.</i>
    br
    br

    div style="display:inline-block; width:100%; vertical-align:middle; border:none; text-align:center;"
      img src='/images/figures/00-linux-os-architecture.png' width="45%" style="background:none; border:none; box-shadow:none;" &nbsp;
      a href="https://commons.wikimedia.org/w/index.php?curid=47075153"
        img src='/images/figures/00-linux-kernel-architecture.svg' width="45%" style="background:none; border:none; box-shadow:none;"
      div style="text-align:center; font-size:14px;" <i>Componentes del sistema operativo Linux, indicando elementos en user space y en kernel space.<br/>Arquitectura simplificada del kernel de Linux, by <a href="//commons.wikimedia.org/wiki/User:ScotXW" title="User:ScotXW">ScotXW</a> <span class="int-own-work" lang="en">Own work</span>, <a href="https://creativecommons.org/licenses/by-sa/4.0" title="Creative Commons Attribution-Share Alike 4.0">CC BY-SA 4.0</a></i>
    br
    br

    p En 1992, Andrew S. Tanenbaum publicó un mensaje en el <i>newsgroup</i> <code>comp.os.minix</code> con el <i>subject</i> &quot;<i>Linux is obsolete</i>&quot;, haciendo referencia a la naturaleza monolítica del recientemente publicado Linux en contraposición a la arquitectura microkernel de MINIX. Este mensaje marcó el inicio de un interesante y clásico debate conocido como <a href="http://www.oreilly.com/catalog/opensources/book/appa.html"><i>Tanenbaum-Torvalds debate</i></a>.


    div style="display:inline-block; width:100%; vertical-align:middle; border:none; text-align:center;"
      a href="https://commons.wikimedia.org/w/index.php?curid=54867596"
        img src='/images/figures/00-ast.jpg' width="20%" style="background:none; border:none; box-shadow:none;" &nbsp;
      img src='/images/figures/00-versus.png' width="20%" style="background:none; border:none; box-shadow:none;" &nbsp;
      a href="https://commons.wikimedia.org/w/index.php?curid=54706023"
        img src='/images/figures/00-linus.jpg' width="20%" style="background:none; border:none; box-shadow:none;"
      div style="text-align:center; font-size:14px;" <i>Andrew S. Tanenbaum (Andy, para los amigos), imagen de <a href="//commons.wikimedia.org/wiki/User:Jantangring" title="User:Jantangring">Jantangring</a>, <a href="https://creativecommons.org/licenses/by-sa/4.0" title="Creative Commons Attribution-Share Alike 4.0">CC BY-SA 4.0</a>.<br/>Linus Torvalds, imagen de <a href="//commons.wikimedia.org/wiki/User:Krd" title="User:Krd">Krd</a>, <a href="https://creativecommons.org/licenses/by-sa/4.0" title="Creative Commons Attribution-Share Alike 4.0">CC BY-SA 4.0</a></i>


    p Con el tiempo se desarrollaron múltiples distribuciones de Linux. Si no está seguro qué distribución de Linux utilizar, <a href="https://www.linuxtrainingacademy.com/choosing-a-linux-distribution/">aquí puede encontrar una guía.

    div style="display:inline-block; width:100%; vertical-align:middle; border:none; text-align:center;"
      /a href="http://futurist.se/gldt/wp-content/uploads/12.10/gldt1210.png"
      a href= href="https://commons.wikimedia.org/w/index.php?curid=2556373"
        img src='/images/figures/00-linux-distributions.svg' width="20%" style="background:none; border:none; box-shadow:none;"
      div style="text-align:center; font-size:14px;"<i> Distribuciones de Linux, by Andreas Lundqvist (initially), Muhammad Herdiansyah (continued), Fabio Loli (continued) - <a rel="nofollow" class="external free" href="http://futurist.se/gldt/">http://futurist.se/gldt/</a> (initially), <a rel="nofollow" class="external free" href="https://github.com/konimex/linuxtimeline">https://github.com/konimex/linuxtimeline</a> (continued), <a rel="nofollow" class="external free" href="https://github.com/FabioLolix/LinuxTimeline">https://github.com/FabioLolix/LinuxTimeline</a> (continued), <a href="www.gnu.org/licenses/fdl-1.3.html" title="GNU Free Documentation License 1.3">GFDL 1.3</a></i>

    br
    br




  section
    h3 Cuarta Generación (1980-Presente): Computadores personales

    p El desarrollo tecnológico de los circuitos integrados llegó al nivel conocido como <b>VLSI</b> (<i>Very Large Scale Integration</i>), capaz de integrar hasta 1 millón de transistores en un chip de 1cm<sup>2</sup>, lo que permitía hasta 100000 celdas lógicas. Surgieron sistemas computacionales de uso personal denominados <b>microcomputadores</b>, que en principio no eran tecnológicamente muy superiores al PDP-11, pero a un precio notablemente inferior.

    h4 Intel 8080, CP/M y el despegue de los microcomputadores

    p En 1974, Intel presenta el chip <a href="https://en.wikipedia.org/wiki/Intel_8080">Intel 8080</a>, una CPU de propósito general de 8-bit con un <i>clock</i> de 2MHz, sucesora del <a href="https://en.wikipedia.org/wiki/Intel_4004">4004</a> y el <a href="https://en.wikipedia.org/wiki/Intel_8008">8008</a>, los primeros microprocesadores del mercado. Fue parte del popular <a href="https://en.wikipedia.org/wiki/Altair_8800">MITS Altair 8800</a>, que dió inicio a la era de los microcomputadores.

    div style="display:inline-block; width:100%; vertical-align:middle; border:none; text-align:center;"
      img src='/images/figures/00-intel-8080.jpg' width="20%" style="background:none; border:none; box-shadow:none;" &nbsp; &nbsp; &nbsp; &nbsp;
      img src='/images/figures/00-altair.jpg' width="25%" style="background:none; border:none; box-shadow:none;"
      div style="text-align:center; font-size:14px;" <i>Intel 8080, y MITS Altair 8800</i>
    br
    br

    p Intel deseaba un sistema operativo propio para el Intel 8080, por lo cual <a href="https://en.wikipedia.org/wiki/Gary_Kildall">Gary Kildall</a> construyó un sistema operativo basado en disco (contenido en un <i>floppy disk</i> de 8&quot;) conectado al 8080, y llamado <a href="http://www.digitalresearch.biz/CPM.HTM">CP/M</a> (<i>Control Program for Microcomputers</i>). CP/M era un sistema <i>single-task</i> de 8-bit y capaz de utilizar hasta 64 KB de memoria. Si bien el sistema fue adoptado por Intel, no le veían mucho futuro a un sistema operativo residente en disco, y los derechos quedaron en manos de Gary Kildall quien formó la compañía <a href="http://www.digitalresearch.biz/">Digital Research Inc.</a> para desarrollar y vender CP/M. Digital Research adaptó CP/M para diversos microcomputadores usando el Intel 8080, pero también para otros microprocesadores de la época como el <a href="https://en.wikipedia.org/wiki/Zilog_Z80">Zilog Z80</a>, dominando el mercado durante unos 5 años. En este periodo se desarrollaron versiones <i>multitasking</i> y de 16-bit. Aplicaciones que surgieron bajo CP/M fueron <A href="https://en.wikipedia.org/wiki/WordStar">WordStar</a> (procesador de texto), <a href="https://en.wikipedia.org/wiki/DBase">dBase</a> (base de datos), <a href="https://en.wikipedia.org/wiki/Multiplan">Multiplan</a> (planilla de cálculo), y <a href="https://en.wikipedia.org/wiki/Turbo_Pascal">Turbo Pascal</a> (IDE y compilador para Pascal).

    div style="display:inline-block; width:100%; vertical-align:middle; border:none; text-align:center;"
      img src='/images/figures/00-GaryKildall.jpg' width="15%" style="background:none; border:none; box-shadow:none;" &nbsp; &nbsp; &nbsp; &nbsp;
      img src='/images/figures/00-cpm-console.png' width="20%" style="background:none; border:none; box-shadow:none;" &nbsp; &nbsp; &nbsp; &nbsp;
      img src='/images/figures/00-wordstar.jpg' width="20%" style="background:none; border:none; box-shadow:none;" &nbsp; &nbsp; &nbsp; &nbsp;
      img src='/images/figures/00-cpm-advertisement.png' width="20%" style="background:none; border:none; box-shadow:none;" &nbsp; &nbsp; &nbsp; &nbsp;
      div style="text-align:center; font-size:14px;" <i>Gary Killdall, Consola de CP/M, Wordstar, y una publicidad promocional de CP/M</i>
    br
    br

    h4 IBM PC y la masificación de Microsoft DOS

    p IBM, por su parte, que había dominado el mercado de los <i>mainframes</i> se estaba quedando atrás en el nuevo mercado de los <i>microcomputadores</i> y empezó a desarrollar su propia versión: el <a href="https://en.wikipedia.org/wiki/IBM_Personal_Computer"><b><i>IBM Personal Computer</i></b></a> (<b>IBM PC</b>) basado en el <a href="https://en.wikipedia.org/wiki/Intel_8088">Intel 8088</a> de 16-bit, 4.77MHz de <i>clock</i>, y hasta 256 kB de RAM. En 1980, IBM contactó a una pequeña compañía de nombre <a href="https://en.wikipedia.org/wiki/History_of_Microsoft"><b>Microsoft</b></a> fundada por <a href="https://en.wikipedia.org/wiki/Bill_Gates">Bill Gates</a> y <a href="https://en.wikipedia.org/wiki/Paul_Allen">Paul Allen</a> en 1975, y conocida por desarrollar un intérprete del lenguaje <a href="https://en.wikipedia.org/wiki/BASIC">BASIC</a> para el popular Altair 8800. Sin embargo, IBM deseaba un sistema operativo completo, y Bill Gates les sugirió contactar a Digital Research, que con CP/M era el dominador absoluto de los sistemas operativos. La negociación con Digital Research fracasó al no llegar a un NDA (<i>Non-Disclosure Agreement</i>) respecto al IBM PC. Si bien las <a href="https://forwardthinking.pcmag.com/software/286148-the-rise-of-dos-how-microsoft-got-the-ibm-pc-os-contract">razones no son claras</a>, se dice que Gary Kildall no quiso reunirse con IBM, que envió a Dorothy McEwen (co-fundadora de Digital Research, y su esposa) en su lugar, que no estuvo de acuerdo con el espacio de tiempo que se le otorgaba para desarrollar una versión de CP/M para el Intel 8088 (que sería el futuro <a href="https://en.wikipedia.org/wiki/CP/M-86">CP/M-86</a>, ya que el set de instrucciones era Intel 8086), o que simplemente no se llegó a acuerdo económico. Varios artículos discuten cómo ocurrió esta curiosa serie de eventos. (<a href="https://spectrum.ieee.org/computing/software/did-bill-gates-steal-the-heart-of-dos">1</a>), (<a href="https://www.wired.com/2012/08/ms-dos-examined-for-thef/">2</a>). Gary Kildall murió en 1994, a los 52 años, bajo circunstancias que tampoco quedaron totalmente claras (<a href="http://www.faqs.org/faqs/CPM-faq/">3</a>), (<a href="https://dfarq.homeip.net/gary-kildalls-death-investigation/">4</a>)

    p Lo cierto es que IBM regresó con Microsoft para solicitar el desarrollo de un sistema operativo para su IBM PC. Bill Gates adquirió un clon de CP/M de una compañía más pequeña aún llamada <a href="https://en.wikipedia.org/wiki/Seattle_Computer_Products"><b>Seattle Computer Products</b></a> (SCP). SCP también se encontraba construyendo un sistema basado en el 8088, y ante la demora en la salida de CP/M-86, uno de sus empleados, <a href="https://en.wikipedia.org/wiki/Tim_Paterson">Tim Paterson</a> había desarrollado en 4 meses un clon llamado <b>QDOS</b> (<i>Quick and Dirty Operating System</i>) que fue renombrado a <a href="https://en.wikipedia.org/wiki/86-DOS">86-DOS</a>. Microsoft logró un acuerdo con SCP para distribuir, y posteriormente adquirir todos los derechos sobre 86-DOS llamándolo <a href="https://en.wikipedia.org/wiki/MS-DOS"><b><i>MicroSoft Disk Operating System</i></b></a> (<b>MS-DOS</b>). Este sistema operativo, junto al intérprete de BASIC fueron ofrecidos a IBM. Microsoft contrató a Tim Paterson para realizar algunas modificaciones y finalmente el IBM PC fue lanzado junto al sistema operativo renombrado por IBM como <b>PC-DOS</b>. Debido a que, en el fondo, PC-DOS había nacido como un clon de CP/M y para evitar problemas legales, IBM eventualmente distribuyó su IBM PC también con CP/M-86. Sin embargo, CP/M-86 había llegado 6 meses tarde y en ese tiempo la popularidad de PC-DOS creció rápidamente.

    div style="display:inline-block; width:100%; vertical-align:middle; border:none; text-align:center;"
      a href="https://commons.wikimedia.org/w/index.php?curid=6692144"
        img src='/images/figures/00-intel-8088.jpg' width="15%" style="background:none; border:none; box-shadow:none;" &nbsp; &nbsp; &nbsp; &nbsp;
      a href="https://commons.wikimedia.org/w/index.php?curid=9561543"
        img src='/images/figures/00-ibm-pc.jpg' width="20%" style="background:none; border:none; box-shadow:none;" &nbsp; &nbsp; &nbsp; &nbsp;
      a href="https://classicreload.com/pc-dos-4.01.html"
        img src='/images/figures/00-pcdos4.png' width="20%" style="background:none; border:none; box-shadow:none;" &nbsp; &nbsp; &nbsp; &nbsp;
      img src='/images/figures/00-ibm-dos-11.jpg' width="20%" style="background:none; border:none; box-shadow:none;" &nbsp; &nbsp; &nbsp; &nbsp;
      div style="text-align:center; font-size:14px;" <i>Intel 8088, by Konstantin Lanzet - CPU collection Konstantin Lanzet, <a href="http://creativecommons.org/licenses/by-sa/3.0/" title="Creative Commons Attribution-Share Alike 3.0">CC BY-SA 3.0</a><br/>IBM PC 5150, Monitor IBM 5151, y Teclado IBM (1981). By <a href="//commons.wikimedia.org/w/index.php?title=User:Rderijcke&amp;action=edit&amp;redlink=1" class="new" title="User:Rderijcke (page does not exist)">Ruben de Rijcke</a> - <span class="int-own-work" lang="en">Own work</span>, <a href="https://creativecommons.org/licenses/by-sa/3.0" title="Creative Commons Attribution-Share Alike 3.0">CC BY-SA 3.0</a><br/>Pantalla de instalación de PC-DOS 4.0 (click para emulación).<br/>Manual y diskette de instalación de IBM DOS 1.1</i>
    br
    br


    p Microsoft, sin embargo, nunca entregó los derechos sobre MS-DOS, sino que solo entregó una licencia a IBM. El IBM PC fue tremendamente exitoso y, salvo la componente de arranque <a href="https://en.wikipedia.org/wiki/BIOS"><b>BIOS</b></a> (<i>Basic Input/Output System</i>) que era propietaria de IBM, el resto era una <a href="http://forwardthinking.pcmag.com/pc-hardware/286065-why-the-ibm-pc-had-an-open-architecture">arquitectura abierta</a> (a diferencia de Apple que patentó componentes cruciales de su <i>hardware</i>). Esto permitió que rápidamente otros manufacturadores empezaran a desarrollar clones, popularmente llamados &quot;<a href="https://en.wikipedia.org/wiki/IBM_PC_compatible">IBM-compatible</a>&quot;. Dado que el sistema operativo no era propiedad de IBM, cada constructor podía obtener una licencia de MS-DOS desde Microsoft para incluirla en su propio sistema. Esto posicionó a Microsoft como líder en el mercado de los sistemas operativos, y desplazó definitivamente a CP/M y Digital Research Inc. <a href="http://www.digitalresearch.biz/CPM.HTM">Años después</a>, en 1996, Digital Research Inc., en ese tiempo parte de la empresa <a href="http://www.caldera.com/">Caldera Inc.</a> (y previamente de Novell), demandaría a Microsoft por prácticas anti-competitivas respecto a <a href="https://en.wikipedia.org/wiki/DR-DOS#6.0">DR-DOS</a>, un sucesor de CP/M-86, y en favor de sus productos MS-DOS, Windows 95 y Windows 98. Entre los argumentos reflotó la acusación que los sistemas de Microsoft, en el fondo, poseían código originado de CP/M que había sido clonado ilegalmente por SCP. Aún hasta <a href="http://www.scirp.org/journal/PaperInformation.aspx?PaperID=46362">2014</a> y <a href="http://file.scirp.org/pdf/JCC_2016101814562366.pdf">2016</a> surgieron artículos académicos que investigaban si hubo realmente copia. El año 2000 se llegó a un acuerdo bajo el cual Microsoft Corp. compensó parcialmente a Caldera Inc. Parte del legado de CP/M en MS-DOS incluía el formato de nombre de archivos de 8.3 (8 caracteres para el nombre, y 3 para la extensión), y la manera de nombrar las unidades de disco como <code>A:</code>, <code>B:</code>, <code>C:</code>, &hellip;

    div style="display:inline-block; width:100%; vertical-align:middle; border:none; text-align:center;"
      img src='/images/figures/00-msdos-logo.jpg' width="20%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"
      img src='/images/figures/00-msdos.png' width="35%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"
      div style="text-align:center; font-size:14px;" <i>MS-DOS</i>
    br
    br

    p En 1983, IBM lanza el IBM PC/AT, con el chip Intel 80286, de 16-bit, con <i>clock</i> de 6MHz, y con modo de protección para soportar <i>multitasking</i>. MS-DOS continuó siendo el sistema operativo de preferencia de los consumidores, distribuido como PC-DOS en las máquinas originales de IBM. Este soporte continuó con la introducción de los Intel 80386 (32-bit, 12 a 40MHz, 1985) y 80486 (32-bit, 16 a 100MHz, 1989). MS-DOS también evolucionó incorporando características de UNIX como <i>multitasking</i> y soporte de nombres largos de archivos. Eventualmente Microsoft produjo su propia implementación de UNIX llamada <a href="https://en.wikipedia.org/wiki/Xenix">Xenix</a>.


    h4 Doug Engelbart y la interactividad: &quot;The Mother of All Demos&quot;

    p Aún a inicios de los años 1980s, tanto MS-DOS como CP/M-86 seguían interactuando con el usuario a través de líneas de comando y teclado. Esto cambiaría debido a una investigación en interacción humano-computador que venía siendo desarrollada desde los años 1960s por <a href="https://en.wikipedia.org/wiki/Douglas_Engelbart">Doug Engelbart</a> (1925-2013) en el Stanford Research Institute (SRI), quien creó las <b>GUI</b> (<i>Graphical User Interface</i>) como medio de interactuar con el computador mediante un conjunto de abstracciones gráficas como ventanas, íconos, menúes, hipertexto (sí, hipertexto, ahí quedaste Tim Berners-Lee #conrespeto), y un novedoso dispositivo llamado <i>mouse</i> capaz de controlar un puntero en pantalla. Su trabajo, el sistema <a href="https://en.wikipedia.org/wiki/NLS_(computer_system)"><b>NLS</b></a> (<i>oN-Line System</i>) fue presentado en un evento histórico que se conoció posteriormente como <a href="https://www.youtube.com/watch?v=yJDv-zdhzMY"><i>The Mother of All Demos</i></a> (vale la pena verlo con los ojos de 1968). Tuvo tanta influencia que este tipo de interfaces se empezó a usar en el centro de investigación de <a href="http://www.parc.com/">Xerox PARC</a> (<i>Xerox Palo Alto Research Center</i>) y en particular en su computador <a href="https://en.wikipedia.org/wiki/Xerox_Alto">Xerox Alto</a>. El trabajo de Doug Engelbart le otorgaría el <a href="https://amturing.acm.org/award_winners/engelbart_5078811.cfm">Turing Award 1997</a> por su visión del futuro de la computación interactiva.

    div style="display:inline-block; width:100%; vertical-align:middle; border:none; text-align:center;"
      img src='/images/figures/00-xerox-alto.jpg' width="20%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"
      img src='/images/figures/00-mouse.jpg' width="20%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"
      img src='/images/figures/00-xerox-gui.jpg' width="20%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"
      img src='/images/figures/00-maad.jpg' width="20%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"
      div style="text-align:center; font-size:14px;" <i>Xerox Alto (1974). Mouse (1968). Xerox Smalltalk environment (1976). Douglas Engelbart en The Mother of All Demos (1968)</i>
    br
    br

    h4 Apple y la evolución de MacOS

    p No sería, hasta el desarrollo del <a href="https://en.wikipedia.org/wiki/Apple_Lisa">Apple Lisa</a> (1983) y el <a href="https://en.wikipedia.org/wiki/Compact_Macintosh">Apple Macintosh</a> (1984), los primeros computadores personales en incluir una interfaz gráfica, que las GUIs se harían populares al acercar el uso del computador al público general e incorporar el concepto de <i>user friendliness</i>. Se dice que Steve Jobs, co-fundador de <a href="http://apple.com/">Apple Computer Inc.</a> habría tenido la idea incorporar la GUI a su próximo computador (Lisa) luego de una visita que realizó en 1979 a Xerox PARC, sin embargo hay <a href="https://web.stanford.edu/dept/SUL/sites/mac/parc.html">testimonios</a> que indican que el plan de incorporar una GUI al Apple Lisa existía <a href="http://www.mac-history.net/computer-history/2012-03-22/apple-and-xerox-parc">de manera previa</a> a dicha visita (Steve Jobs y los ingenieros de Apple tenían suficientes motivos para visitar Xerox PARC, en cualquier caso, y la visita efectivamente ocurrió). En cualquier caso el Apple Macintosh fue ampliamente popular en particular en el ámbito del diseño gráfico.

    div style="display:inline-block; width:100%; vertical-align:middle; border:none; text-align:center;"
      img src='/images/figures/00-lisa-macintosh.jpg' width="25%" style="background:none; border:none; box-shadow:none; vertical-align:middle;" &nbsp; &nbsp; &nbsp;
      img src='/images/figures/00-macintosh-gui.jpg' width="25%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"
      div style="text-align:center; font-size:14px;" <i>Apple Lisa (1983), y Apple Macintosh (1984). Macintosh GUI (1984)</i>
    br
    br


    p Hasta 1999, el sistema operativo de los computadores de Apple (llamado ahora &quot;<a href="https://en.wikipedia.org/wiki/Classic_Mac_OS">classic mac OS</a>&quot;) se trataba de un <i>kernel</i> monolítico desarrollado para chips Motorola 68k. Su última versión fue el <a href="https://en.wikipedia.org/wiki/Classic_Mac_OS">Mac OS 9</a>. El próximo <i>kernel</i> toma como punto de origen a <a href="http://www.cs.cmu.edu/afs/cs/project/mach/public/www/mach.html">Mach</a>, una reimplementación de BSD Unix con arquitectura de microkernel desarrollado en Carnegie Mellon University. La compañía <a href="https://web.archive.org/web/19970412194822/http://www.next.com/">NeXT</a>, fundada por Steve Jobs durante su periodo fuera de Apple, había desarrollado el sistema operativo <a href="https://en.wikipedia.org/wiki/NeXTSTEP">NeXTSTEP</a> a partir de Mach, y escrito en C y Objective-C. Cuando Apple adquirió NeXT (y a Steve Jobs de regreso), se introdujo el <i>kernel</i> híbrido <a href="http://opensource.apple.com/source/xnu">XNU</a> (<i>XNU is Not Unix</i>) combinando ideas del <i>kernel</i> Mach 2.5 y de UNIX BSD 4.3. Se incorporó código del kernel de NeXTSTEP (y su siguiente versión OPENSTEP), y del proyecto <a href="https://www.freebsd.org/">FreeBSD</a> una implementación opensource de BSD UNIX. Con base en el kernel XNU se construyó el sistema operativo que se conoce como <a href="https://opensource.apple.com/">Darwin</a> (opensource y POSIX-compliant), que junto con herramientas propietarias de Apple (como Finder y la interfaz gráfica Aqua) conformaron el sistema operativo <a href="https://www.apple.com/macos">Mac OS X</a>.

    div style="display:inline-block; width:100%; vertical-align:middle; border:none; text-align:center;"
      img src='/images/figures/00-darwinos.jpg' width="20%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"
      img src='/images/figures/00-macosx.jpg' width="20%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"
      img src='/images/figures/00-osx-logo.png' width="20%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"
      a href="https://commons.wikimedia.org/w/index.php?curid=879049"
        img src='/images/figures/00-macosx-architecture.svg' width="30%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"
      div style="text-align:center; font-size:14px;" <i>Darwin OS mascot (mezclando elementos de Apple y BSD. Mac OS X 10.13 High Sierra. OS X logo.<br/>Arquitectura de OS X, by <a href="https://it.wikipedia.org/wiki/Utente:Sassospicco" class="extiw" title="it:Utente:Sassospicco">Utente:Sassospicco</a> - Derivated work from <a href="//commons.wikimedia.org/wiki/File:MacOSXArchitecture.svg" title="File:MacOSXArchitecture.svg">Image:MacOSXArchitecture.svg</a>, <a href="http://creativecommons.org/licenses/by-sa/3.0/" title="Creative Commons Attribution-Share Alike 3.0">CC BY-SA 3.0</a></i>
    br
    br

    h4 Microsoft y la evolución de Windows


    p Fuertemente influenciado por el éxito del Apple Macintosh, a inicios de 1980s Microsoft planeaba un sucesor para MS-DOS que tuviera su propia GUI. Su primer intento fue un sistema administrador de ventanas llamado <a href="https://en.wikipedia.org/wiki/Windows_1.0">Windows 1.0</a> (1985) que funcionaba como una aplicación sobre MS-DOS. La versión que consiguió mayor adopción fue Windows <a href="https://en.wikipedia.org/wiki/Windows_3.1x">3.11</a>, para sistemas de 16-bit. Fue en 1995, con el lanzamiento de <a href="https://en.wikipedia.org/wiki/Windows_9x">Windows 95</a> y luego Windows 98, que se incorporó código para aprovechar las nuevas CPU de 32-bit, aun cuando parte del sistema operativo debía soportar aún aplicaciones de 16-bit por retrocompatibilidad. MS-DOS seguía siendo usado para iniciar el sistema y como soporte subyacente para aplicaciones antiguas.

    p Ya desde 1987, Microsoft había trabajado en conjunto con IBM para construir un sistema operativo con GUI. Este sistema se conoció como <a href="https://en.wikipedia.org/wiki/OS/2">OS/2</a>, sin embargo nunca alcanzó gran popularidad ante Macintosh y los mismos Windows 9x. Eventualmente Microsoft tomó parte del trabajo desarrollado para OS/2 y reimplementó Windows usando código completamente de 32-bit. Este nuevo sistema se llamó <a href="https://en.wikipedia.org/wiki/Windows_NT"><b>Windows NT</b></a> (<i>Windows New Technology</i>), mientras OS/2 fue eventualmente abandonado por IBM.

    div style="display:inline-block; width:100%; vertical-align:middle; border:none; text-align:center;"
      a href="https://commons.wikimedia.org/w/index.php?curid=2242280"
        img src='/images/figures/00-windows-2000-architecture.svg' width="30%" style="background:none; border:none; box-shadow:none; vertical-align:middle;" 
      div style="text-align:center; font-size:14px;" <i>Arquitectura de Windows 2000. By The original uploader was <a href="https://en.wikipedia.org/wiki/User:Grm_wnr" class="extiw" title="wikipedia:User:Grm wnr">Grm wnr</a> at <a href="https://en.wikipedia.org/wiki/" class="extiw" title="wikipedia:">English Wikipedia</a> Later versions were uploaded by <a href="https://en.wikipedia.org/wiki/User:Xyzzy_n" class="extiw" title="en:User:Xyzzy n">Xyzzy n</a> at <a class="external text" href="http://en.wikipedia.org">en.wikipedia</a>. - Transferred from <span class="plainlinks"><a class="external text" href="//en.wikipedia.org">en.wikipedia</a></span> to Commons</i>
    br
    br


    p Windows NT fue desarrollado bajo el concepto de portabilidad. Implementó <i>preemptive multitasking</i>, soporte para múltiples arquitecturas modernas como IA-32, MIPS y DEC-Alpha, soporte para Windows API y POSIX, e introdujo un nuevo sistema de archivos, NTFS. La línea de Windows NT continuó con Windows XP, Windows Vista, Windows 7, Windows 8, y Windows 10. Paralelamente se introdujo una línea para servidores con Windows 2000, Windows Server 2003, Windows Server 2008, Windows Server 2012, y Windows Server 2016.

    div style="display:inline-block; width:100%; vertical-align:middle; border:none; text-align:center;"
      img src='/images/figures/00-windows1-0.png' width="20%" style="background:none; border:none; box-shadow:none; vertical-align:middle;" &nbsp; &nbsp; &nbsp; 
      img src='/images/figures/00-windows3-11.png' width="20%" style="background:none; border:none; box-shadow:none; vertical-align:middle;" &nbsp; &nbsp; &nbsp; 
      img src='/images/figures/00-windowslogos.png' width="20%" style="background:none; border:none; box-shadow:none; vertical-align:middle;" &nbsp; &nbsp; &nbsp; 
      img src='/images/figures/00-windows-10.png' width="20%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"
      div style="text-align:center; font-size:14px;" <i>Microsoft Windows 1.01 (1985). GUI de Windows 3.11 (1992). Evolución de logos de Windows. GUI de Windows 10 (2015)</i>
    br
    br


  section 
    h3 Quinta Generación (1990-Presente): Computadores Móviles

    p Hasta 1993, los dispositivos telefónicos móviles no era más que dispositivos de comunicación que usaban sistemas embebidos, dedicados, para administrar su <i>hardware</i>. El concepto de utilizar estos dispositivos para realizar actividades más allá de la telefonía surgió con los dispositivos conocidos como <b>PDA</b> (<i>Personal Digital Assistant</i>), entre los cuales se encuentra el <a href="https://en.wikipedia.org/wiki/Apple_Newton">Apple Newton</a> que incluía un sistema operativo <a href="https://en.wikipedia.org/wiki/Newton_OS">Newton OS</a> escrito en C++, y con un pionero uso de reconocimiento de escritura manual. Poseía una API para aplicaciones desarrolladas por terceros, sin embargo no obtuvo gran adopción.

    p Talvez el primer dispositivo llamado un <i>smartphone</i> fue el <a href="https://en.wikipedia.org/wiki/IBM_Simon">IBM Simon</a>, con una interfaz de pantalla <i>touch</i> (con stylus) y un sistema operativo <a href="https://en.wikipedia.org/wiki/Datalight#ROM-DOS">ROM-DOS</a>, compatible con MS-DOS y desarrollado por la empresa Datalight. Su batería de una hora de duración no le permitió competir con los nuevos dispositivos.

    div style="display:inline-block; width:100%; vertical-align:middle; border:none; text-align:center;"
      img src='/images/figures/00-apple-newton.jpg' width="20%" style="background:none; border:none; box-shadow:none; vertical-align:middle;" &nbsp; &nbsp; &nbsp; 
      img src='/images/figures/00-ibm-simon.png' width="10%" style="background:none; border:none; box-shadow:none; vertical-align:middle;" &nbsp; &nbsp; &nbsp; 
      div style="text-align:center; font-size:14px;" <i>Apple Newton (1993). IBM Simon (1994)</i>
    br
    br

    h4 Palm, Inc. y el Palm OS

    p Fue en 1997 que la ya extinta compañía <a href="https://en.wikipedia.org/wiki/Palm,_Inc.">Palm, Inc.</a> popularizó los dispositivos PDA mediante su <a href="https://en.wikipedia.org/wiki/PalmPilot">PalmPilot</a>, y su sistema operativo <a href="https://en.wikipedia.org/wiki/Palm_OS">Palm OS 2.0</a> como el primer sistema operativo móvil exitoso. Incorporaba el sistema <i>Graffiti</i> de reconocimiento de escritura manual, y el <i>stack</i> de protocolos TCP/IP para soportar sincronización por red en lugar de cable serial. Palm OS introdujo paulatinamente características modernas acorde a la evolución de los dispositivos como soporte para el <i>stack</i> WiFi (IEEE 802.11), Bluetooh, y desde 2004 con Palm OS 6.0 (Cobalt), un kernel con <i>multitasking</i> y protección de memoria. En 2009, Palm, Inc. intentó ponerse al día en la competencia por el mercado móvil con el desarrollo de <a href="https://en.wikipedia.org/wiki/WebOS"><b>webOS</b></a>. Palm, Inc. sería adquirido por HP al año siguiente y el desarrollo de webOS no se vería impulsado hasta al menos dos años más cuando el código de webOS se publicó de manera abierta. Finalmente HP licencia el uso de webOS a LG para incorporarlo en sus dispositivos <i>smartTV</i>.

    div style="display:inline-block; width:100%; vertical-align:middle; border:none; text-align:center;"
      img src='/images/figures/00-palmpilot.gif' width="20%" style="background:none; border:none; box-shadow:none; vertical-align:middle;" &nbsp; &nbsp; &nbsp; 
      img src='/images/figures/00-palmos.gif' width="15%" style="background:none; border:none; box-shadow:none; vertical-align:middle;" &nbsp; &nbsp; &nbsp; 
      img src='/images/figures/00-palmos-6.jpg' width="15%" style="background:none; border:none; box-shadow:none; vertical-align:middle;" &nbsp; &nbsp; &nbsp; 
      img src='/images/figures/00-webos.jpg' width="20%" style="background:none; border:none; box-shadow:none; vertical-align:middle;" &nbsp; &nbsp; &nbsp; 
      div style="text-align:center; font-size:14px;" <i>Palm Pilot (1997). Palm OS 2.0 (1997). Palm OS 6.0 (2004). LG webOS SmartTV</i>
    br
    br


    h4 Nokia y SymbianOS

    p El éxito de Palm llevó a otros protagonistas de la telefonía móvil como <b>Nokia</b> a co-fundar y posteriormente adquirir completamente a <a href="https://en.wikipedia.org/wiki/Symbian_Ltd.">Symbian Ltd.</a>. El consorcio fundador incluía a <a href="https://en.wikipedia.org/wiki/Psion_(company)">Psion</a>, una compañía que estaba detrás de <a href="https://en.wikipedia.org/wiki/EPOC_(operating_system)">EPOC</a>, un sistema operativo <i>single-user</i> de 32-bit con <i>preemptive multitasking</i> del año 1998, que bajo Symbian se convertiría en <a href="https://en.wikipedia.org/wiki/Symbian_OS"><b>Symbian OS</b></a> cuya primera versión (6.0) fue utilizada en el <a href="https://en.wikipedia.org/wiki/Nokia_9210_Communicator">Nokia 9210 Communicator</a>. Symbian OS corría sobre procesadores <a href="https://en.wikipedia.org/wiki/ARM_architecture">ARM</a>, una arquitectura RISC. En su mejor momento, Symbian OS fue el sistema preferido por manufacturadores como Samsung, Motorola, Sony Ericsson, y principalmente Nokia. Poseía un <i>microkernel</i> llamado <a href="https://en.wikipedia.org/wiki/EKA2">EKA2</a> que soportaba <i>preemptive multithreading</i>, protección de memoria, y <i>scheduling</i> para tareas de tiempo real (<i>RTOS</i>). Poseía un diseño orientado a objetos y estaba escrito en C++. Symbian OS dominó gran parte del mercado de los sistemas operativos móviles hasta su abandono paulatino por Samsung, Sony Ericsson y eventualmente Nokia (que lo reemplazaría por Windows Phone), lo que lo hizo perder terreno ante la irrupción de iOS y Android.

    div style="display:inline-block; width:100%; vertical-align:middle; border:none; text-align:center;"
      img src='/images/figures/00-symbianos.jpg' width="20%" style="background:none; border:none; box-shadow:none; vertical-align:middle;" &nbsp; &nbsp; &nbsp; 
      img src='/images/figures/00-nokia-9210.jpg' width="20%" style="background:none; border:none; box-shadow:none; vertical-align:middle;" &nbsp; &nbsp; &nbsp; 
      img src='/images/figures/00-nokia-c601.jpg' width="20%" style="background:none; border:none; box-shadow:none; vertical-align:middle;" &nbsp; &nbsp; &nbsp; 
      div style="text-align:center; font-size:14px;" <i>SymbianOS. Nokia 9210 Communicator (2000). Nokia C6-01 con Symbian 9.5</i>
    br
    br

    p Durante los años 2005 al 2010 y previo a la consolidación de Android existieron diversos esfuerzos por generar una plataforma <i>opensource</i> basada en el <i>kernel</i> de Linux. Nokia tuvo su intento propio con <a href="https://en.wikipedia.org/wiki/Maemo">Maemo</a>, un kernel monolítico basado en Debian GNU/Linux y con interfaz basada en GNOME para arquitecturas ARM. Previo a la adopción de Windows Phone, Nokia abandona Maemo y, en conjunto con <a href="http://www.linuxfoundation.org/">Linux Foundation</a> e Intel crea la distribución <a href="https://en.wikipedia.org/wiki/MeeGo">MeeGo</a> con la intención de servir de plataforma para dispositivos como <i>smartphones</i>, <i>tablets</i>, <i>smartTVs</i> y <i>netbooks</i>. MeeGo nace como una mezcla de las plataformas de Nokia (Maemo) y una que estaba desarrollando Intel (Moblin, que a su vez estaba basado en Fedora). Sin embargo, en 2011, cuando Nokia adopta Windows Phone, abandona MeeGo. A partir de MeeGo, Intel se une con Samsung y Linux Foundation para desarrollar <a href="https://www.tizen.org/">Tizen</a>. En una línea paralela, la compañía finlandesa <a href="https://en.wikipedia.org/wiki/Jolla">Jolla</a> aprovecha el código <i>opensource</i> de <a href="https://en.wikipedia.org/wiki/Mer_(software_distribution)">Mer</a>, un <i>fork</i> de MeeGo y desarrolla <a href="https://sailfishos.org/">Sailfish OS</a>, un kernel monolítico con compatibilidad para Android mediante APIs, soporte para ARM y x86-64, y un fuerte énfasis en <i>multitasking</i>.

    div style="display:inline-block; width:100%; vertical-align:middle; border:none; text-align:center;"
      a href="https://commons.wikimedia.org/w/index.php?curid=27484659"
        img src='/images/figures/00-sailfish-tree.svg' width="40%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"
      div style="font-size:14px;"
        div By <a href="https://commons.wikimedia.org/w/index.php?title=User:Semsi_Paco_Virchow&amp;action=edit&amp;redlink=1" class="new" title="User:Semsi Paco Virchow (page does not exist)">User:Semsi Paco Virchow</a> - <span class="int-own-work" lang="en">Own work</span>, <a href="https://creativecommons.org/licenses/by-sa/3.0" title="Creative Commons Attribution-Share Alike 3.0">CC BY-SA 3.0</a>
    br
    br


    h4 Microsoft y el Windows Phone

    p Microsoft había desarrollado desde 1996 un sistema operativo embebido llamado <a href="http://msdn.microsoft.com/en-ph/embedded/"><b>Windows CE</b></a> (actualmente Windows Embedded Compact) diseñado para una especificación de plataformas incialmente denominado <a href="https://en.wikipedia.org/wiki/Pocket_PC">Pocket PC</a>. Los primeros dispositivos con Windows CE se lanzaron en 2002. Windows CE contenía un kernel híbrido escrito en C y soportaba arquitecturas x86, ARM, MIPS y PowerPC. La serie de sistemas operativos móviles basados en Windows CE fue conocida como <a href="https://en.wikipedia.org/wiki/Windows_Mobile">Windows Mobile</a> (incluyendo el <i>media player</i> <a href="https://en.wikipedia.org/wiki/Zune">Zune</a>) y fue desarrollado hasta 2010. Posteriormente Microsoft reimplementaría su sistema operativo móvil basado en la línea de Windows NT, dando inicio a <a href="https://en.wikipedia.org/wiki/Windows_Phone">Windows Phone</a>, línea que fue descontinuada en 2017 debido al poco interés de los desarrolladores en generar aplicaciones para esta plataforma ante la dominancia de iOS y Android.

    div style="display:inline-block; width:100%; vertical-align:middle; border:none; text-align:center;"
      img src='/images/figures/00-windows-ce.jpg' width="20%" style="background:none; border:none; box-shadow:none; vertical-align:middle;" &nbsp; &nbsp; &nbsp; 
      img src='/images/figures/00-windowsphone-lumia-650.png' width="20%" style="background:none; border:none; box-shadow:none; vertical-align:middle;" &nbsp; &nbsp; &nbsp; 
      img src='/images/figures/00-windows-phone-architecture.png' width="20%" style="background:none; border:none; box-shadow:none; vertical-align:middle;" &nbsp; &nbsp; &nbsp; 
      div style="text-align:center; font-size:14px;" <i>Logo de Windows CE. Microsfot Lumia 650 con Windows Phone. Arquitectura de Windows Phone 8.</i>
    br
    br


    h4 RIM y Blackberry OS

    p En 2002 la compañía canadiense <b>Research In Motion</b> (RIM) desarrolló su propia línea de dispositivos móviles conocidos como <a href="https://en.wikipedia.org/wiki/BlackBerry"><b>BlackBerry</b></a> y su propio sistema operativo <a href="https://en.wikipedia.org/wiki/BlackBerry_OS"><b>BlackBerry OS</b></a> (RIM con el tiempo cambiaría su nombre a BlackBerry Ltd.). BlackBerry OS era un sistema <i>multitasking</i> con soporte para aplicaciones mediante la plataforma especial para dispositivos embebidos Java Micro Edition (JavaME). Incluía soporte para WAP, un <i>stack</i> de protocolos de comunicación para móviles que dejó de ser adoptado cuando los dispositivos móviles fueron suficientemente poderosos para procesar el tradicional <i>stack</i> TCP/IP. En 2010, BlackBerry OS fue reemplazado por <a href="https://en.wikipedia.org/wiki/BlackBerry_10"><b>BlackBerry 10</b></a>, un sistema basado en el <i>microkernel</i> de tiempo real (RTOS) <a href="https://en.wikipedia.org/wiki/QNX">QNX</a>. Desde 2016, los dispositivos producidos por BlackBerry empezaron a usar Android en lugar de BlackBerry 10, cuyo soporte ha sido anunciado al menos hasta 2019.

    div style="display:inline-block; width:100%; vertical-align:middle; border:none; text-align:center;"
      img src='/images/figures/00-rim.jpg' width="20%" style="background:none; border:none; box-shadow:none; vertical-align:middle;" &nbsp; &nbsp; &nbsp; 
      img src='/images/figures/00-blackberry-curve.jpg' width="20%" style="background:none; border:none; box-shadow:none; vertical-align:middle;" &nbsp; &nbsp; &nbsp; 
      img src='/images/figures/00-blackberry10-architecture.png' width="20%" style="background:none; border:none; box-shadow:none; vertical-align:middle;" &nbsp; &nbsp; &nbsp; 
      div style="text-align:center; font-size:14px;" <i>Logo de RIM/Blackberry. Blackberry Curve 9320 con BlackberryOS 7.1. Arquitectura de Blackberry 10.</i>
    br
    br

    h4 Apple: el iPhone y iOS

    p El año 2007 ocurrió la entrada de uno de los principales competidores cuando Apple presentó su <a href="https://en.wikipedia.org/wiki/IPhone">iPhone</a> junto con su sistema operativo <a href="https://en.wikipedia.org/wiki/IOS"><b>iOS</b></a> (originalmente <i>iPhone OS</i>). iOS, al igual que MacOSX se basa en el kernel híbrido XNU y el sistema operativo (UNIX-like) Darwin. Desde el año 2010, con iOS 4, el sistema añadió soporte de APIs para <i>multitasking</i> por parte de aplicaciones de usuario. Previamente el <i>multitasking</i> estaba restringido solo a ciertos servicios del sistema. La disponibilidad del <a href="https://developer.apple.com/">iOS SDK</a> (<i>Software Development Kit</i>) atrajo el desarrollo de múltiples aplicaciones nativas disponibles desde una tienda <i>online</i> (App Store), popularizando rápidamente el uso del iPhone y posicionándolo como uno de los principales competidores.

    div style="display:inline-block; width:100%; vertical-align:middle; border:none; text-align:center;"
      img src='/images/figures/00-iphone-logo.png' width="10%" style="background:none; border:none; box-shadow:none; vertical-align:middle;" &nbsp; &nbsp; &nbsp; 
      img src='/images/figures/00-iphonex.jpg' width="15%" style="background:none; border:none; box-shadow:none; vertical-align:middle;" &nbsp; &nbsp; &nbsp; 
      img src='/images/figures/00-ios-architecture.png' width="25%" style="background:none; border:none; box-shadow:none; vertical-align:middle;" &nbsp; &nbsp; &nbsp; 
      a href="http://www.knowstack.com/cocoa-layered-architecture-for-mac-osx/"
        img src='/images/figures/00-macosx-cocoa-architecture.jpg' width="25%" style="background:none; border:none; box-shadow:none; vertical-align:middle;" &nbsp; &nbsp; &nbsp; 
      div style="text-align:center; font-size:14px;" <i>Logo de iPhone. iPhone X (2018). Arquitectura general de iOS. Arquitectura detallada de MacOSX, que comparte muchas características con iOS.</i>
    br
    br


    h4 Android, la entrada de Google

    p Meses después del lanzamiento del primer iPhone, un conjunto de compañías lideradas por <a href="http://google.com/"><b>Google</b></a>, incluyendo a HTC, Sony, Dell, Intel, Motorola, Samsung, LG, Nvidia, entre otros, forman la <a href="http://www.openhandsetalliance.com/"><b>Open Handset Alliance</b></a> (OHA). Con el soporte de OHA, Google lanza en 2008 la primera versión de <a href="https://android.com/"><b><i>Android</i></b></a>, un sistema operativo monolítico (UNIX-like) de código abierto basado en el <i>kernel</i> Linux. Android inició su desarrollo bajo la compañía Android, Inc. fundada en 2003. El año 2005 Google adquirió Android, Inc. y fue bajo su alero que el equipo de desarrollo terminó la primera versión <a href="https://en.wikipedia.org/wiki/Android_version_history#Android_1.0.0_(API_1)">Android 1.0</a>. De manera similar a App Store, Android lanzó el <i>Android Market</i> (más tarde <i>Google Play Store</i>), y el <a href="http://developer.android.com/sdk/index.html">Android SDK</a> para el desarrollo de aplicaciones (escritas principalmente en Java, y recientemente en Kotlin) para terceros. El soporte de OHA, integrado por importantes actores del mercado <i>smartphone</i> fue clave para posicionar a Android como el sistema operativo dominador en los dispositivos móviles desde el año 2010, con iOS como su único (y distante) competidor real.

    p A diferencia de Linux, el kernel de Android no utiliza la tradicional GNU C Library <code>glibc</code>, sino que utiliza una implementación alternativa de la biblioteca de C desarrollado por Google, llamada <a href="https://en.wikipedia.org/wiki/Bionic_(software)">Bionic</a>, la cual posee un menor <i>memory footprint</i> que <code>glibc</code> y fue diseñado para CPUs funcionando a menor frecuencia de <i>clock</i> (y por lo tanto, optimizada para menor consumo energético). Bionic, sin embargo, no implementa toda la interfaz POSIX, haciendo que Android sea <i>Non-POSIX compliant</i>.

    div style="display:inline-block; width:100%; vertical-align:middle; border:none; text-align:center;"
      img src='/images/figures/00-android-logo.jpg' width="20%" style="background:none; border:none; box-shadow:none; vertical-align:middle;"
      img src='/images/figures/00-oha-members.jpg' width="30%" style="background:none; border:none; box-shadow:none; vertical-align:middle;" &nbsp; 
      img src='/images/figures/00-android-phones.jpg' width="20%" style="background:none; border:none; box-shadow:none; vertical-align:middle;" &nbsp; 
      a href="https://commons.wikimedia.org/w/index.php?curid=20067152"
        img src='/images/figures/00-android-architecture.svg' width="25%" style="background:none; border:none; box-shadow:none; vertical-align:middle;" 
      div style="text-align:center; font-size:14px;" <i>Logo de Android. Miembros de OHA. Algunos smartphones Android. Arquitecture de Android, by <a href="//commons.wikimedia.org/w/index.php?title=User:Smieh&amp;action=edit&amp;redlink=1" class="new" title="User:Smieh (page does not exist)">Smieh</a> <a rel="nofollow" class="external text" href="http://androidteam.googlecode.com/files/Anatomy-Physiology-of-an-Android.pdf">Anatomy Physiology of an Android</a>, <a href="https://creativecommons.org/licenses/by-sa/3.0" title="Creative Commons Attribution-Share Alike 3.0">CC BY-SA 3.0</a></i>
    br
    br

    











  section 
    h5 Sources


    ul
      li Tanenbaum, "Modern Operating Systems", 4th Ed. Sección 1.2.
      li Wikipedia
      li etc

